
--Converted with ttyyuu12345's model to script plugin v4
function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Folder0 = Instance.new("Folder")
Script1 = Instance.new("Script")
Tool2 = Instance.new("Tool")
Configuration3 = Instance.new("Configuration")
IntValue4 = Instance.new("IntValue")
StringValue5 = Instance.new("StringValue")
StringValue6 = Instance.new("StringValue")
NumberValue7 = Instance.new("NumberValue")
NumberValue8 = Instance.new("NumberValue")
NumberValue9 = Instance.new("NumberValue")
NumberValue10 = Instance.new("NumberValue")
NumberValue11 = Instance.new("NumberValue")
NumberValue12 = Instance.new("NumberValue")
NumberValue13 = Instance.new("NumberValue")
NumberValue14 = Instance.new("NumberValue")
StringValue15 = Instance.new("StringValue")
NumberValue16 = Instance.new("NumberValue")
NumberValue17 = Instance.new("NumberValue")
Part18 = Instance.new("Part")
Model19 = Instance.new("Model")
MeshPart20 = Instance.new("MeshPart")
Beam21 = Instance.new("Beam")
WeldConstraint22 = Instance.new("WeldConstraint")
Motor6D23 = Instance.new("Motor6D")
Sound24 = Instance.new("Sound")
Sound25 = Instance.new("Sound")
MeshPart26 = Instance.new("MeshPart")
MeshPart27 = Instance.new("MeshPart")
StringValue28 = Instance.new("StringValue")
Folder29 = Instance.new("Folder")
IntValue30 = Instance.new("IntValue")
RemoteEvent31 = Instance.new("RemoteEvent")
Folder32 = Instance.new("Folder")
ScreenGui33 = Instance.new("ScreenGui")
Frame34 = Instance.new("Frame")
ImageLabel35 = Instance.new("ImageLabel")
UIAspectRatioConstraint36 = Instance.new("UIAspectRatioConstraint")
Frame37 = Instance.new("Frame")
Frame38 = Instance.new("Frame")
Frame39 = Instance.new("Frame")
Frame40 = Instance.new("Frame")
Frame41 = Instance.new("Frame")
ImageButton42 = Instance.new("ImageButton")
ImageButton43 = Instance.new("ImageButton")
Frame44 = Instance.new("Frame")
ImageButton45 = Instance.new("ImageButton")
ImageButton46 = Instance.new("ImageButton")
Folder47 = Instance.new("Folder")
Frame48 = Instance.new("Frame")
ImageLabel49 = Instance.new("ImageLabel")
ImageLabel50 = Instance.new("ImageLabel")
ImageLabel51 = Instance.new("ImageLabel")
ImageLabel52 = Instance.new("ImageLabel")
UIAspectRatioConstraint53 = Instance.new("UIAspectRatioConstraint")
Frame54 = Instance.new("Frame")
ImageLabel55 = Instance.new("ImageLabel")
UIAspectRatioConstraint56 = Instance.new("UIAspectRatioConstraint")
Folder57 = Instance.new("Folder")
Frame58 = Instance.new("Frame")
ImageLabel59 = Instance.new("ImageLabel")
UIAspectRatioConstraint60 = Instance.new("UIAspectRatioConstraint")
Configuration61 = Instance.new("Configuration")
StringValue62 = Instance.new("StringValue")
NumberValue63 = Instance.new("NumberValue")
NumberValue64 = Instance.new("NumberValue")
NumberValue65 = Instance.new("NumberValue")
NumberValue66 = Instance.new("NumberValue")
NumberValue67 = Instance.new("NumberValue")
UIAspectRatioConstraint68 = Instance.new("UIAspectRatioConstraint")
Folder69 = Instance.new("Folder")
Animation70 = Instance.new("Animation")
Animation71 = Instance.new("Animation")
Animation72 = Instance.new("Animation")
Folder73 = Instance.new("Folder")
Folder74 = Instance.new("Folder")
Part75 = Instance.new("Part")
ParticleEmitter76 = Instance.new("ParticleEmitter")
Beam77 = Instance.new("Beam")
Beam78 = Instance.new("Beam")
ParticleEmitter79 = Instance.new("ParticleEmitter")
Sound80 = Instance.new("Sound")
Part81 = Instance.new("Part")
Beam82 = Instance.new("Beam")
Beam83 = Instance.new("Beam")
Sound84 = Instance.new("Sound")
SpecialMesh85 = Instance.new("SpecialMesh")
Sound86 = Instance.new("Sound")
Part87 = Instance.new("Part")
Beam88 = Instance.new("Beam")
Beam89 = Instance.new("Beam")
ParticleEmitter90 = Instance.new("ParticleEmitter")
Sound91 = Instance.new("Sound")
SpecialMesh92 = Instance.new("SpecialMesh")
Part93 = Instance.new("Part")
ParticleEmitter94 = Instance.new("ParticleEmitter")
Beam95 = Instance.new("Beam")
Beam96 = Instance.new("Beam")
ParticleEmitter97 = Instance.new("ParticleEmitter")
Sound98 = Instance.new("Sound")
SpecialMesh99 = Instance.new("SpecialMesh")
Sound100 = Instance.new("Sound")
Part101 = Instance.new("Part")
Beam102 = Instance.new("Beam")
Beam103 = Instance.new("Beam")
Sound104 = Instance.new("Sound")
ParticleEmitter105 = Instance.new("ParticleEmitter")
ParticleEmitter106 = Instance.new("ParticleEmitter")
Part107 = Instance.new("Part")
ParticleEmitter108 = Instance.new("ParticleEmitter")
Beam109 = Instance.new("Beam")
Beam110 = Instance.new("Beam")
ParticleEmitter111 = Instance.new("ParticleEmitter")
Sound112 = Instance.new("Sound")
Part113 = Instance.new("Part")
Beam114 = Instance.new("Beam")
Beam115 = Instance.new("Beam")
Sound116 = Instance.new("Sound")
ParticleEmitter117 = Instance.new("ParticleEmitter")
Folder118 = Instance.new("Folder")
Part119 = Instance.new("Part")
BillboardGui120 = Instance.new("BillboardGui")
ImageLabel121 = Instance.new("ImageLabel")
Decal122 = Instance.new("Decal")
Part123 = Instance.new("Part")
Decal124 = Instance.new("Decal")
Part125 = Instance.new("Part")
SpecialMesh126 = Instance.new("SpecialMesh")
Part127 = Instance.new("Part")
Decal128 = Instance.new("Decal")
Decal129 = Instance.new("Decal")
Part130 = Instance.new("Part")
Decal131 = Instance.new("Decal")
Decal132 = Instance.new("Decal")
Folder133 = Instance.new("Folder")
MeshPart134 = Instance.new("MeshPart")
Sound135 = Instance.new("Sound")
MeshPart136 = Instance.new("MeshPart")
Sound137 = Instance.new("Sound")
Script138 = Instance.new("Script")
LocalScript139 = Instance.new("LocalScript")
Folder140 = Instance.new("Folder")
ModuleScript141 = Instance.new("ModuleScript")
ModuleScript142 = Instance.new("ModuleScript")
ModuleScript143 = Instance.new("ModuleScript")
Folder144 = Instance.new("Folder")
BoolValue145 = Instance.new("BoolValue")
BoolValue146 = Instance.new("BoolValue")
Folder147 = Instance.new("Folder")
ModuleScript148 = Instance.new("ModuleScript")
ModuleScript149 = Instance.new("ModuleScript")
ModuleScript150 = Instance.new("ModuleScript")
ModuleScript151 = Instance.new("ModuleScript")
ModuleScript152 = Instance.new("ModuleScript")
ModuleScript153 = Instance.new("ModuleScript")
ModuleScript154 = Instance.new("ModuleScript")
ModuleScript155 = Instance.new("ModuleScript")
ModuleScript156 = Instance.new("ModuleScript")
ModuleScript157 = Instance.new("ModuleScript")
ModuleScript158 = Instance.new("ModuleScript")
Tool159 = Instance.new("Tool")
Configuration160 = Instance.new("Configuration")
IntValue161 = Instance.new("IntValue")
StringValue162 = Instance.new("StringValue")
StringValue163 = Instance.new("StringValue")
NumberValue164 = Instance.new("NumberValue")
NumberValue165 = Instance.new("NumberValue")
NumberValue166 = Instance.new("NumberValue")
NumberValue167 = Instance.new("NumberValue")
NumberValue168 = Instance.new("NumberValue")
NumberValue169 = Instance.new("NumberValue")
NumberValue170 = Instance.new("NumberValue")
NumberValue171 = Instance.new("NumberValue")
StringValue172 = Instance.new("StringValue")
NumberValue173 = Instance.new("NumberValue")
NumberValue174 = Instance.new("NumberValue")
Part175 = Instance.new("Part")
Model176 = Instance.new("Model")
MeshPart177 = Instance.new("MeshPart")
Beam178 = Instance.new("Beam")
WeldConstraint179 = Instance.new("WeldConstraint")
Sound180 = Instance.new("Sound")
Sound181 = Instance.new("Sound")
MeshPart182 = Instance.new("MeshPart")
MeshPart183 = Instance.new("MeshPart")
StringValue184 = Instance.new("StringValue")
Folder185 = Instance.new("Folder")
IntValue186 = Instance.new("IntValue")
RemoteEvent187 = Instance.new("RemoteEvent")
Folder188 = Instance.new("Folder")
ScreenGui189 = Instance.new("ScreenGui")
Frame190 = Instance.new("Frame")
ImageLabel191 = Instance.new("ImageLabel")
UIAspectRatioConstraint192 = Instance.new("UIAspectRatioConstraint")
Frame193 = Instance.new("Frame")
Frame194 = Instance.new("Frame")
Frame195 = Instance.new("Frame")
Frame196 = Instance.new("Frame")
Frame197 = Instance.new("Frame")
ImageButton198 = Instance.new("ImageButton")
ImageButton199 = Instance.new("ImageButton")
Frame200 = Instance.new("Frame")
ImageButton201 = Instance.new("ImageButton")
ImageButton202 = Instance.new("ImageButton")
Folder203 = Instance.new("Folder")
Frame204 = Instance.new("Frame")
ImageLabel205 = Instance.new("ImageLabel")
ImageLabel206 = Instance.new("ImageLabel")
ImageLabel207 = Instance.new("ImageLabel")
ImageLabel208 = Instance.new("ImageLabel")
UIAspectRatioConstraint209 = Instance.new("UIAspectRatioConstraint")
Frame210 = Instance.new("Frame")
UIAspectRatioConstraint211 = Instance.new("UIAspectRatioConstraint")
ImageLabel212 = Instance.new("ImageLabel")
Folder213 = Instance.new("Folder")
Frame214 = Instance.new("Frame")
ImageLabel215 = Instance.new("ImageLabel")
UIAspectRatioConstraint216 = Instance.new("UIAspectRatioConstraint")
Configuration217 = Instance.new("Configuration")
StringValue218 = Instance.new("StringValue")
NumberValue219 = Instance.new("NumberValue")
NumberValue220 = Instance.new("NumberValue")
NumberValue221 = Instance.new("NumberValue")
NumberValue222 = Instance.new("NumberValue")
NumberValue223 = Instance.new("NumberValue")
UIAspectRatioConstraint224 = Instance.new("UIAspectRatioConstraint")
Folder225 = Instance.new("Folder")
Animation226 = Instance.new("Animation")
Animation227 = Instance.new("Animation")
Animation228 = Instance.new("Animation")
Folder229 = Instance.new("Folder")
Folder230 = Instance.new("Folder")
Part231 = Instance.new("Part")
ParticleEmitter232 = Instance.new("ParticleEmitter")
Beam233 = Instance.new("Beam")
Beam234 = Instance.new("Beam")
ParticleEmitter235 = Instance.new("ParticleEmitter")
Sound236 = Instance.new("Sound")
Part237 = Instance.new("Part")
Beam238 = Instance.new("Beam")
Beam239 = Instance.new("Beam")
Sound240 = Instance.new("Sound")
SpecialMesh241 = Instance.new("SpecialMesh")
Sound242 = Instance.new("Sound")
Part243 = Instance.new("Part")
Beam244 = Instance.new("Beam")
Beam245 = Instance.new("Beam")
ParticleEmitter246 = Instance.new("ParticleEmitter")
Sound247 = Instance.new("Sound")
SpecialMesh248 = Instance.new("SpecialMesh")
Part249 = Instance.new("Part")
ParticleEmitter250 = Instance.new("ParticleEmitter")
Beam251 = Instance.new("Beam")
Beam252 = Instance.new("Beam")
ParticleEmitter253 = Instance.new("ParticleEmitter")
Sound254 = Instance.new("Sound")
SpecialMesh255 = Instance.new("SpecialMesh")
Sound256 = Instance.new("Sound")
Part257 = Instance.new("Part")
Beam258 = Instance.new("Beam")
Beam259 = Instance.new("Beam")
Sound260 = Instance.new("Sound")
ParticleEmitter261 = Instance.new("ParticleEmitter")
ParticleEmitter262 = Instance.new("ParticleEmitter")
Part263 = Instance.new("Part")
ParticleEmitter264 = Instance.new("ParticleEmitter")
Beam265 = Instance.new("Beam")
Beam266 = Instance.new("Beam")
ParticleEmitter267 = Instance.new("ParticleEmitter")
Sound268 = Instance.new("Sound")
Part269 = Instance.new("Part")
Beam270 = Instance.new("Beam")
Beam271 = Instance.new("Beam")
Sound272 = Instance.new("Sound")
ParticleEmitter273 = Instance.new("ParticleEmitter")
Folder274 = Instance.new("Folder")
Part275 = Instance.new("Part")
BillboardGui276 = Instance.new("BillboardGui")
ImageLabel277 = Instance.new("ImageLabel")
Decal278 = Instance.new("Decal")
Part279 = Instance.new("Part")
Decal280 = Instance.new("Decal")
Part281 = Instance.new("Part")
SpecialMesh282 = Instance.new("SpecialMesh")
Part283 = Instance.new("Part")
Decal284 = Instance.new("Decal")
Decal285 = Instance.new("Decal")
Part286 = Instance.new("Part")
Decal287 = Instance.new("Decal")
Decal288 = Instance.new("Decal")
Folder289 = Instance.new("Folder")
MeshPart290 = Instance.new("MeshPart")
Sound291 = Instance.new("Sound")
MeshPart292 = Instance.new("MeshPart")
Sound293 = Instance.new("Sound")
LocalScript294 = Instance.new("LocalScript")
ModuleScript295 = Instance.new("ModuleScript")
Folder296 = Instance.new("Folder")
ModuleScript297 = Instance.new("ModuleScript")
ModuleScript298 = Instance.new("ModuleScript")
Script299 = Instance.new("Script")
Folder300 = Instance.new("Folder")
BoolValue301 = Instance.new("BoolValue")
BoolValue302 = Instance.new("BoolValue")
Folder303 = Instance.new("Folder")
ModuleScript304 = Instance.new("ModuleScript")
ModuleScript305 = Instance.new("ModuleScript")
ModuleScript306 = Instance.new("ModuleScript")
ModuleScript307 = Instance.new("ModuleScript")
ModuleScript308 = Instance.new("ModuleScript")
ModuleScript309 = Instance.new("ModuleScript")
ModuleScript310 = Instance.new("ModuleScript")
ModuleScript311 = Instance.new("ModuleScript")
ModuleScript312 = Instance.new("ModuleScript")
ModuleScript313 = Instance.new("ModuleScript")
ModuleScript314 = Instance.new("ModuleScript")
Tool315 = Instance.new("Tool")
Configuration316 = Instance.new("Configuration")
IntValue317 = Instance.new("IntValue")
StringValue318 = Instance.new("StringValue")
StringValue319 = Instance.new("StringValue")
NumberValue320 = Instance.new("NumberValue")
NumberValue321 = Instance.new("NumberValue")
NumberValue322 = Instance.new("NumberValue")
NumberValue323 = Instance.new("NumberValue")
NumberValue324 = Instance.new("NumberValue")
NumberValue325 = Instance.new("NumberValue")
NumberValue326 = Instance.new("NumberValue")
NumberValue327 = Instance.new("NumberValue")
StringValue328 = Instance.new("StringValue")
NumberValue329 = Instance.new("NumberValue")
NumberValue330 = Instance.new("NumberValue")
Part331 = Instance.new("Part")
Model332 = Instance.new("Model")
MeshPart333 = Instance.new("MeshPart")
Beam334 = Instance.new("Beam")
WeldConstraint335 = Instance.new("WeldConstraint")
Sound336 = Instance.new("Sound")
Sound337 = Instance.new("Sound")
MeshPart338 = Instance.new("MeshPart")
MeshPart339 = Instance.new("MeshPart")
StringValue340 = Instance.new("StringValue")
Folder341 = Instance.new("Folder")
IntValue342 = Instance.new("IntValue")
RemoteEvent343 = Instance.new("RemoteEvent")
Folder344 = Instance.new("Folder")
ScreenGui345 = Instance.new("ScreenGui")
Frame346 = Instance.new("Frame")
ImageLabel347 = Instance.new("ImageLabel")
UIAspectRatioConstraint348 = Instance.new("UIAspectRatioConstraint")
Frame349 = Instance.new("Frame")
Frame350 = Instance.new("Frame")
Frame351 = Instance.new("Frame")
Frame352 = Instance.new("Frame")
Frame353 = Instance.new("Frame")
ImageButton354 = Instance.new("ImageButton")
ImageButton355 = Instance.new("ImageButton")
Frame356 = Instance.new("Frame")
ImageButton357 = Instance.new("ImageButton")
ImageButton358 = Instance.new("ImageButton")
Folder359 = Instance.new("Folder")
Frame360 = Instance.new("Frame")
ImageLabel361 = Instance.new("ImageLabel")
ImageLabel362 = Instance.new("ImageLabel")
ImageLabel363 = Instance.new("ImageLabel")
ImageLabel364 = Instance.new("ImageLabel")
UIAspectRatioConstraint365 = Instance.new("UIAspectRatioConstraint")
Frame366 = Instance.new("Frame")
UIAspectRatioConstraint367 = Instance.new("UIAspectRatioConstraint")
ImageLabel368 = Instance.new("ImageLabel")
Folder369 = Instance.new("Folder")
Frame370 = Instance.new("Frame")
ImageLabel371 = Instance.new("ImageLabel")
UIAspectRatioConstraint372 = Instance.new("UIAspectRatioConstraint")
Configuration373 = Instance.new("Configuration")
StringValue374 = Instance.new("StringValue")
NumberValue375 = Instance.new("NumberValue")
NumberValue376 = Instance.new("NumberValue")
NumberValue377 = Instance.new("NumberValue")
NumberValue378 = Instance.new("NumberValue")
NumberValue379 = Instance.new("NumberValue")
UIAspectRatioConstraint380 = Instance.new("UIAspectRatioConstraint")
Folder381 = Instance.new("Folder")
Animation382 = Instance.new("Animation")
Animation383 = Instance.new("Animation")
Animation384 = Instance.new("Animation")
Folder385 = Instance.new("Folder")
Folder386 = Instance.new("Folder")
Part387 = Instance.new("Part")
ParticleEmitter388 = Instance.new("ParticleEmitter")
Beam389 = Instance.new("Beam")
Beam390 = Instance.new("Beam")
ParticleEmitter391 = Instance.new("ParticleEmitter")
Sound392 = Instance.new("Sound")
Part393 = Instance.new("Part")
Beam394 = Instance.new("Beam")
Beam395 = Instance.new("Beam")
Sound396 = Instance.new("Sound")
SpecialMesh397 = Instance.new("SpecialMesh")
Sound398 = Instance.new("Sound")
Part399 = Instance.new("Part")
Beam400 = Instance.new("Beam")
Beam401 = Instance.new("Beam")
ParticleEmitter402 = Instance.new("ParticleEmitter")
Sound403 = Instance.new("Sound")
SpecialMesh404 = Instance.new("SpecialMesh")
Part405 = Instance.new("Part")
ParticleEmitter406 = Instance.new("ParticleEmitter")
Beam407 = Instance.new("Beam")
Beam408 = Instance.new("Beam")
ParticleEmitter409 = Instance.new("ParticleEmitter")
Sound410 = Instance.new("Sound")
SpecialMesh411 = Instance.new("SpecialMesh")
Sound412 = Instance.new("Sound")
Part413 = Instance.new("Part")
Beam414 = Instance.new("Beam")
Beam415 = Instance.new("Beam")
Sound416 = Instance.new("Sound")
ParticleEmitter417 = Instance.new("ParticleEmitter")
ParticleEmitter418 = Instance.new("ParticleEmitter")
Part419 = Instance.new("Part")
ParticleEmitter420 = Instance.new("ParticleEmitter")
Beam421 = Instance.new("Beam")
Beam422 = Instance.new("Beam")
ParticleEmitter423 = Instance.new("ParticleEmitter")
Sound424 = Instance.new("Sound")
Part425 = Instance.new("Part")
Beam426 = Instance.new("Beam")
Beam427 = Instance.new("Beam")
Sound428 = Instance.new("Sound")
ParticleEmitter429 = Instance.new("ParticleEmitter")
Folder430 = Instance.new("Folder")
Part431 = Instance.new("Part")
BillboardGui432 = Instance.new("BillboardGui")
ImageLabel433 = Instance.new("ImageLabel")
Decal434 = Instance.new("Decal")
Part435 = Instance.new("Part")
Decal436 = Instance.new("Decal")
Part437 = Instance.new("Part")
SpecialMesh438 = Instance.new("SpecialMesh")
Part439 = Instance.new("Part")
Decal440 = Instance.new("Decal")
Decal441 = Instance.new("Decal")
Part442 = Instance.new("Part")
Decal443 = Instance.new("Decal")
Decal444 = Instance.new("Decal")
Folder445 = Instance.new("Folder")
MeshPart446 = Instance.new("MeshPart")
Sound447 = Instance.new("Sound")
MeshPart448 = Instance.new("MeshPart")
Sound449 = Instance.new("Sound")
LocalScript450 = Instance.new("LocalScript")
ModuleScript451 = Instance.new("ModuleScript")
Folder452 = Instance.new("Folder")
ModuleScript453 = Instance.new("ModuleScript")
ModuleScript454 = Instance.new("ModuleScript")
Script455 = Instance.new("Script")
Folder456 = Instance.new("Folder")
BoolValue457 = Instance.new("BoolValue")
BoolValue458 = Instance.new("BoolValue")
Folder459 = Instance.new("Folder")
ModuleScript460 = Instance.new("ModuleScript")
ModuleScript461 = Instance.new("ModuleScript")
ModuleScript462 = Instance.new("ModuleScript")
ModuleScript463 = Instance.new("ModuleScript")
ModuleScript464 = Instance.new("ModuleScript")
ModuleScript465 = Instance.new("ModuleScript")
ModuleScript466 = Instance.new("ModuleScript")
ModuleScript467 = Instance.new("ModuleScript")
ModuleScript468 = Instance.new("ModuleScript")
ModuleScript469 = Instance.new("ModuleScript")
ModuleScript470 = Instance.new("ModuleScript")
Folder0.Name = "hi"
Folder0.Parent = mas
Script1.Parent = Folder0
table.insert(cors,sandbox(Script1,function()
wait(0.2)
game.Workspace.AR.Handle.Position = game.Workspace.spumato.Torso.Position
game.Workspace.AR.Handle.Position = game.Workspace.spumato.Torso.Position
game.Workspace.AR.Handle.Position = game.Workspace.spumato.Torso.Position

end))
Tool2.Name = "AR"
Tool2.Parent = Folder0
Configuration3.Parent = Tool2
IntValue4.Name = "AmmoCapacity"
IntValue4.Parent = Configuration3
IntValue4.Value = 30
StringValue5.Name = "CasingEffect"
StringValue5.Parent = Configuration3
StringValue5.Value = "RifleCasing"
StringValue6.Name = "FireMode"
StringValue6.Parent = Configuration3
StringValue6.Value = "Automatic"
NumberValue7.Name = "GravityFactor"
NumberValue7.Parent = Configuration3
NumberValue7.Value = 0.5
NumberValue8.Name = "HitDamage"
NumberValue8.Parent = Configuration3
NumberValue8.Value = 14
NumberValue9.Name = "MuzzleFlashSize0"
NumberValue9.Parent = Configuration3
NumberValue9.Value = 1.1
NumberValue10.Name = "MuzzleFlashSize1"
NumberValue10.Parent = Configuration3
NumberValue10.Value = 1.4
NumberValue11.Name = "RecoilDecay"
NumberValue11.Parent = Configuration3
NumberValue11.Value = 0.81
NumberValue12.Name = "RecoilMax"
NumberValue12.Parent = Configuration3
NumberValue12.Value = 0.9
NumberValue13.Name = "RecoilMin"
NumberValue13.Parent = Configuration3
NumberValue13.Value = 0.7
NumberValue14.Name = "ShotCooldown"
NumberValue14.Parent = Configuration3
NumberValue14.Value = 0.125
StringValue15.Name = "ShotEffect"
StringValue15.Parent = Configuration3
StringValue15.Value = "Bullet"
NumberValue16.Name = "TotalRecoilMax"
NumberValue16.Parent = Configuration3
NumberValue16.Value = 1.1
NumberValue17.Name = "MaxSpread"
NumberValue17.Parent = Configuration3
NumberValue17.Value = 0.6
Part18.Name = "Handle"
Part18.Parent = Tool2
Part18.CFrame = CFrame.new(-4.06429482, 1.02535903, -11.4182281, -0.00140200043, -0.0122989975, -0.999923468, 0.0607290231, 0.99807775, -0.0123614455, 0.998153329, -0.060741704, -0.00065239938)
Part18.Orientation = Vector3.new(0.709999979, -90.0400009, 3.48000002)
Part18.Position = Vector3.new(-4.06429482, 1.02535903, -11.4182281)
Part18.Rotation = Vector3.new(93.0199966, -89.2900009, 96.5)
Part18.Transparency = 1
Part18.Size = Vector3.new(0.5, 1, 3)
Part18.BottomSurface = Enum.SurfaceType.Smooth
Part18.CanCollide = false
Part18.TopSurface = Enum.SurfaceType.Smooth
Model19.Name = "AR"
Model19.Parent = Tool2
Model19.PrimaryPart = MeshPart20
MeshPart20.Name = "Rifle"
MeshPart20.Parent = Model19
MeshPart20.CFrame = CFrame.new(-4.18927908, 1.02377498, -11.4182425, -0.00140200043, -0.0122989975, -0.999923468, 0.0607290231, 0.99807775, -0.0123614455, 0.998153329, -0.060741704, -0.00065239938)
MeshPart20.Orientation = Vector3.new(0.709999979, -90.0400009, 3.48000002)
MeshPart20.Position = Vector3.new(-4.18927908, 1.02377498, -11.4182425)
MeshPart20.Rotation = Vector3.new(93.0199966, -89.2900009, 96.5)
MeshPart20.Size = Vector3.new(0.194108516, 1.05410731, 4.72941303)
MeshPart20.Material = Enum.Material.Metal
MeshPart20.TextureID = "rbxassetid://2492896951"
Beam21.Name = "MuzzleFlash"
Beam21.Parent = MeshPart20
Beam21.Attachment0 = nil
Beam21.Attachment1 = nil
Beam21.Color = ColorSequence.new(Color3.new(0.839216, 0.670588, 0),Color3.new(1, 0.917647, 0.435294))
Beam21.Enabled = false
Beam21.LightEmission = 1
Beam21.Segments = 5
Beam21.Texture = "rbxassetid://872910628"
Beam21.TextureSpeed = 0
Beam21.Transparency = NumberSequence.new(0,0)
WeldConstraint22.Parent = MeshPart20
WeldConstraint22.Part0 = MeshPart20
WeldConstraint22.Part1 = MeshPart26
Motor6D23.Name = "BoltMotor"
Motor6D23.Parent = MeshPart20
Motor6D23.C0 = CFrame.new(-0.0709371567, 0.350013733, -0.0323791504, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Motor6D23.Part0 = MeshPart20
Motor6D23.Part1 = MeshPart27
Motor6D23.part1 = MeshPart27
Sound24.Name = "Fired"
Sound24.Parent = MeshPart20
Sound24.SoundId = "rbxassetid://3806349898"
Sound25.Name = "Reload"
Sound25.Parent = MeshPart20
Sound25.SoundId = "rbxassetid://3821787597"
MeshPart26.Name = "Magazine"
MeshPart26.Parent = Model19
MeshPart26.CFrame = CFrame.new(-4.25482321, 0.684796691, -11.3909864, -0.00140200043, -0.0122989975, -0.999923468, 0.0607290231, 0.99807775, -0.0123614455, 0.998153329, -0.060741704, -0.00065239938)
MeshPart26.Orientation = Vector3.new(0.709999979, -90.0400009, 3.48000002)
MeshPart26.Position = Vector3.new(-4.25482321, 0.684796691, -11.3909864)
MeshPart26.Rotation = Vector3.new(93.0199966, -89.2900009, 96.5)
MeshPart26.Color = Color3.new(0.290196, 0.278431, 0.286275)
MeshPart26.Size = Vector3.new(0.100694895, 1.03380096, 0.625120997)
MeshPart26.BrickColor = BrickColor.new("Dark taupe")
MeshPart26.Material = Enum.Material.Metal
MeshPart26.brickColor = BrickColor.new("Dark taupe")
MeshPart27.Name = "Bolt"
MeshPart27.Parent = Model19
MeshPart27.CFrame = CFrame.new(-4.16110754, 1.36920822, -11.5102882, -0.00140200043, -0.0122989975, -0.999923468, 0.0607290231, 0.99807775, -0.0123614455, 0.998153329, -0.060741704, -0.00065239938)
MeshPart27.Orientation = Vector3.new(0.709999979, -90.0400009, 3.48000002)
MeshPart27.Position = Vector3.new(-4.16110754, 1.36920822, -11.5102882)
MeshPart27.Rotation = Vector3.new(93.0199966, -89.2900009, 96.5)
MeshPart27.Color = Color3.new(0.388235, 0.372549, 0.384314)
MeshPart27.Size = Vector3.new(0.22213085, 0.126657262, 0.561310232)
MeshPart27.BrickColor = BrickColor.new("Dark stone grey")
MeshPart27.Material = Enum.Material.Metal
MeshPart27.brickColor = BrickColor.new("Dark stone grey")
StringValue28.Name = "WeaponType"
StringValue28.Parent = Tool2
StringValue28.Value = "BulletWeapon"
Folder29.Name = "WeaponsSystem"
Folder29.Parent = Tool2
IntValue30.Name = "Version"
IntValue30.Parent = Folder29
RemoteEvent31.Name = "WeaponData"
RemoteEvent31.Parent = Folder29
Folder32.Name = "Assets"
Folder32.Parent = Folder29
ScreenGui33.Name = "WeaponsSystemGui"
ScreenGui33.Parent = Folder32
ScreenGui33.AutoLocalize = false
ScreenGui33.Localize = false
ScreenGui33.ResetOnSpawn = false
ScreenGui33.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui33.DisplayOrder = 10000
Frame34.Name = "Scope"
Frame34.Parent = ScreenGui33
Frame34.Visible = false
Frame34.Size = UDim2.new(1, 0, 1, 0)
Frame34.BackgroundColor = BrickColor.new("Institutional white")
Frame34.BackgroundColor3 = Color3.new(1, 1, 1)
Frame34.BackgroundTransparency = 1
Frame34.ZIndex = 5
ImageLabel35.Name = "ScopeImage"
ImageLabel35.Parent = Frame34
ImageLabel35.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel35.Size = UDim2.new(1, 0, 0.949999988, 0)
ImageLabel35.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel35.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel35.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel35.BackgroundTransparency = 1
ImageLabel35.ZIndex = 2
ImageLabel35.Image = "rbxassetid://1598134910"
UIAspectRatioConstraint36.Parent = ImageLabel35
Frame37.Name = "LeftBlack"
Frame37.Parent = ImageLabel35
Frame37.Position = UDim2.new(0, 0, 0.5, 0)
Frame37.Size = UDim2.new(1, 0, 1, 0)
Frame37.AnchorPoint = Vector2.new(1, 0.5)
Frame37.BackgroundColor = BrickColor.new("Really black")
Frame37.BackgroundColor3 = Color3.new(0, 0, 0)
Frame37.BorderSizePixel = 0
Frame38.Name = "RightBlack"
Frame38.Parent = ImageLabel35
Frame38.Position = UDim2.new(1, 0, 0.5, 0)
Frame38.Size = UDim2.new(1, 0, 1, 0)
Frame38.AnchorPoint = Vector2.new(0, 0.5)
Frame38.BackgroundColor = BrickColor.new("Really black")
Frame38.BackgroundColor3 = Color3.new(0, 0, 0)
Frame38.BorderSizePixel = 0
Frame39.Name = "BottomBlack"
Frame39.Parent = ImageLabel35
Frame39.Position = UDim2.new(0.5, 0, 1, 0)
Frame39.Size = UDim2.new(5, 0, 1, 0)
Frame39.AnchorPoint = Vector2.new(0.5, 0)
Frame39.BackgroundColor = BrickColor.new("Really black")
Frame39.BackgroundColor3 = Color3.new(0, 0, 0)
Frame39.BorderSizePixel = 0
Frame40.Name = "TopBlack"
Frame40.Parent = ImageLabel35
Frame40.Position = UDim2.new(0.5, 0, 0, 0)
Frame40.Size = UDim2.new(5, 0, 1, 0)
Frame40.AnchorPoint = Vector2.new(0.5, 1)
Frame40.BackgroundColor = BrickColor.new("Really black")
Frame40.BackgroundColor3 = Color3.new(0, 0, 0)
Frame40.BorderSizePixel = 0
Frame41.Name = "SmallTouchscreen"
Frame41.Parent = ScreenGui33
Frame41.Visible = false
Frame41.Size = UDim2.new(1, 0, 1, 0)
Frame41.BackgroundColor = BrickColor.new("Institutional white")
Frame41.BackgroundColor3 = Color3.new(1, 1, 1)
Frame41.BackgroundTransparency = 1
Frame41.ZIndex = 10
ImageButton42.Name = "FireButton"
ImageButton42.Parent = Frame41
ImageButton42.Position = UDim2.new(1, -95, 1, -90)
ImageButton42.Size = UDim2.new(0, 72, 0, 72)
ImageButton42.Active = false
ImageButton42.BackgroundColor = BrickColor.new("Institutional white")
ImageButton42.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton42.BackgroundTransparency = 1
ImageButton42.ZIndex = 10
ImageButton42.Image = "rbxassetid://2804818047"
ImageButton43.Name = "AimButton"
ImageButton43.Parent = Frame41
ImageButton43.Position = UDim2.new(1, -25, 1, -148)
ImageButton43.Size = UDim2.new(0, 44, 0, 44)
ImageButton43.AnchorPoint = Vector2.new(1, 0)
ImageButton43.BackgroundColor = BrickColor.new("Institutional white")
ImageButton43.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton43.BackgroundTransparency = 1
ImageButton43.ZIndex = 10
ImageButton43.Image = "rbxassetid://2804583948"
Frame44.Name = "LargeTouchscreen"
Frame44.Parent = ScreenGui33
Frame44.Visible = false
Frame44.Size = UDim2.new(1, 0, 1, 0)
Frame44.BackgroundColor = BrickColor.new("Institutional white")
Frame44.BackgroundColor3 = Color3.new(1, 1, 1)
Frame44.BackgroundTransparency = 1
Frame44.ZIndex = 10
ImageButton45.Name = "FireButton"
ImageButton45.Parent = Frame44
ImageButton45.Position = UDim2.new(1, -170, 1, -210)
ImageButton45.Size = UDim2.new(0, 120, 0, 120)
ImageButton45.Active = false
ImageButton45.BackgroundColor = BrickColor.new("Institutional white")
ImageButton45.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton45.BackgroundTransparency = 1
ImageButton45.ZIndex = 10
ImageButton45.Image = "rbxassetid://2804818047"
ImageButton46.Name = "AimButton"
ImageButton46.Parent = Frame44
ImageButton46.Position = UDim2.new(1, -50, 1, -296)
ImageButton46.Size = UDim2.new(0, 88, 0, 88)
ImageButton46.AnchorPoint = Vector2.new(1, 0)
ImageButton46.BackgroundColor = BrickColor.new("Institutional white")
ImageButton46.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton46.BackgroundTransparency = 1
ImageButton46.ZIndex = 10
ImageButton46.Image = "rbxassetid://2804583948"
Folder47.Name = "ScalingElements"
Folder47.Parent = ScreenGui33
Frame48.Name = "Crosshair"
Frame48.Parent = Folder47
Frame48.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame48.Size = UDim2.new(0.0480000004, 0, 0.0480000004, 0)
Frame48.AnchorPoint = Vector2.new(0.5, 0.5)
Frame48.BackgroundColor = BrickColor.new("Institutional white")
Frame48.BackgroundColor3 = Color3.new(1, 1, 1)
Frame48.BackgroundTransparency = 1
ImageLabel49.Name = "Top"
ImageLabel49.Parent = Frame48
ImageLabel49.Position = UDim2.new(0.5, 0, 0, 0)
ImageLabel49.Size = UDim2.new(0.416700006, 0, 0.416999996, 0)
ImageLabel49.AnchorPoint = Vector2.new(0.5, 0)
ImageLabel49.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel49.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel49.BackgroundTransparency = 1
ImageLabel49.Image = "rbxassetid://2755681329"
ImageLabel50.Name = "Bottom"
ImageLabel50.Parent = Frame48
ImageLabel50.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel50.Rotation = 180
ImageLabel50.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel50.AnchorPoint = Vector2.new(0.5, 1)
ImageLabel50.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel50.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel50.BackgroundTransparency = 1
ImageLabel50.Image = "rbxassetid://2755681329"
ImageLabel51.Name = "Left"
ImageLabel51.Parent = Frame48
ImageLabel51.Position = UDim2.new(0, 0, 0.5, 0)
ImageLabel51.Rotation = 270
ImageLabel51.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel51.AnchorPoint = Vector2.new(0, 0.5)
ImageLabel51.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel51.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel51.BackgroundTransparency = 1
ImageLabel51.Image = "rbxassetid://2755681329"
ImageLabel52.Name = "Right"
ImageLabel52.Parent = Frame48
ImageLabel52.Position = UDim2.new(1, 0, 0.5, 0)
ImageLabel52.Rotation = 90
ImageLabel52.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel52.AnchorPoint = Vector2.new(1, 0.5)
ImageLabel52.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel52.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel52.BackgroundTransparency = 1
ImageLabel52.Image = "rbxassetid://2755681329"
UIAspectRatioConstraint53.Parent = Frame48
Frame54.Name = "HitMarker"
Frame54.Parent = Folder47
Frame54.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame54.Size = UDim2.new(0.0480000004, 0, 0.0480000004, 0)
Frame54.AnchorPoint = Vector2.new(0.5, 0.5)
Frame54.BackgroundColor = BrickColor.new("Institutional white")
Frame54.BackgroundColor3 = Color3.new(1, 1, 1)
Frame54.BackgroundTransparency = 1
ImageLabel55.Name = "HitMarkerImage"
ImageLabel55.Parent = Frame54
ImageLabel55.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel55.Rotation = 180
ImageLabel55.Size = UDim2.new(1, 0, 1, 0)
ImageLabel55.AnchorPoint = Vector2.new(0.5, 1)
ImageLabel55.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel55.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel55.BackgroundTransparency = 1
ImageLabel55.Image = "rbxassetid://285779644"
ImageLabel55.ImageTransparency = 1
UIAspectRatioConstraint56.Parent = Frame54
Folder57.Name = "DirectionalIndicators"
Folder57.Parent = Folder47
Frame58.Name = "DamageIndicator"
Frame58.Parent = Folder57
Frame58.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame58.Rotation = 180
Frame58.Size = UDim2.new(0.180000007, 0, 0.360000014, 0)
Frame58.AnchorPoint = Vector2.new(0.5, 0.5)
Frame58.BackgroundColor = BrickColor.new("Institutional white")
Frame58.BackgroundColor3 = Color3.new(1, 1, 1)
Frame58.BackgroundTransparency = 1
ImageLabel59.Name = "DamageIndicator"
ImageLabel59.Parent = Frame58
ImageLabel59.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel59.Rotation = 90
ImageLabel59.Size = UDim2.new(1, 0, 0.5, 0)
ImageLabel59.AnchorPoint = Vector2.new(0.5, 0.620000005)
ImageLabel59.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel59.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel59.BackgroundTransparency = 1
ImageLabel59.Image = "rbxassetid://3498623805"
ImageLabel59.ImageColor3 = Color3.new(0.898039, 0, 0)
ImageLabel59.ImageTransparency = 1
ImageLabel59.ScaleType = Enum.ScaleType.Slice
UIAspectRatioConstraint60.Parent = ImageLabel59
UIAspectRatioConstraint60.AspectRatio = 0.27200001478195
Configuration61.Parent = Frame58
StringValue62.Name = "Name"
StringValue62.Parent = Configuration61
StringValue62.Value = "DamageIndicator"
NumberValue63.Name = "TimeBeforeFade"
NumberValue63.Parent = Configuration61
NumberValue63.Value = 1.5
NumberValue64.Name = "FadeTime"
NumberValue64.Parent = Configuration61
NumberValue64.Value = 1
NumberValue65.Name = "TransparencyBeforeFade"
NumberValue65.Parent = Configuration61
NumberValue65.Value = 0.25
NumberValue66.Name = "DistanceLevelFromCenter"
NumberValue66.Parent = Configuration61
NumberValue66.Value = 6
NumberValue67.Name = "WidthLevel"
NumberValue67.Parent = Configuration61
NumberValue67.Value = 6
UIAspectRatioConstraint68.Parent = Frame58
Folder69.Name = "Animations"
Folder69.Parent = Folder32
Animation70.Name = "RifleAim"
Animation70.Parent = Folder69
Animation70.AnimationId = "rbxassetid://3972164452"
Animation71.Name = "RifleAimDownSights"
Animation71.Parent = Folder69
Animation71.AnimationId = "rbxassetid://3972157449"
Animation72.Name = "RifleReload"
Animation72.Parent = Folder69
Animation72.AnimationId = "rbxassetid://3972131105"
Folder73.Name = "Effects"
Folder73.Parent = Folder32
Folder74.Name = "Shots"
Folder74.Parent = Folder73
Part75.Name = "Bullet"
Part75.Parent = Folder74
Part75.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part75.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part75.Transparency = 1
Part75.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part75.Anchored = true
Part75.BottomSurface = Enum.SurfaceType.Smooth
Part75.CanCollide = false
Part75.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter76.Name = "TrailParticles"
ParticleEmitter76.Parent = mas
ParticleEmitter76.Speed = NumberRange.new(0, 2)
ParticleEmitter76.Rotation = NumberRange.new(-180, 180)
ParticleEmitter76.Color = ColorSequence.new(Color3.new(0.423529, 0.329412, 0),Color3.new(0.760784, 0.607843, 0))
ParticleEmitter76.Enabled = false
ParticleEmitter76.Texture = "rbxassetid://3852340006"
ParticleEmitter76.Transparency = NumberSequence.new(0,0.087499976158142,0.41249996423721,1)
ParticleEmitter76.Size = NumberSequence.new(0.070000000298023,0.070000000298023)
ParticleEmitter76.Lifetime = NumberRange.new(0.25, 0.5)
ParticleEmitter76.Rate = 100
ParticleEmitter76.RotSpeed = NumberRange.new(-50, 50)
ParticleEmitter76.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter76.VelocityInheritance = 0.30000001192093
ParticleEmitter76.VelocitySpread = 30
Beam77.Name = "Beam0"
Beam77.Parent = Part75
Beam77.Attachment0 = nil
Beam77.Attachment1 = nil
Beam77.Enabled = false
Beam77.FaceCamera = true
Beam77.Segments = 50
Beam77.Texture = "rbxassetid://3867967806"
Beam77.TextureSpeed = 0
Beam77.Transparency = NumberSequence.new(1,0,0,1)
Beam77.Width0 = 0.10000000149012
Beam77.Width1 = 0.25
Beam78.Name = "Beam1"
Beam78.Parent = Part75
Beam78.Attachment0 = nil
Beam78.Attachment1 = nil
Beam78.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam78.Enabled = false
Beam78.FaceCamera = true
Beam78.LightEmission = 1
Beam78.Segments = 50
Beam78.Texture = "rbxassetid://1287002748"
Beam78.TextureSpeed = 0
Beam78.Transparency = NumberSequence.new(1,1)
Beam78.Width0 = 0.10000000149012
Beam78.Width1 = 0.10000000149012
ParticleEmitter79.Name = "HitParticles"
ParticleEmitter79.Parent = mas
ParticleEmitter79.Speed = NumberRange.new(0, 10)
ParticleEmitter79.Rotation = NumberRange.new(-180, 180)
ParticleEmitter79.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter79.LightEmission = 0.10000000149012
ParticleEmitter79.LightInfluence = 1
ParticleEmitter79.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter79.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter79.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter79.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter79.Drag = 0.5
ParticleEmitter79.EmissionDirection = Enum.NormalId.Front
ParticleEmitter79.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter79.Rate = 0
ParticleEmitter79.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter79.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter79.VelocityInheritance = -0.0010000000474975
ParticleEmitter79.VelocitySpread = 30
Sound80.Name = "HitSound"
Sound80.Parent = mas
Sound80.SoundId = "rbxassetid://1489924400"
Sound80.Volume = 0
Part81.Name = "Grenade"
Part81.Parent = Folder74
Part81.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part81.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part81.Transparency = 1
Part81.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part81.Anchored = true
Part81.BottomSurface = Enum.SurfaceType.Smooth
Part81.CanCollide = false
Part81.TopSurface = Enum.SurfaceType.Smooth
Beam82.Name = "Beam0"
Beam82.Parent = Part81
Beam82.Attachment0 = nil
Beam82.Attachment1 = nil
Beam82.Color = ColorSequence.new(Color3.new(1, 0.796078, 0.270588),Color3.new(1, 0.798884, 0.280833),Color3.new(1, 0.964706, 0.886275))
Beam82.Enabled = false
Beam82.FaceCamera = true
Beam82.LightEmission = 1
Beam82.Segments = 50
Beam82.Texture = "rbxassetid://2463944225"
Beam82.TextureSpeed = 0
Beam82.Transparency = NumberSequence.new(1,0.90710383653641,0,1)
Beam82.Width0 = 0.10000000149012
Beam82.Width1 = 0.25
Beam83.Name = "Beam1"
Beam83.Parent = Part81
Beam83.Attachment0 = nil
Beam83.Attachment1 = nil
Beam83.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam83.Enabled = false
Beam83.FaceCamera = true
Beam83.LightEmission = 1
Beam83.Segments = 50
Beam83.Texture = "rbxassetid://1287002748"
Beam83.TextureSpeed = 0
Beam83.Transparency = NumberSequence.new(1,0.95081967115402,0.76502734422684,0.43169403076172,0,1)
Beam83.Width0 = 0.10000000149012
Beam83.Width1 = 0.10000000149012
Sound84.Name = "HitSound"
Sound84.Parent = mas
Sound84.SoundId = "rbxassetid://3963013256"
Sound84.Volume = 5
SpecialMesh85.Parent = Part81
SpecialMesh85.MeshId = "http://www.roblox.com/asset/?id=232379763"
SpecialMesh85.Scale = Vector3.new(1.5, 1.5, 1.5)
SpecialMesh85.TextureId = "http://www.roblox.com/asset/?id=232379808"
SpecialMesh85.MeshType = Enum.MeshType.FileMesh
Sound86.Name = "Flying"
Sound86.Parent = Part81
Sound86.Looped = true
Sound86.EmitterSize = 5
Sound86.MinDistance = 5
Sound86.SoundId = "rbxassetid://3963014042"
Part87.Name = "Arrow"
Part87.Parent = Folder74
Part87.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part87.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part87.Transparency = 1
Part87.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part87.Anchored = true
Part87.BottomSurface = Enum.SurfaceType.Smooth
Part87.CanCollide = false
Part87.TopSurface = Enum.SurfaceType.Smooth
Beam88.Name = "Beam0"
Beam88.Parent = Part87
Beam88.Attachment0 = nil
Beam88.Attachment1 = nil
Beam88.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.964706, 0.886275))
Beam88.Enabled = false
Beam88.FaceCamera = true
Beam88.LightEmission = 1
Beam88.Segments = 50
Beam88.Texture = "rbxassetid://2463944225"
Beam88.TextureLength = 0.5
Beam88.TextureSpeed = 0
Beam88.Transparency = NumberSequence.new(1,0.74863386154175,1,0.4426229596138,1,0.25136613845825,1,0.14754098653793,0.85792350769043,0,1,0,1,0,1)
Beam88.Width0 = 0.25
Beam88.Width1 = 0.25
Beam89.Name = "Beam1"
Beam89.Parent = Part87
Beam89.Attachment0 = nil
Beam89.Attachment1 = nil
Beam89.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(0.862745, 0.862745, 0.862745))
Beam89.Enabled = false
Beam89.FaceCamera = true
Beam89.LightEmission = 1
Beam89.Segments = 50
Beam89.Texture = "rbxassetid://1287002748"
Beam89.TextureSpeed = 0
Beam89.Transparency = NumberSequence.new(1,0.75409835577011,0.55191254615784,0.43169403076172,0.43169403076172,0.28415304422379,1)
Beam89.Width0 = 0.25
Beam89.Width1 = 0.25
ParticleEmitter90.Name = "HitParticles"
ParticleEmitter90.Parent = mas
ParticleEmitter90.Speed = NumberRange.new(0, 10)
ParticleEmitter90.Rotation = NumberRange.new(-180, 180)
ParticleEmitter90.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter90.LightEmission = 0.10000000149012
ParticleEmitter90.LightInfluence = 1
ParticleEmitter90.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter90.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter90.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter90.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter90.Drag = 0.5
ParticleEmitter90.EmissionDirection = Enum.NormalId.Front
ParticleEmitter90.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter90.Rate = 0
ParticleEmitter90.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter90.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter90.VelocityInheritance = -0.0010000000474975
ParticleEmitter90.VelocitySpread = 30
Sound91.Name = "HitSound"
Sound91.Parent = mas
Sound91.SoundId = "rbxassetid://3963012401"
Sound91.Volume = 0.25
SpecialMesh92.Parent = Part87
SpecialMesh92.MeshId = "rbxassetid://2493118549"
SpecialMesh92.Offset = Vector3.new(0, 0, -0.899999976)
SpecialMesh92.Scale = Vector3.new(0.43178001, 0.43178001, 0.43178001)
SpecialMesh92.TextureId = "rbxassetid://2493025364"
SpecialMesh92.MeshType = Enum.MeshType.FileMesh
Part93.Name = "Rocket"
Part93.Parent = Folder74
Part93.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part93.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part93.Transparency = 1
Part93.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part93.Anchored = true
Part93.BottomSurface = Enum.SurfaceType.Smooth
Part93.CanCollide = false
Part93.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter94.Name = "LeadingParticles"
ParticleEmitter94.Parent = mas
ParticleEmitter94.Speed = NumberRange.new(-5, -5)
ParticleEmitter94.Rotation = NumberRange.new(-180, 180)
ParticleEmitter94.Color = ColorSequence.new(Color3.new(1, 0.470588, 0.117647),Color3.new(1, 0.352941, 0.156863),Color3.new(0.815686, 0.490196, 0))
ParticleEmitter94.Enabled = false
ParticleEmitter94.LightEmission = 1
ParticleEmitter94.Texture = "rbxasset://textures/particles/fire_main.dds"
ParticleEmitter94.Transparency = NumberSequence.new(1,0.07407408952713,0,0,0.098765432834625,0.25308638811111,1)
ParticleEmitter94.Size = NumberSequence.new(0.3125,0.34722208976746,0.72916686534882,1.5625,2.8819441795349)
ParticleEmitter94.Drag = 5
ParticleEmitter94.EmissionDirection = Enum.NormalId.Left
ParticleEmitter94.Lifetime = NumberRange.new(0.10000000149012, 0.25)
ParticleEmitter94.Rate = 500
ParticleEmitter94.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter94.SpreadAngle = Vector2.new(10, 10)
ParticleEmitter94.VelocityInheritance = -0.10000000149012
ParticleEmitter94.VelocitySpread = 10
Beam95.Name = "Beam0"
Beam95.Parent = Part93
Beam95.Attachment0 = nil
Beam95.Attachment1 = nil
Beam95.Color = ColorSequence.new(Color3.new(1, 0.796078, 0.270588),Color3.new(1, 0.798884, 0.280833),Color3.new(1, 0.964706, 0.886275))
Beam95.Enabled = false
Beam95.FaceCamera = true
Beam95.LightEmission = 1
Beam95.Segments = 50
Beam95.Texture = "rbxassetid://2463944225"
Beam95.TextureSpeed = 0
Beam95.Transparency = NumberSequence.new(1,0.90710383653641,0,1)
Beam95.Width0 = 0.10000000149012
Beam95.Width1 = 0.25
Beam96.Name = "Beam1"
Beam96.Parent = Part93
Beam96.Attachment0 = nil
Beam96.Attachment1 = nil
Beam96.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam96.Enabled = false
Beam96.FaceCamera = true
Beam96.LightEmission = 1
Beam96.Segments = 50
Beam96.Texture = "rbxassetid://1287002748"
Beam96.TextureSpeed = 0
Beam96.Transparency = NumberSequence.new(1,0.95081967115402,0.76502734422684,0.43169403076172,0,1)
Beam96.Width0 = 0.10000000149012
Beam96.Width1 = 0.10000000149012
ParticleEmitter97.Name = "HitParticles"
ParticleEmitter97.Parent = mas
ParticleEmitter97.Speed = NumberRange.new(0, 10)
ParticleEmitter97.Rotation = NumberRange.new(-180, 180)
ParticleEmitter97.Color = ColorSequence.new(Color3.new(1, 0.988235, 0.929412),Color3.new(0.97466, 0.925769, 0.797998),Color3.new(1, 0.803922, 0.0941176),Color3.new(1, 0.705882, 0.109804),Color3.new(0.196078, 0.133333, 0.0117647))
ParticleEmitter97.LightEmission = 1
ParticleEmitter97.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter97.Transparency = NumberSequence.new(1,0,0.76543211936951,0.9753086566925,0.98765432834625,1)
ParticleEmitter97.Size = NumberSequence.new(0,2.9166669845581,2.361111164093,5.5208339691162,8.125)
ParticleEmitter97.Drag = 10
ParticleEmitter97.EmissionDirection = Enum.NormalId.Front
ParticleEmitter97.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter97.Rate = 0
ParticleEmitter97.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter97.SpreadAngle = Vector2.new(15, 15)
ParticleEmitter97.VelocitySpread = 15
Sound98.Name = "HitSound"
Sound98.Parent = mas
Sound98.SoundId = "rbxassetid://3963015379"
Sound98.Volume = 5
SpecialMesh99.Parent = Part93
SpecialMesh99.MeshId = "rbxassetid://94690081"
SpecialMesh99.Offset = Vector3.new(0, 0, -2)
SpecialMesh99.Scale = Vector3.new(2, 2, 2)
SpecialMesh99.TextureId = "rbxassetid://94689966"
SpecialMesh99.MeshType = Enum.MeshType.FileMesh
Sound100.Name = "Flying"
Sound100.Parent = Part93
Sound100.Looped = true
Sound100.EmitterSize = 5
Sound100.MinDistance = 5
Sound100.SoundId = "rbxassetid://3963016451"
Sound100.Volume = 2
Part101.Name = "Railgun"
Part101.Parent = Folder74
Part101.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part101.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part101.Transparency = 1
Part101.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part101.Anchored = true
Part101.BottomSurface = Enum.SurfaceType.Smooth
Part101.CanCollide = false
Part101.TopSurface = Enum.SurfaceType.Smooth
Beam102.Name = "Beam0"
Beam102.Parent = Part101
Beam102.Attachment0 = nil
Beam102.Attachment1 = nil
Beam102.Color = ColorSequence.new(Color3.new(1, 0.921569, 0.560784),Color3.new(1, 0.921569, 0.560784))
Beam102.Enabled = false
Beam102.FaceCamera = true
Beam102.LightEmission = 1
Beam102.Segments = 50
Beam102.Texture = "rbxassetid://1286995910"
Beam102.TextureSpeed = 0
Beam102.Transparency = NumberSequence.new(1,0,0,1)
Beam102.Width0 = 0.10000000149012
Beam102.Width1 = 0.25
Beam103.Name = "Beam1"
Beam103.Parent = Part101
Beam103.Attachment0 = nil
Beam103.Attachment1 = nil
Beam103.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam103.Enabled = false
Beam103.FaceCamera = true
Beam103.LightEmission = 1
Beam103.Segments = 50
Beam103.Texture = "rbxassetid://1287002748"
Beam103.TextureSpeed = 0
Beam103.Transparency = NumberSequence.new(1,0,0,1)
Beam103.Width0 = 0.10000000149012
Beam103.Width1 = 0.10000000149012
Sound104.Name = "HitSound"
Sound104.Parent = mas
Sound104.Pitch = 0.25
Sound104.PlaybackSpeed = 0.25
Sound104.SoundId = "rbxassetid://1489924400"
Sound104.Volume = 2
ParticleEmitter105.Name = "HitParticles"
ParticleEmitter105.Parent = mas
ParticleEmitter105.Speed = NumberRange.new(0, 2)
ParticleEmitter105.Rotation = NumberRange.new(-180, 180)
ParticleEmitter105.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.976659, 0.943567),Color3.new(1, 0.690196, 0.25098),Color3.new(1, 0.588235, 0.172549),Color3.new(0.4, 0.0352941, 0.0352941),Color3.new(0.14902, 0.121569, 0.121569),Color3.new(0.14902, 0.14902, 0.14902))
ParticleEmitter105.Enabled = false
ParticleEmitter105.LightEmission = 1
ParticleEmitter105.Texture = "rbxassetid://552389687"
ParticleEmitter105.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter105.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter105.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter105.Drag = 0.5
ParticleEmitter105.EmissionDirection = Enum.NormalId.Front
ParticleEmitter105.Lifetime = NumberRange.new(0.10000000149012, 1)
ParticleEmitter105.Rate = 0
ParticleEmitter105.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter105.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter105.VelocityInheritance = -0.0010000000474975
ParticleEmitter105.VelocitySpread = 30
ParticleEmitter106.Name = "MuzzleParticles"
ParticleEmitter106.Parent = Part101
ParticleEmitter106.Speed = NumberRange.new(5, 25)
ParticleEmitter106.Rotation = NumberRange.new(-180, 180)
ParticleEmitter106.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.580392, 0.580392),Color3.new(0.188235, 0.0352941, 0.0352941))
ParticleEmitter106.Enabled = false
ParticleEmitter106.LightEmission = 0.5
ParticleEmitter106.LightInfluence = 0.5
ParticleEmitter106.Texture = "rbxassetid://552389687"
ParticleEmitter106.Transparency = NumberSequence.new(1,0.83950614929199,0.90123456716537,0.70370370149612,0.80246913433075,0.67283952236176,0.93209874629974,0.56172835826874,0.8950617313385,0.6851851940155,0.92592591047287,1)
ParticleEmitter106.Size = NumberSequence.new(0,0.83333313465118,3.1944441795349,0.625,0.72916686534882,0,0.41666686534882,0)
ParticleEmitter106.Drag = 8
ParticleEmitter106.EmissionDirection = Enum.NormalId.Front
ParticleEmitter106.Lifetime = NumberRange.new(0.5, 1)
ParticleEmitter106.Rate = 0
ParticleEmitter106.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter106.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter106.VelocitySpread = 30
Part107.Name = "Plasma"
Part107.Parent = Folder74
Part107.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part107.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part107.Transparency = 1
Part107.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part107.Anchored = true
Part107.BottomSurface = Enum.SurfaceType.Smooth
Part107.CanCollide = false
Part107.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter108.Name = "LeadingParticles"
ParticleEmitter108.Parent = mas
ParticleEmitter108.Speed = NumberRange.new(5, 10)
ParticleEmitter108.Rotation = NumberRange.new(-180, 180)
ParticleEmitter108.Color = ColorSequence.new(Color3.new(0.498039, 0.917647, 1),Color3.new(1, 1, 1))
ParticleEmitter108.Enabled = false
ParticleEmitter108.LightEmission = 1
ParticleEmitter108.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter108.Transparency = NumberSequence.new(1,0,0,0.74074077606201,0.95679014921188,1)
ParticleEmitter108.Size = NumberSequence.new(0.3125,0.59027791023254,1.3194441795349,0.41666686534882,0.20833313465118,0)
ParticleEmitter108.Drag = 0.5
ParticleEmitter108.Lifetime = NumberRange.new(0.10000000149012, 0.25)
ParticleEmitter108.LockedToPart = true
ParticleEmitter108.Rate = 100
ParticleEmitter108.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter108.SpreadAngle = Vector2.new(180, 180)
ParticleEmitter108.VelocitySpread = 180
Beam109.Name = "Beam0"
Beam109.Parent = Part107
Beam109.Attachment0 = nil
Beam109.Attachment1 = nil
Beam109.Color = ColorSequence.new(Color3.new(0.498039, 0.917647, 1),Color3.new(0.498039, 0.917647, 1))
Beam109.Enabled = false
Beam109.FaceCamera = true
Beam109.LightEmission = 1
Beam109.Segments = 50
Beam109.Texture = "rbxassetid://2463944225"
Beam109.TextureSpeed = 0
Beam109.Transparency = NumberSequence.new(1,0,0,1)
Beam109.Width0 = 0.10000000149012
Beam109.Width1 = 0.25
Beam110.Name = "Beam1"
Beam110.Parent = Part107
Beam110.Attachment0 = nil
Beam110.Attachment1 = nil
Beam110.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam110.Enabled = false
Beam110.FaceCamera = true
Beam110.LightEmission = 1
Beam110.Segments = 50
Beam110.Texture = "rbxassetid://1287002748"
Beam110.TextureSpeed = 0
Beam110.Transparency = NumberSequence.new(1,0,0,1)
Beam110.Width0 = 0.10000000149012
Beam110.Width1 = 0.10000000149012
ParticleEmitter111.Name = "HitParticles"
ParticleEmitter111.Parent = mas
ParticleEmitter111.Speed = NumberRange.new(0, 10)
ParticleEmitter111.Rotation = NumberRange.new(-180, 180)
ParticleEmitter111.Color = ColorSequence.new(Color3.new(0.607843, 0.937255, 1),Color3.new(0, 0.392157, 0.470588))
ParticleEmitter111.LightEmission = 1
ParticleEmitter111.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter111.Transparency = NumberSequence.new(1,0,0.76543211936951,0.9753086566925,0.98765432834625,1)
ParticleEmitter111.Size = NumberSequence.new(0,1.25,0.97222208976746,2.1180553436279,3.5069441795349)
ParticleEmitter111.Drag = 10
ParticleEmitter111.EmissionDirection = Enum.NormalId.Front
ParticleEmitter111.Lifetime = NumberRange.new(0.5, 2)
ParticleEmitter111.Rate = 0
ParticleEmitter111.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter111.SpreadAngle = Vector2.new(15, 15)
ParticleEmitter111.VelocitySpread = 15
Sound112.Name = "HitSound"
Sound112.Parent = mas
Sound112.Pitch = 2
Sound112.PlaybackSpeed = 2
Sound112.SoundId = "rbxassetid://878000314"
Sound112.Volume = 0.25
Part113.Name = "CannonBall"
Part113.Parent = Folder74
Part113.CFrame = CFrame.new(-6.13871193, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part113.Position = Vector3.new(-6.13871193, 1.25002396, -11.435256)
Part113.Color = Color3.new(0.160784, 0.164706, 0.188235)
Part113.Transparency = 1
Part113.Size = Vector3.new(2, 2, 2)
Part113.BottomSurface = Enum.SurfaceType.Smooth
Part113.BrickColor = BrickColor.new("Black")
Part113.CustomPhysicalProperties = 13, 0.800000012, 0.0500000007, 10, 100
Part113.Material = Enum.Material.Metal
Part113.TopSurface = Enum.SurfaceType.Smooth
Part113.brickColor = BrickColor.new("Black")
Part113.Shape = Enum.PartType.Ball
Beam114.Name = "Beam0"
Beam114.Parent = Part113
Beam114.Attachment0 = nil
Beam114.Attachment1 = nil
Beam114.Color = ColorSequence.new(Color3.new(0.639216, 0.639216, 0.639216),Color3.new(0.34902, 0.34902, 0.34902))
Beam114.Enabled = false
Beam114.FaceCamera = true
Beam114.LightEmission = 1
Beam114.LightInfluence = 1
Beam114.Segments = 50
Beam114.Texture = "rbxassetid://2463944225"
Beam114.TextureSpeed = 0
Beam114.Transparency = NumberSequence.new(1,0,0,1)
Beam114.Width0 = 0.10000000149012
Beam114.Width1 = 2
Beam115.Name = "Beam1"
Beam115.Parent = Part113
Beam115.Attachment0 = nil
Beam115.Attachment1 = nil
Beam115.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam115.Enabled = false
Beam115.FaceCamera = true
Beam115.LightEmission = 1
Beam115.Segments = 50
Beam115.Texture = "rbxassetid://2463944225"
Beam115.TextureSpeed = 0
Beam115.Transparency = NumberSequence.new(1,0,0,1)
Beam115.Width0 = 0.10000000149012
Beam115.Width1 = 3
Sound116.Name = "HitSound"
Sound116.Parent = mas
Sound116.SoundId = "rbxassetid://1489924400"
Sound116.Volume = 0.25
ParticleEmitter117.Name = "HitParticles"
ParticleEmitter117.Parent = mas
ParticleEmitter117.Speed = NumberRange.new(0, 10)
ParticleEmitter117.Rotation = NumberRange.new(-180, 180)
ParticleEmitter117.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter117.Enabled = false
ParticleEmitter117.LightEmission = 0.10000000149012
ParticleEmitter117.LightInfluence = 1
ParticleEmitter117.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter117.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter117.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter117.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter117.Drag = 0.5
ParticleEmitter117.EmissionDirection = Enum.NormalId.Front
ParticleEmitter117.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter117.Rate = 0
ParticleEmitter117.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter117.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter117.VelocityInheritance = -0.0010000000474975
ParticleEmitter117.VelocitySpread = 30
Folder118.Name = "HitMarks"
Folder118.Parent = Folder73
Part119.Name = "BulletHole"
Part119.Parent = Folder118
Part119.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part119.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part119.Transparency = 1
Part119.Size = Vector3.new(0.5, 0.5, 0.0500000007)
Part119.BottomSurface = Enum.SurfaceType.Smooth
Part119.CanCollide = false
Part119.TopSurface = Enum.SurfaceType.Smooth
BillboardGui120.Name = "ImpactBillboard"
BillboardGui120.Parent = Part119
BillboardGui120.LightInfluence = 1
BillboardGui120.Size = UDim2.new(5, 0, 5, 0)
BillboardGui120.ResetOnSpawn = false
BillboardGui120.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
BillboardGui120.Adornee = Part119
BillboardGui120.ExtentsOffset = Vector3.new(0, 0, 0.25)
ImageLabel121.Name = "Impact"
ImageLabel121.Parent = BillboardGui120
ImageLabel121.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel121.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel121.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel121.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel121.BackgroundTransparency = 1
ImageLabel121.BorderSizePixel = 0
ImageLabel121.Image = "rbxassetid://3918596245"
ImageLabel121.ImageTransparency = 1
Decal122.Name = "BulletHole"
Decal122.Parent = Part119
Decal122.Texture = "http://www.roblox.com/asset/?id=2078626"
Decal122.Transparency = 1
Decal122.Face = Enum.NormalId.Back
Decal122.Color3 = Color3.new(1, 0.831373, 0.435294)
Part123.Name = "Pellet"
Part123.Parent = Folder118
Part123.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part123.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part123.Transparency = 1
Part123.Size = Vector3.new(0.200000003, 0.200000003, 0.0500000007)
Part123.BottomSurface = Enum.SurfaceType.Smooth
Part123.CanCollide = false
Part123.TopSurface = Enum.SurfaceType.Smooth
Decal124.Name = "BulletHole"
Decal124.Parent = Part123
Decal124.Texture = "http://www.roblox.com/asset/?id=2078626"
Decal124.Transparency = 1
Decal124.Face = Enum.NormalId.Back
Decal124.Color3 = Color3.new(1, 0.831373, 0.435294)
Part125.Name = "Arrow"
Part125.Parent = Folder118
Part125.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part125.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
Part125.Transparency = 1
Part125.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part125.BottomSurface = Enum.SurfaceType.Smooth
Part125.CanCollide = false
Part125.TopSurface = Enum.SurfaceType.Smooth
SpecialMesh126.Parent = Part125
SpecialMesh126.MeshId = "rbxassetid://2493118549"
SpecialMesh126.Offset = Vector3.new(0, 0, 0.75)
SpecialMesh126.Scale = Vector3.new(0.43178001, 0.43178001, 0.43178001)
SpecialMesh126.TextureId = "rbxassetid://2493025364"
SpecialMesh126.MeshType = Enum.MeshType.FileMesh
Part127.Name = "Scorch"
Part127.Parent = Folder118
Part127.CFrame = CFrame.new(-5.27945089, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part127.Position = Vector3.new(-5.27945089, 1.25002396, -11.435256)
Part127.Transparency = 1
Part127.Size = Vector3.new(2, 2, 0.0500000007)
Part127.BottomSurface = Enum.SurfaceType.Smooth
Part127.CanCollide = false
Part127.TopSurface = Enum.SurfaceType.Smooth
Decal128.Name = "ScorchMark"
Decal128.Parent = Part127
Decal128.Texture = "rbxassetid://53875997"
Decal128.Transparency = 1
Decal128.Face = Enum.NormalId.Back
Decal129.Name = "Glow"
Decal129.Parent = Part127
Decal129.Texture = "http://www.roblox.com/asset/?id=246689799"
Decal129.Transparency = 1
Decal129.Face = Enum.NormalId.Back
Decal129.Color3 = Color3.new(1, 0.258824, 0.113725)
Part130.Name = "Explosion"
Part130.Parent = Folder118
Part130.CFrame = CFrame.new(-5.27945089, 1.25002396, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part130.Position = Vector3.new(-5.27945089, 1.25002396, -11.435256)
Part130.Transparency = 1
Part130.Size = Vector3.new(2.5, 2.5, 0.0500000007)
Part130.BottomSurface = Enum.SurfaceType.Smooth
Part130.CanCollide = false
Part130.TopSurface = Enum.SurfaceType.Smooth
Decal131.Name = "ScorchMark"
Decal131.Parent = Part130
Decal131.Texture = "rbxassetid://53875997"
Decal131.Transparency = 1
Decal131.Face = Enum.NormalId.Back
Decal132.Name = "Glow"
Decal132.Parent = Part130
Decal132.Texture = "http://www.roblox.com/asset/?id=246689799"
Decal132.Transparency = 1
Decal132.Face = Enum.NormalId.Back
Decal132.Color3 = Color3.new(1, 0.258824, 0.113725)
Folder133.Name = "Casings"
Folder133.Parent = Folder73
MeshPart134.Name = "RifleCasing"
MeshPart134.Parent = Folder133
MeshPart134.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 0, 1, -0, -1, 0, 0, 0, 0, 1)
MeshPart134.Orientation = Vector3.new(0, 0, -90)
MeshPart134.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
MeshPart134.Rotation = Vector3.new(0, 0, -90)
MeshPart134.Color = Color3.new(1, 0.690196, 0)
MeshPart134.Transparency = 1
MeshPart134.Size = Vector3.new(0.105999999, 0.330000013, 0.105999999)
MeshPart134.BrickColor = BrickColor.new("Deep orange")
MeshPart134.Material = Enum.Material.Metal
MeshPart134.brickColor = BrickColor.new("Deep orange")
MeshPart134.TextureID = "rbxassetid://2794275376"
Sound135.Name = "CasingHitSound"
Sound135.Parent = MeshPart134
Sound135.EmitterSize = 1
Sound135.MinDistance = 1
Sound135.SoundId = "rbxassetid://3909012115"
Sound135.Volume = 1
MeshPart136.Name = "PistolCasing"
MeshPart136.Parent = Folder133
MeshPart136.CFrame = CFrame.new(-6.52995777, 1.25002396, -11.435256, 0, 1, -0, -1, 0, 0, 0, 0, 1)
MeshPart136.Orientation = Vector3.new(0, 0, -90)
MeshPart136.Position = Vector3.new(-6.52995777, 1.25002396, -11.435256)
MeshPart136.Rotation = Vector3.new(0, 0, -90)
MeshPart136.Color = Color3.new(1, 0.690196, 0)
MeshPart136.Transparency = 1
MeshPart136.Size = Vector3.new(0.0829999968, 0.107000001, 0.0829999968)
MeshPart136.BrickColor = BrickColor.new("Deep orange")
MeshPart136.Material = Enum.Material.Metal
MeshPart136.brickColor = BrickColor.new("Deep orange")
MeshPart136.TextureID = "rbxassetid://2794275376"
Sound137.Name = "CasingHitSound"
Sound137.Parent = MeshPart136
Sound137.EmitterSize = 1
Sound137.MinDistance = 1
Sound137.SoundId = "rbxassetid://3909012115"
Sound137.Volume = 1
Script138.Name = "ServerWeaponsScript"
Script138.Parent = Folder29
table.insert(cors,sandbox(Script138,function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local curWeaponsSystemFolder = script.Parent
local weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
local weaponsSystemInitialized = false

local function initializeWeaponsSystemAssets()
	if not weaponsSystemInitialized then
		-- Enable/make visible all necessary assets
		local effectsFolder = weaponsSystemFolder.Assets.Effects
		local partNonZeroTransparencyValues = {
			["BulletHole"] = 1, ["Explosion"] = 1, ["Pellet"] = 1, ["Scorch"] = 1,
			["Bullet"] = 1, ["Plasma"] = 1, ["Railgun"] = 1,
		}
		local decalNonZeroTransparencyValues = { ["ScorchMark"] = 0.25 }
		local particleEmittersToDisable = { ["Smoke"] = true }
		local imageLabelNonZeroTransparencyValues = { ["Impact"] = 0.25 }
		for _, descendant in pairs(effectsFolder:GetDescendants()) do
			if descendant:IsA("BasePart") then
				if partNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = partNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("Decal") then
				descendant.Transparency = 0
				if decalNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = decalNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("ParticleEmitter") then
				descendant.Enabled = true
				if particleEmittersToDisable[descendant.Name] ~= nil then
					descendant.Enabled = false
				else
					descendant.Enabled = true
				end
			elseif descendant:IsA("ImageLabel") then
				if imageLabelNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.ImageTransparency = imageLabelNonZeroTransparencyValues[descendant.Name]
				else
					descendant.ImageTransparency = 0
				end
			end
		end
		
		weaponsSystemInitialized = true
	end
end

if weaponsSystemFolder == nil then
	weaponsSystemFolder = curWeaponsSystemFolder:Clone()
	initializeWeaponsSystemAssets()
	weaponsSystemFolder.Parent = ReplicatedStorage
end

if ServerScriptService:FindFirstChild("ServerWeaponsScript") == nil then
	script.Parent = ServerScriptService
	initializeWeaponsSystemAssets()

	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
	
	local function setupClientWeaponsScript(player)
		local clientWeaponsScript = player.PlayerGui:FindFirstChild("ClientWeaponsScript")
		if clientWeaponsScript == nil then
			clientWeaponsScript = weaponsSystemFolder.ClientWeaponsScript:Clone()
			clientWeaponsScript.Parent = player.PlayerGui
		end
	end
	
	Players.PlayerAdded:Connect(function(player)
		setupClientWeaponsScript(player)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		setupClientWeaponsScript(player)
	end
end

if curWeaponsSystemFolder.Name == "WeaponsSystem" then
	curWeaponsSystemFolder:Destroy()
end
end))
LocalScript139.Name = "ClientWeaponsScript"
LocalScript139.Parent = Folder29
table.insert(cors,sandbox(LocalScript139,function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local playerChildAddedConnection
local replicatedStorageChildAddedConnection
local clientWeaponsScript
local weaponsSystemFolder

local function setupWeaponsSystem()
	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
end

local function onReplicatedStorageChildAdded(child)
	if child.Name == "WeaponsSystem" then
		setupWeaponsSystem()
		replicatedStorageChildAddedConnection:Disconnect()
	end
end

local function onPlayerChildAdded(child)
	if child.Name == "PlayerScripts" then
		clientWeaponsScript.Parent = child
		playerChildAddedConnection:Disconnect()
	end
end

if script.Parent.Name ~= "PlayerScripts" then
	clientWeaponsScript = script:Clone()
	local PlayerScripts = script.Parent.Parent:FindFirstChild("PlayerScripts")
	
	if PlayerScripts ~= nil then
		clientWeaponsScript.Parent = PlayerScripts
	else
		playerChildAddedConnection = script.Parent.Parent.ChildAdded:Connect(onPlayerChildAdded)
	end
else
	weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
	if weaponsSystemFolder ~= nil then
		setupWeaponsSystem()
	else
		replicatedStorageChildAddedConnection = ReplicatedStorage.ChildAdded:Connect(onReplicatedStorageChildAdded)
	end
end
end))
Folder140.Name = "WeaponTypes"
Folder140.Parent = Folder29
ModuleScript141.Name = "BowWeapon"
ModuleScript141.Parent = Folder140
table.insert(cors,sandbox(ModuleScript141,function()
local RunService = game:GetService("RunService")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent

local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local BulletWeapon = require(WeaponTypes:WaitForChild("BulletWeapon"))

local BowWeapon = {}
BowWeapon.__index = BowWeapon
setmetatable(BowWeapon, BulletWeapon)

BowWeapon.CanAimDownSights = true
BowWeapon.CanBeFired = true
BowWeapon.CanBeReloaded = true
BowWeapon.CanHit = true

function BowWeapon.new(weaponsSystem, instance)
	local self = BulletWeapon.new(weaponsSystem, instance)
	setmetatable(self, BowWeapon)

	self.hasArrow = true

	self.arrowPart = self.instance:FindFirstChild("Arrow", true)
	self.armsPart = self.instance:FindFirstChild("Arms", true)
	if self.armsPart then
		self.armsMesh = self.armsPart:FindFirstChildOfClass("SpecialMesh")

		self.tightOffsetValue = self.armsPart:FindFirstChild("TightOffset")
		self.tightScaleValue = self.armsPart:FindFirstChild("TightScale")

		self.looseOffsetValue = self.armsPart:FindFirstChild("LooseOffset")
		self.looseScaleValue = self.armsPart:FindFirstChild("LooseScale")

		self.leftLooseAttach = self.armsPart:FindFirstChild("LeftLoose")
		self.rightLooseAttach = self.armsPart:FindFirstChild("RightLoose")

		self.leftTightAttach = self.armsPart:FindFirstChild("LeftTight")
		self.rightTightAttach = self.armsPart:FindFirstChild("RightTight")

		self.leftString0 = self.armsPart:FindFirstChild("LeftString0")
		self.rightString0 = self.armsPart:FindFirstChild("RightString0")
	end

	self.string1 = self.instance:FindFirstChild("String1", true)
	self.stringLooseAttach = self.instance:FindFirstChild("StringLoose", true)
	self.stringTightAttach = self.instance:FindFirstChild("StringTight", true)

	self:setHasArrow(false)

	return self
end

function BowWeapon:renderCharge()
	if self.armsMesh and self.looseOffsetValue and self.looseScaleValue and self.tightOffsetValue and self.tightScaleValue then
		local looseOffset, tightOffset = self.looseOffsetValue.Value, self.tightOffsetValue.Value
		local looseScale, tightScale = self.looseScaleValue.Value, self.tightScaleValue.Value

		self.armsMesh.Offset = looseOffset:Lerp(tightOffset, self.charge)
		self.armsMesh.Scale = looseScale:Lerp(tightScale, self.charge)
	end

	if self.leftString0 and self.leftLooseAttach and self.leftTightAttach then
		self.leftString0.CFrame = self.leftLooseAttach.CFrame:lerp(self.leftTightAttach.CFrame, self.charge)
	end
	if self.rightString0 and self.rightLooseAttach and self.rightTightAttach then
		self.rightString0.CFrame = self.rightLooseAttach.CFrame:lerp(self.rightTightAttach.CFrame, self.charge)
	end

	if self.string1 and self.stringLooseAttach and self.stringTightAttach then
		self.string1.CFrame = self.stringLooseAttach.CFrame:lerp(self.stringTightAttach.CFrame, self.charge)
	end
end

function BowWeapon:handleCharging(dt)
	if self.hasArrow then return end
	BulletWeapon.handleCharging(self, dt)

	if self.charge >= 1 then
		self:setHasArrow(true)
	end
end

function BowWeapon:onActivatedChanged()
	if not IsServer then
		if not self.activated then
			if self.didFire then
				self.didFire = false
			end
		end
	end
	BulletWeapon.onActivatedChanged(self)
end

function BowWeapon:isCharged()
	return self.hasArrow and self.charge >= 1
end

function BowWeapon:doLocalFire()
	BulletWeapon.doLocalFire(self)
	self:setHasArrow(false)
	self.didFire = true
end

function BowWeapon:setHasArrow(hasArrow)
	if self.hasArrow == hasArrow then
		return
	end

	self.hasArrow = hasArrow
	if self.arrowPart then
		self.arrowPart.Transparency = self.hasArrow and 0 or 1
	end
end

return BowWeapon
end))
ModuleScript142.Name = "BulletWeapon"
ModuleScript142.Parent = Folder140
table.insert(cors,sandbox(ModuleScript142,function()
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local ContextActionService = game:GetService("ContextActionService")
local CollectionService = game:GetService("CollectionService")
local ContentProvider = game:GetService("ContentProvider")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local BaseWeapon = require(Libraries:WaitForChild("BaseWeapon"))
local Parabola = require(Libraries:WaitForChild("Parabola"))
local Roblox = require(Libraries:WaitForChild("Roblox"))

local Effects = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Effects")
local ShotsFolder = Effects:WaitForChild("Shots")
local HitMarksFolder = Effects:WaitForChild("HitMarks")
local CasingsFolder = Effects:WaitForChild("Casings")

local NO_BULLET_DECALS = false
local NO_BULLET_CASINGS = false

--The ignore list will fill up over time. This is how many seconds it will go before
--being refreshed in order to keep it from filling up with instances that aren't in
--the datamodel anymore.
local IGNORE_LIST_LIFETIME = 5

local MAX_BULLET_TIME = 10

local localRandom = Random.new()
local localPlayer = not IsServer and Players.LocalPlayer

local BulletWeapon = {}
BulletWeapon.__index = BulletWeapon
setmetatable(BulletWeapon, BaseWeapon)

BulletWeapon.CanAimDownSights = true
BulletWeapon.CanBeFired = true
BulletWeapon.CanBeReloaded = true
BulletWeapon.CanHit = true

function BulletWeapon.new(weaponsSystem, instance)
	local self = BaseWeapon.new(weaponsSystem, instance)
	setmetatable(self, BulletWeapon)

	self.usesCharging = false
	self.charge = 0
	self.chargeSoundPitchMin = 0.5
	self.chargeSoundPitchMax = 1

	self.triggerDisconnected = false
	self.startupFinished = false -- TODO: make startup time use a configuration value
	self.burstFiring = false
	self.burstIdx = 0
	self.nextFireTime = 0

	self.recoilIntensity = 0
	self.aimPoint = Vector3.new()

	self:addOptionalDescendant("tipAttach", "TipAttachment")

	self:addOptionalDescendant("boltMotor", "BoltMotor")
	self:addOptionalDescendant("boltMotorStart", "BoltMotorStart")
	self:addOptionalDescendant("boltMotorTarget", "BoltMotorTarget")

	self:addOptionalDescendant("chargeGlowPart", "ChargeGlow")
	self:addOptionalDescendant("chargeCompleteParticles", "ChargeCompleteParticles")
	self:addOptionalDescendant("dischargeCompleteParticles", "DischargeCompleteParticles")

	self:addOptionalDescendant("muzzleFlash0", "MuzzleFlash0")
	self:addOptionalDescendant("muzzleFlash1", "MuzzleFlash1")
	self:addOptionalDescendant("muzzleFlashBeam", "MuzzleFlash")

	self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))

	self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
	self:addOptionalDescendant("casingEjectPoint", "CasingEjectPoint")

	self.ignoreList = {}
	self.ignoreListRefreshTime = 0

	self:addOptionalDescendant("handAttach", "LeftHandAttachment")
	self.handAlignPos = nil
	self.handAlignRot = nil

	self.chargingParticles = {}
	self.instance.DescendantAdded:Connect(function(descendant)
		if descendant.Name == "ChargingParticles" and descendant:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, descendant)
		end
	end)
	for _, v in pairs(self.instance:GetDescendants()) do
		if v.Name == "ChargingParticles" and v:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, v)
		end
	end

	self:doInitialSetup()

	return self
end

function BulletWeapon:onEquippedChanged()
	BaseWeapon.onEquippedChanged(self)

	if not IsServer then
		if self.weaponsSystem.camera then
			if self.equipped then
				self.startupFinished = false
			end
		end

		if self.equipped then
			ContextActionService:BindAction("ReloadWeapon", function(...) self:onReloadAction(...) end, false, Enum.KeyCode.R, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindAction("ReloadWeapon")

			-- Stop charging/discharging sounds
			local chargingSound = self:getSound("Charging")
			local dischargingSound = self:getSound("Discharging")
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
		end

		self.triggerDisconnected = false
	end
end

function BulletWeapon:onReloadAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin and not self.reloading then
		self:reload()
	end
end

function BulletWeapon:animateBoltAction(isOpen)
	if not self.boltMotor or not self.boltMotorStart or not self.boltMotorTarget then
		return
	end

	if isOpen then
		self:tryPlaySound("BoltOpenSound")
	else
		self:tryPlaySound("BoltCloseSound")
	end

	local actionMoveTime = isOpen and self:getConfigValue("ActionOpenTime", 0.025) or self:getConfigValue("ActionCloseTime", 0.075)
	local targetCFrame = isOpen and self.boltMotorTarget.CFrame or self.boltMotorStart.CFrame

	local boltTween = TweenService:Create(self.boltMotor, TweenInfo.new(actionMoveTime, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { C0 = targetCFrame })
	boltTween:Play()
	boltTween.Completed:Wait()
end

function BulletWeapon:getRandomSeedForId(id)
	return id
end

-- This function is only called on clients
function BulletWeapon:simulateFire(firingPlayer, fireInfo)
	BaseWeapon.simulateFire(self, fireInfo)

	-- Play "Fired" sound
	if self.lastFireSound then
		self.lastFireSound:Stop()
	end
	self.lastFireSound = self:tryPlaySound("Fired", self:getConfigValue("FiredPlaybackSpeedRange", 0.1))

	-- Simulate each projectile/bullet fired from current weapon
	local numProjectiles = self:getConfigValue("NumProjectiles", 1)
	local randomGenerator = Random.new(self:getRandomSeedForId(fireInfo.id))
	for i = 1, numProjectiles do
		self:simulateProjectile(firingPlayer, fireInfo, i, randomGenerator)
	end

	-- Animate the bolt if the current gun has one
	local actionOpenTime = self:getConfigValue("ActionOpenTime", 0.025)
	if self.boltMotor then
		coroutine.wrap(function()
			self:animateBoltAction(true)
			wait(actionOpenTime)
			self:animateBoltAction(false)
		end)()
	end

	-- Eject bullet casings and play "CasingHitSound" (child of casing) sound if applicable for current weapon
	if not NO_BULLET_CASINGS and self.casingTemplate and self.casingEjectPoint then
		local casing = self.casingTemplate:Clone()
		casing.Anchored = false
		casing.Archivable = false
		casing.CFrame = self.casingEjectPoint.WorldCFrame
		casing.Velocity = self.casingEjectPoint.Parent.Velocity + (self.casingEjectPoint.WorldAxis * localRandom:NextNumber(self:getConfigValue("CasingEjectSpeedMin", 15), self:getConfigValue("CasingEjectSpeedMax", 18)))
		casing.Parent = workspace.CurrentCamera
		CollectionService:AddTag(casing, "WeaponsSystemIgnore")

		local casingHitSound = casing:FindFirstChild("CasingHitSound")
		if casingHitSound then
			local touchedConn = nil
			touchedConn = casing.Touched:Connect(function(hitPart)
				if not hitPart:IsDescendantOf(self.instance) then
					casingHitSound:Play()
					touchedConn:Disconnect()
					touchedConn = nil
				end
			end)
		end

		Debris:AddItem(casing, 2)
	end

	if self.player == Players.LocalPlayer then
		coroutine.wrap(function()
			-- Wait for "RecoilDelayTime" before adding recoil
			local startTime = tick()
			local recoilDelayTime = self:getConfigValue("RecoilDelayTime", 0.07)
			while tick() < startTime + recoilDelayTime do
				RunService.RenderStepped:Wait()
			end
			RunService.RenderStepped:Wait()

			-- Add recoil to camera
			local recoilMin, recoilMax = self:getConfigValue("RecoilMin", 0.05), self:getConfigValue("RecoilMax", 0.5)
			local intensityToAdd = randomGenerator:NextNumber(recoilMin, recoilMax)
			local xIntensity = math.sin(tick() * 2) * intensityToAdd * math.rad(0.05)
			local yIntensity = intensityToAdd * 0.025
			self.weaponsSystem.camera:addRecoil(Vector2.new(xIntensity, yIntensity))

			if not (self.weaponsSystem.camera:isZoomed() and self:getConfigValue("HasScope", false)) then
				self.recoilIntensity = math.clamp(self.recoilIntensity * 1 + (intensityToAdd / 10), 0.005, 1)
			end

			-- Make crosshair reflect recoil/spread amount
			local weaponsGui = self.weaponsSystem.gui
			if weaponsGui then
				weaponsGui:setCrosshairScale(1 + intensityToAdd)
			end
		end)()
	end
end

function BulletWeapon:getIgnoreList(includeLocalPlayer)
	local now = tick()
	local ignoreList = self.ignoreList
	if not ignoreList or now - self.ignoreListRefreshTime > IGNORE_LIST_LIFETIME then
		ignoreList = {
			self.instanceIsTool and self.instance.Parent or self.instance,
			workspace.CurrentCamera
		}
		if not RunService:IsServer() then
			if includeLocalPlayer and Players.LocalPlayer and Players.LocalPlayer.Character then
				table.insert(ignoreList, Players.LocalPlayer.Character)
			end
		end
		self.ignoreList = ignoreList
	end
	return ignoreList
end

-- This function is only called on clients
function BulletWeapon:simulateProjectile(firingPlayer, fireInfo, projectileIdx, randomGenerator)
	local localPlayerInitiatedShot = self.player == Players.LocalPlayer

	-- Retrieve config values
	local bulletSpeed = self:getConfigValue("BulletSpeed", 1000)
	local maxDistance = self:getConfigValue("MaxDistance", 2000)
	local trailLength = self:getConfigValue("TrailLength", nil)
	local trailLengthFactor = self:getConfigValue("TrailLengthFactor", 1)
	local showEntireTrailUntilHit = self:getConfigValue("ShowEntireTrailUntilHit", false)
	local gravityFactor = self:getConfigValue("GravityFactor", 0)
	local minSpread = self:getConfigValue("MinSpread", 0)
	local maxSpread = self:getConfigValue("MaxSpread", 0)
	local shouldMovePart = self:getConfigValue("ShouldMovePart", false)
	local explodeOnImpact = self:getConfigValue("ExplodeOnImpact", false)
	local blastRadius = self:getConfigValue("BlastRadius", 8)

	-- Cheat the origin of the shot back if gun tip in wall/object
	if self.tipAttach ~= nil then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local tipDir = tipCFrame.LookVector
		local amountToCheatBack = math.abs((self.instance:FindFirstChild("Handle").Position - tipPos):Dot(tipDir)) + 1
		local gunRay = Ray.new(tipPos - tipDir.Unit * amountToCheatBack, tipDir.Unit * amountToCheatBack)
		local hitPart, hitPoint = Roblox.penetrateCast(gunRay, self:getIgnoreList(localPlayerInitiatedShot))
		if hitPart and math.abs((tipPos - hitPoint).Magnitude) > 0 then
			fireInfo.origin = hitPoint - tipDir.Unit * 0.1
			fireInfo.dir = tipDir.Unit
		end
	end

	local origin, dir = fireInfo.origin, fireInfo.dir

	dir = Roblox.applySpread(dir, randomGenerator, math.rad(minSpread), math.rad(maxSpread))

	-- Initialize variables for visuals/particle effects
	local bulletEffect = self.bulletEffectTemplate:Clone()
	bulletEffect.CFrame = CFrame.new(origin, origin + dir)
	bulletEffect.Parent = workspace.CurrentCamera
	CollectionService:AddTag(bulletEffect, "WeaponsSystemIgnore")

	local leadingParticles = bulletEffect:FindFirstChild("LeadingParticles", true)
	local attachment0 = bulletEffect:FindFirstChild("Attachment0")
	local trailParticles = nil
	if attachment0 then
		trailParticles = attachment0:FindFirstChild("TrailParticles")
	end

	local hitAttach = bulletEffect:FindFirstChild("HitEffect")
	local hitParticles = bulletEffect:FindFirstChild("HitParticles", true)
	local numHitParticles = self:getConfigValue("NumHitParticles", 3)
	local hitSound = bulletEffect:FindFirstChild("HitSound", true)
	local flyingSound = bulletEffect:FindFirstChild("Flying", true)

	local muzzleFlashTime = self:getConfigValue("MuzzleFlashTime", 0.03)
	local muzzleFlashShown = false

	local beamThickness0 = self:getConfigValue("BeamWidth0", 1.5)
	local beamThickness1 = self:getConfigValue("BeamWidth1", 1.8)
	local beamFadeTime = self:getConfigValue("BeamFadeTime", nil)

	-- Enable beam trails for projectile
	local beam0 = bulletEffect:FindFirstChild("Beam0")
	if beam0 then
		beam0.Enabled = true
	end
	local beam1 = bulletEffect:FindFirstChild("Beam1")
	if beam1 then
		beam1.Enabled = true
	end

	-- Emit muzzle particles
	local muzzleParticles = bulletEffect:FindFirstChild("MuzzleParticles", true)
	local numMuzzleParticles = self:getConfigValue("NumMuzzleParticles", 50)
	if muzzleParticles then
		muzzleParticles.Parent.CFrame = CFrame.new(origin, origin + dir)
		local numSteps = 5
		for _ = 1, numSteps do
			muzzleParticles.Parent.Velocity = Vector3.new(localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10))
			muzzleParticles:Emit(numMuzzleParticles / numSteps)
		end
	end

	-- Show muzzle flash
	if self.tipAttach and self.muzzleFlash0 and self.muzzleFlash1 and self.muzzleFlashBeam and projectileIdx == 1 then
		local minFlashRotation, maxFlashRotation = self:getConfigValue("MuzzleFlashRotation0", -math.pi), self:getConfigValue("MuzzleFlashRotation1", math.pi)
		local minFlashSize, maxFlashSize = self:getConfigValue("MuzzleFlashSize0", 1), self:getConfigValue("MuzzleFlashSize1", 1)
		local flashRotation = localRandom:NextNumber(minFlashRotation, maxFlashRotation)
		local flashSize = localRandom:NextNumber(minFlashSize, maxFlashSize)
		local baseCFrame = self.tipAttach.CFrame * CFrame.Angles(0, 0, flashRotation)
		self.muzzleFlash0.CFrame = baseCFrame * CFrame.new(flashSize * -0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)
		self.muzzleFlash1.CFrame = baseCFrame * CFrame.new(flashSize * 0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)

		self.muzzleFlashBeam.Enabled = true
		self.muzzleFlashBeam.Width0 = flashSize
		self.muzzleFlashBeam.Width1 = flashSize
		muzzleFlashShown = true
	end

	-- Play projectile flying sound
	if flyingSound then
		flyingSound:Play()
	end

	-- Enable trail particles
	if trailParticles then
		trailParticles.Enabled = true
	end

	-- Set up parabola for projectile path
	local parabola = Parabola.new()
	parabola:setPhysicsLaunch(origin, dir * bulletSpeed, nil, 35 * -gravityFactor)
	-- More samples for higher gravity since path will be more curved but raycasts can only be straight lines
	if gravityFactor > 0.66 then
		parabola:setNumSamples(3)
	elseif gravityFactor > 0.33 then
		parabola:setNumSamples(2)
	else
		parabola:setNumSamples(1)
	end

	-- Set up/initialize variables used in steppedCallback
	local stepConn = nil
	local pTravelDistance = 0 -- projected travel distance so far if projectile never stops
	local startTime = tick()
	local didHit = false
	local stoppedMotion = false
	local stoppedMotionAt = 0
	local timeSinceStart = 0
	local flyingVisualEffectsFinished = false -- true if all particle effects shown while projectile is flying are done
	local visualEffectsFinishTime = math.huge
	local visualEffectsLingerTime = 0 -- max time any visual effect needs to finish
	if beamFadeTime then
		visualEffectsLingerTime = beamFadeTime
	end
	local hitInfo = {
		sid = fireInfo.id,
		pid = projectileIdx,
		maxDist = maxDistance,
		part = nil,
		p = nil,
		n = nil,
		m = Enum.Material.Air,
		d = 1e9,
	}

	local steppedCallback = function(dt)
		local now = tick()
		timeSinceStart = now - startTime

		local travelDist = bulletSpeed * dt -- distance projectile has travelled since last frame
		trailLength = trailLength or travelDist * trailLengthFactor

		-- Note: the next three variables are all in terms of distance from starting point (which should be tip of current weapon)
		local projBack = pTravelDistance - trailLength -- furthest back part of projectile (including the trail effect, so will be the start of the trail effect if any)
		local projFront = pTravelDistance -- most forward part of projectile
		local maxDist = hitInfo.maxDist or 0 -- before it collides, this is the max distance the projectile can travel. After it collides, this is the hit point

		-- This will make trailing beams render from tip of gun to wherever projectile is until projectile is destroyed
		if showEntireTrailUntilHit then
			projBack = 0
		end

		-- Validate projBack and projFront
		projBack = math.clamp(projBack, 0, maxDist)
		projFront = math.clamp(projFront, 0, maxDist)

		if not didHit then
			-- Check if bullet hit since last frame
			local castProjBack, castProjFront = projFront, projFront + travelDist
			parabola:setDomain(castProjBack, castProjFront)
			local hitPart, hitPoint, hitNormal, hitMaterial, hitT = parabola:findPart(self.ignoreList)

			if hitPart then
				didHit = true
				projFront = castProjBack + hitT * (castProjFront - castProjBack) -- set projFront to point along projectile arc where an object was hit
				parabola:setDomain(projBack, projFront) -- update parabola domain to match new projFront

				-- Update hitInfo
				hitInfo.part = hitPart
				hitInfo.p = hitPoint
				hitInfo.n = hitNormal
				hitInfo.m = hitMaterial
				hitInfo.d = (hitPoint - origin).Magnitude
				hitInfo.t = hitT
				hitInfo.maxDist = projFront -- since the projectile hit, maxDist is now the hitPoint instead of maxDistance

				-- Register hit on clients
				self:onHit(hitInfo)

				-- Notify the server that this projectile hit something from client that initiated the shot
				-- Show hit indicators on gui of client that shot projectile
				if localPlayerInitiatedShot then
					local hitInfoClone = {}
					for hitInfoKey, value in pairs(hitInfo) do
						hitInfoClone[hitInfoKey] = value
					end
					self.weaponsSystem.getRemoteEvent("WeaponHit"):FireServer(self.instance, hitInfoClone)
				end


				-- Deal with all effects that start/stop/change on hit

				-- Disable trail particles
				if trailParticles then
					trailParticles.Enabled = false
				end

				-- Stop bullet flying sound
				if flyingSound and flyingSound.IsPlaying then
					flyingSound:Stop()
				end

				-- Hide the actual projectile model
				if bulletEffect then
					bulletEffect.Transparency = 1
				end

				-- Stop emitting leading particles
				if leadingParticles then
					leadingParticles.Rate = 0
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, leadingParticles.Lifetime.Max)
				end

				-- Show the explosion on clients for explosive projectiles
				if explodeOnImpact then
					local explosion = Instance.new("Explosion")
					explosion.Position = hitPoint + (hitNormal * 0.5)
					explosion.BlastRadius = blastRadius
					explosion.BlastPressure = 0 -- no blast pressure because the real explosion happens on server
					explosion.ExplosionType = Enum.ExplosionType.NoCraters
					explosion.DestroyJointRadiusPercent = 0
					explosion.Visible = true
					if localPlayerInitiatedShot then
						-- Trigger hit indicators on client that initiated the shot if the explosion hit another player/humanoid
						explosion.Hit:Connect(function(explodedPart, hitDist)
							local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
							if humanoid and
							   explodedPart.Name == "UpperTorso" and
							   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
							   self.weaponsSystem.gui and
							   explodedPart.Parent ~= self.player.Character and
							   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
							then
								self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), humanoid)
							end
						end)
					end
					explosion.Parent = workspace
				end

				-- Make sure hitAttach is in correct position before showing hit effects
				if hitAttach and beam0 and beam0.Attachment1 then
					parabola:renderToBeam(beam0)
					hitAttach.CFrame = beam0.Attachment1.CFrame * CFrame.Angles(0, math.rad(90), 0)
				end

				-- Show hit particle effect
				local hitPartColor = hitPart and hitPart.Color or Color3.fromRGB(255, 255, 255)
				if hitPart and hitPart:IsA("Terrain") then
					hitPartColor = workspace.Terrain:GetMaterialColor(hitMaterial or Enum.Material.Sand)
				end
				if hitInfo.h and hitInfo.h:IsA("Humanoid") and hitParticles and numHitParticles > 0 and hitPart then
					-- Show particle effect for hitting a player/humanoid
					hitParticles.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				elseif (not hitInfo.h or not hitInfo.h:IsA("Humanoid")) and hitParticles and numHitParticles > 0 then
					-- Show particle effect for hitting anything else
					if hitPart and self:getConfigValue("HitParticlesUsePartColor", true) then
						local existingSeq = hitParticles.Color
						local newKeypoints = {}

						for i, keypoint in pairs(existingSeq.Keypoints) do
							local newColor = keypoint.Value
							if newColor == Color3.fromRGB(255, 0, 255) then
								newColor = hitPartColor
							end
							newKeypoints[i] = ColorSequenceKeypoint.new(keypoint.Time, newColor)
						end

						hitParticles.Color = ColorSequence.new(newKeypoints)
					end

					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				end

				-- Play hit sound
				if hitSound then
					hitSound:Play()
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitSound.TimeLength)
				end

				-- Manage/show decals, billboards, and models (such as an arrow) that appear where the projectile hit (only if the hit object was not a humanoid/player)
				local hitPointObjectSpace = hitPart.CFrame:pointToObjectSpace(hitPoint)
				local hitNormalObjectSpace = hitPart.CFrame:vectorToObjectSpace(hitNormal)
				if not NO_BULLET_DECALS and
				   hitPart and
				   not hitPart.Parent or not hitPart.Parent:FindFirstChildOfClass("Humanoid") and
				   hitPointObjectSpace and
				   hitNormalObjectSpace and
				   self.hitMarkTemplate
				then
					-- Clone hitMark (this contains all the decals/billboards/models to show on the hit surface)
					local hitMark = self.hitMarkTemplate:Clone()
					hitMark.Parent = hitPart
					CollectionService:AddTag(hitMark, "WeaponsSystemIgnore")

					-- Move/align hitMark to the hit surface
					local incomingVec = parabola:sampleVelocity(1).Unit
					if self:getConfigValue("AlignHitMarkToNormal", true) then
						-- Make hitMark face straight out from surface where projectile hit (good for decals)
						local forward = hitNormalObjectSpace
						local up = incomingVec
						local right = -forward:Cross(up).Unit
						up = forward:Cross(right)
						local orientationCFrame = CFrame.fromMatrix(hitPointObjectSpace + hitNormalObjectSpace * 0.05, right, up, -forward)
						hitMark.CFrame = hitPart.CFrame:toWorldSpace(orientationCFrame)
					else
						-- Make hitmark appear stuck in the hit surface from the direction the projectile came from (good for things like arrows)
						hitMark.CFrame = hitPart.CFrame * CFrame.new(hitPointObjectSpace, hitPointObjectSpace + hitPart.CFrame:vectorToObjectSpace(incomingVec))
					end

					-- Weld hitMark to the hitPart
					local weld = Instance.new("WeldConstraint")
					weld.Part0 = hitMark
					weld.Part1 = hitPart
					weld.Parent = hitMark

					-- Fade glow decal over time
					local glowDecal = hitMark:FindFirstChild("Glow")
					if glowDecal then
						coroutine.wrap(function()
							local heartbeat = RunService.Heartbeat
							for i = 0, 1, 1/60 do
								heartbeat:Wait()
								glowDecal.Transparency = (i ^ 2)
							end
						end)()
					end

					-- Set bullethole decal color and fade over time
					local bulletHole = hitMark:FindFirstChild("BulletHole")
					if bulletHole then
						bulletHole.Color3 = hitPartColor
						TweenService:Create(
							bulletHole,
							TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 4),
							{ Transparency = 1 }
						):Play()
					end

					-- Fade impact billboard's size and transparency over time
					local impactBillboard = hitMark:FindFirstChild("ImpactBillboard")
					if impactBillboard then
						local impact = impactBillboard:FindFirstChild("Impact")
						local impactTween = TweenService:Create(
							impact,
							TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
							{ Size = UDim2.new(1, 0, 1, 0) }
						)
						impactTween.Completed:Connect(function()
							TweenService:Create(
								impact,
								TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
								{ Size = UDim2.new(0.5, 0, 0.5, 0), ImageTransparency = 1 }
							):Play()
						end)
						impactTween:Play()
					end

					-- Destroy hitMark in 5 seconds
					Debris:AddItem(hitMark, 5)
				end

				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Will enter this if-statement if projectile hit something or maxDistance has been reached
		if projFront >= maxDist then
			if not stoppedMotion then
				stoppedMotion = true
				stoppedMotionAt = now
			end

			-- Stop particle effects if projectile didn't hit anything and projBack has reached the end
			if projBack >= maxDist and not flyingVisualEffectsFinished then
				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Update parabola domain
		parabola:setDomain(projBack, projFront)

		-- Continue updating pTravelDistance until projBack has reached maxDist (this helps with some visual effects)
		if projBack < maxDist then
			pTravelDistance = math.max(0, timeSinceStart * bulletSpeed)
		end


		-- Update visual effects each frame

		-- Update CFrame/velocity of projectile if the projectile uses a model (such as rocket or grenade)
		if shouldMovePart then
			local bulletPos = parabola:samplePoint(1)
			local bulletVelocity = parabola:sampleVelocity(1)
			bulletEffect.CFrame = CFrame.new(bulletPos, bulletPos + bulletVelocity)
			bulletEffect.Velocity = bulletVelocity.Unit * bulletSpeed
		end

		-- Update thickness and render trailing beams
		local thickness0 = beamThickness0
		local thickness1 = beamThickness1
		if beamFadeTime then
			-- Fade out trail beams if projectile is no longer moving (hit something or reached max distance)
			local timeSinceEnd = stoppedMotion and (now - stoppedMotionAt) or 0
			local fadeAlpha = math.clamp(timeSinceEnd / beamFadeTime, 0, 1)
			thickness0 = thickness0 * (1 - fadeAlpha)
			thickness1 = thickness1 * (1 - fadeAlpha)
		end
		if beam0 then
			beam0.Width0 = thickness0
			beam0.Width1 = thickness1
			parabola:renderToBeam(beam0)
		end
		if beam1 then
			beam1.Width0 = thickness0
			beam1.Width1 = thickness1
			parabola:renderToBeam(beam1)
		end

		-- Disable muzzle flash after muzzleFlashTime seconds have passed
		if muzzleFlashShown and timeSinceStart > muzzleFlashTime and self.muzzleFlashBeam then
			self.muzzleFlashBeam.Enabled = false
			muzzleFlashShown = false
		end

		-- Destroy projectile and attached visual effects when visual effects are done showing or max bullet time has been reached
		local timeSinceParticleEffectsFinished = now - visualEffectsFinishTime
		if (flyingVisualEffectsFinished and timeSinceParticleEffectsFinished > 0) or timeSinceStart > MAX_BULLET_TIME then
			if bulletEffect then
				bulletEffect:Destroy()
				bulletEffect = nil
			end

			stepConn:Disconnect()
		end
	end

	stepConn = RunService.Heartbeat:Connect(steppedCallback)

	-- Get rid of charge on chargeable weapons
	if not IsServer and self.usesCharging then
		self.charge = math.clamp(self.charge - self:getConfigValue("FireDischarge", 1), 0, 1)
	end
end

function BulletWeapon:calculateDamage(travelDistance)
	local zeroDamageDistance = self:getConfigValue("ZeroDamageDistance", 10000)
	local fullDamageDistance = self:getConfigValue("FullDamageDistance", 1000)
	local distRange = zeroDamageDistance - fullDamageDistance
	local falloff = math.clamp(1 - (math.max(0, travelDistance - fullDamageDistance) / math.max(1, distRange)), 0, 1)
	return math.max(self:getConfigValue("HitDamage", 10) * falloff, 0)
end

function BulletWeapon:applyDamage(hitInfo)
	local damage = self:calculateDamage(hitInfo.d)

	if damage <= 0 then
		return
	end

	self.weaponsSystem.doDamage(hitInfo.h, damage, nil, self.player)
end

function BulletWeapon:onHit(hitInfo)
	local hitPoint = hitInfo.p
	local hitNormal = hitInfo.n
	local hitPart = hitInfo.part

	if hitPart and hitPart.Parent then
		local humanoid = self.weaponsSystem.getHumanoid(hitPart)
		hitInfo.h = humanoid or hitPart

		if IsServer and
		   (not hitInfo.h:IsA("Humanoid") or
		   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player))
		then
			self:applyDamage(hitInfo)
		elseif hitInfo.h:IsA("Humanoid") and
			hitInfo.h:GetState() ~= Enum.HumanoidStateType.Dead and
			self.weaponsSystem.gui and
			self.player == Players.LocalPlayer and
			self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player)
		then
			-- Show hit indicators on gui of client that shot projectile if players are not on same team
			self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), hitInfo.h)
		end
	end

	-- Create invisible explosion on server that deals damage to anything caught in the explosion
	if IsServer and self:getConfigValue("ExplodeOnImpact", false) then
		local blastRadius = self:getConfigValue("BlastRadius", 8)
		local blastPressure = self:getConfigValue("BlastPressure", 10000)
		local blastDamage = self:getConfigValue("BlastDamage", 100)

		local explosion = Instance.new("Explosion")
		explosion.Position = hitPoint + (hitNormal * 0.5)
		explosion.BlastRadius = blastRadius
		explosion.BlastPressure = blastPressure
		explosion.ExplosionType = Enum.ExplosionType.NoCraters
		explosion.DestroyJointRadiusPercent = 0
		explosion.Visible = false

		explosion.Hit:Connect(function(explodedPart, hitDist)
			local damageMultiplier = (1 - math.clamp((hitDist / blastRadius), 0, 1))
			local damageToDeal = blastDamage * damageMultiplier

			local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
			if humanoid then
				if explodedPart.Name == "UpperTorso" and
				   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
				   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
				then
					-- Do damage to players/humanoids
					self.weaponsSystem.doDamage(humanoid, damageToDeal, nil, self.player)
				end
			elseif not CollectionService:HasTag(explodedPart, "WeaponsSystemIgnore") then
				-- Do damage to a part (sends damage to breaking system)
				self.weaponsSystem.doDamage(explodedPart, damageToDeal, nil, self.player)
			end
		end)

		explosion.Parent = workspace
	end
end

function BulletWeapon:fire(origin, dir, charge)
	if not self:isCharged() then
		return
	end

	BaseWeapon.fire(self, origin, dir, charge)
end

function BulletWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer and firingPlayer == Players.LocalPlayer and fromNetwork then
		return
	end

	local cooldownTime = self:getConfigValue("ShotCooldown", 0.1)
	local fireMode = self:getConfigValue("FireMode", "Semiautomatic")
	local isSemiAuto = fireMode == "Semiautomatic"
	local isBurst = fireMode == "Burst"

	if isBurst and not self.burstFiring then
		self.burstIdx = 0
		self.burstFiring = true
	elseif isSemiAuto then
		self.triggerDisconnected = true
	end

	-- Calculate cooldown time for burst firing
	if self.burstFiring then
		self.burstIdx = self.burstIdx + 1
		if self.burstIdx >= self:getConfigValue("NumBurstShots", 3) then
			self.burstFiring = false
			self.triggerDisconnected = true
		else
			cooldownTime = self:getConfigValue("BurstShotCooldown", nil) or cooldownTime
		end
	end

	self.nextFireTime = tick() + cooldownTime

	BaseWeapon.onFired(self, firingPlayer, fireInfo, fromNetwork)
end

function BulletWeapon:onConfigValueChanged(valueName, newValue, oldValue)
	BaseWeapon.onConfigValueChanged(self, valueName, newValue, oldValue)
	if valueName == "ShotEffect" then
		self.bulletEffectTemplate = ShotsFolder:FindFirstChild(self:getConfigValue("ShotEffect", "Bullet"))
		if self.bulletEffectTemplate then
			local config = self.bulletEffectTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end

			local beam0 = self.bulletEffectTemplate:FindFirstChild("Beam0")
			if beam0 then
				coroutine.wrap(function()
					ContentProvider:PreloadAsync({ beam0 })
				end)()
			end
		end
	elseif valueName == "HitMarkEffect" then
		self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))
		if self.hitMarkTemplate then
			local config = self.hitMarkTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "CasingEffect" then
		self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
		if self.casingTemplate then
			local config = self.casingTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "ChargeRate" then
		self.usesCharging = newValue ~= nil
	end
end

function BulletWeapon:onActivatedChanged()
	BaseWeapon.onActivatedChanged(self)

	if not IsServer then
		-- Reload if no ammo left in clip
		if self.equipped and self:getAmmoInWeapon() <= 0 then
			self:reload()
			return
		end

		-- Fire weapon
		if self.activated and self.player == localPlayer and self:canFire() and tick() > self.nextFireTime then
			self:doLocalFire()
		end

		-- Reenable trigger after activated changes to false
		if not self.activated and self.triggerDisconnected and not self.burstFiring then
			self.triggerDisconnected = false
		end
	end
end

function BulletWeapon:onRenderStepped(dt)
	BaseWeapon.onRenderStepped(self, dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	local tipCFrame = self.tipAttach.WorldCFrame

	if self.player == Players.LocalPlayer then
		-- Retrieve aim point from camera and update player's aim animation
		local aimTrack = self:getAnimTrack(self:getConfigValue("AimTrack", "RifleAim"))
		local aimZoomTrack = self:getAnimTrack(self:getConfigValue("AimZoomTrack", "RifleAimDownSights"))
		if aimTrack then
			local aimDir = tipCFrame.LookVector

			local gunLookRay = Ray.new(tipCFrame.p, aimDir * 500)

			local _, gunHitPoint = Roblox.penetrateCast(gunLookRay, self.ignoreList)

			if self.weaponsSystem.aimRayCallback then
				local _, hitPoint = Roblox.penetrateCast(self.weaponsSystem.aimRayCallback(), self.ignoreList)
				self.aimPoint = hitPoint
			else
				self.aimPoint = gunHitPoint
			end

			if not aimTrack.IsPlaying and not self.reloading then
				aimTrack:Play(0.15)
				coroutine.wrap(function() -- prevent player from firing until gun is fully out
					wait(self:getConfigValue("StartupTime", 0.2))
					self.startupFinished = true
				end)()
			end

			if aimZoomTrack and not self.reloading then
				if not aimZoomTrack.IsPlaying then
					aimZoomTrack:Play(0.15)
				end
				aimZoomTrack:AdjustSpeed(0.001)
				if self.weaponsSystem.camera:isZoomed() then
					if aimTrack.WeightTarget ~= 0 then
						aimZoomTrack:AdjustWeight(1)
						aimTrack:AdjustWeight(0)
					end
				elseif aimTrack.WeightTarget ~= 1 then
					aimZoomTrack:AdjustWeight(0)
					aimTrack:AdjustWeight(1)
				end
			end

			local MIN_ANGLE = -80
			local MAX_ANGLE = 80
			local aimYAngle = math.deg(self.recoilIntensity)
			if self.weaponsSystem.camera.enabled then
				-- Gets pitch and recoil from camera to figure out how high/low to aim the gun
				aimYAngle = math.deg(self.weaponsSystem.camera:getRelativePitch() + self.weaponsSystem.camera.currentRecoil.Y + self.recoilIntensity)
			end
			local aimTimePos = 2 * ((aimYAngle - MIN_ANGLE) / (MAX_ANGLE - MIN_ANGLE))

			aimTrack:AdjustSpeed(0.001)
			aimTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)

			if aimZoomTrack then
				aimZoomTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)
			end

			-- Update recoil (decay over time)
			local recoilDecay = self:getConfigValue("RecoilDecay", 0.825)
			self.recoilIntensity = math.clamp(self.recoilIntensity * recoilDecay, 0, math.huge)
		else
			warn("no aimTrack")
		end
	end
end

function BulletWeapon:setChargingParticles(charge)
	local ratePerCharge = self:getConfigValue("ChargingParticlesRatePerCharge", 20)
	local rate = ratePerCharge * charge
	for _, v in pairs(self.chargingParticles) do
		v.Rate = rate
	end
end

function BulletWeapon:onStepped(dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	BaseWeapon.onStepped(self, dt)

	local now = tick()

	local chargingSound = self:getSound("Charging")
	local dischargingSound = self:getSound("Discharging")

	if self.usesCharging then
		-- Update charge amount
		local chargeBefore = self.charge
		self:handleCharging(dt)
		local chargeDelta = self.charge - chargeBefore

		-- Update charge particles
		if chargeDelta > 0 then
			self:setChargingParticles(self.charge)
		else
			self:setChargingParticles(0)
		end

		-- Play charging sounds
		if chargingSound then
			if chargingSound.Looped then
				if chargeDelta < 0 then
					chargingSound:Stop()
				else
					if not chargingSound.Playing and self.charge < 1 and chargeDelta > 0 then
						chargingSound:Play()
					end
					chargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta > 0 and self.charge <= 1 and not chargingSound.Playing then
					chargingSound.TimePosition = chargingSound.TimeLength * self.charge
					chargingSound:Play()
				elseif chargeDelta <= 0 and chargingSound.Playing then
					chargingSound:Stop()
				end
			end
		end
		if dischargingSound then
			if dischargingSound.Looped then
				if chargeDelta > 0 then
					dischargingSound:Stop()
				else
					if not dischargingSound.Playing and self.charge > 0 then
						dischargingSound:Play()
					end
					dischargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta < 0 and self.charge >= 0 and not dischargingSound.Playing then
					dischargingSound.TimePosition = dischargingSound.TimeLength * self.charge
					dischargingSound:Play()
				elseif chargeDelta >= 0 and dischargingSound.Playing then
					dischargingSound:Stop()
				end
			end
		end

		-- Play charge/discharge completed sounds and particle effects
		if chargeBefore < 1 and self.charge >= 1 then
			local chargeCompleteSound = self:getSound("ChargeComplete")
			if chargeCompleteSound then
				chargeCompleteSound:Play()
			end
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if self.chargeCompleteParticles then
				self.chargeCompleteParticles:Emit(self:getConfigValue("NumChargeCompleteParticles", 25))
			end
		end
		if chargeBefore > 0 and self.charge <= 0 then
			local dischargeCompleteSound = self:getSound("DischargeComplete")
			if dischargeCompleteSound then
				dischargeCompleteSound:Play()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
			if self.dischargeCompleteParticles then
				self.dischargeCompleteParticles:Emit(self:getConfigValue("NumDischargeCompleteParticles", 25))
			end
		end

		self:renderCharge()
	else
		if chargingSound then
			chargingSound:Stop()
		end
		if dischargingSound then
			dischargingSound:Stop()
		end
	end

	if self.usesCharging and self.chargeGlowPart then
		self.chargeGlowPart.Transparency = 1 - self.charge
	end

	-- Fire weapon if it is fully charged
	if self:canFire() and now > self.nextFireTime then
		self:doLocalFire()
	end
end

function BulletWeapon:handleCharging(dt)
	local chargeDelta
	local shouldCharge = self.activated or self.burstFiring or self:getConfigValue("ChargePassively", false)
	if self.reloading or self.triggerDisconnected then
		shouldCharge = false
	end

	if shouldCharge then
		chargeDelta = self:getConfigValue("ChargeRate", 0) * dt
	else
		chargeDelta = self:getConfigValue("DischargeRate", 0) * -dt
	end

	self.charge = math.clamp(self.charge + chargeDelta, 0, 1)
end

function BulletWeapon:isCharged()
	return not self.usesCharging or self.charge >= 1
end

function BulletWeapon:canFire()
	return self.player == Players.LocalPlayer and (self.burstFiring or self.activated) and not self.triggerDisconnected and not self.reloading and self:isCharged() and self.startupFinished
end

function BulletWeapon:doLocalFire()
	if self.tipAttach then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local aimDir = (self.aimPoint - tipPos).Unit

		self:fire(tipPos, aimDir, self.charge)
	end
end

return BulletWeapon

end))
ModuleScript143.Name = "NetworkingCallbacks"
ModuleScript143.Parent = Folder29
table.insert(cors,sandbox(ModuleScript143,function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()
local LocalPlayer = (not IsServer) and Players.LocalPlayer or nil

local NetworkingCallbacks = {}
NetworkingCallbacks.WeaponsSystem = nil

function NetworkingCallbacks.WeaponFired(player, instance, fireInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weaponType.CanBeFired and weapon.player == player then
			weapon:onFired(player, fireInfo, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadRequest(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded then
			weapon:reload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloaded(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= nil and player ~= LocalPlayer then
			weapon:onReloaded(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadCanceled(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= LocalPlayer then
			weapon:cancelReload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponHit(player, instance, hitInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanHit then
			if IsServer then
				weapon:onHit(hitInfo)
			end
		end
	end
end

function NetworkingCallbacks.WeaponActivated(player, instance, activated)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weapon.player == player then
			weapon:setActivated(activated, true)
		end
	end
end

return NetworkingCallbacks

end))
Folder144.Name = "Configuration"
Folder144.Parent = Folder29
BoolValue145.Name = "SprintEnabled"
BoolValue145.Parent = Folder144
BoolValue145.Value = true
BoolValue146.Name = "SlowZoomWalkEnabled"
BoolValue146.Parent = Folder144
BoolValue146.Value = true
Folder147.Name = "Libraries"
Folder147.Parent = Folder29
ModuleScript148.Name = "DamageBillboardHandler"
ModuleScript148.Parent = Folder147
table.insert(cors,sandbox(ModuleScript148,function()
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

if RunService:IsServer() then return {} end

local localPlayer = Players.LocalPlayer
while not localPlayer do
	Players.PlayerAdded:Wait()
	localPlayer = Players.LocalPlayer
end

local adorneeToBillboardGui = {}

local DamageBillboardHandler = {}

function DamageBillboardHandler:CreateBillboardForAdornee(adornee)
	local billboard = adorneeToBillboardGui[adornee]
	if billboard then
		return billboard
	end

	billboard = Instance.new("BillboardGui")
	billboard.Name = "DamageBillboardGui"
	billboard.Adornee = adornee
	billboard.AlwaysOnTop = true
	billboard.ExtentsOffsetWorldSpace = Vector3.new(0,18,0)
	billboard.Size = UDim2.new(0.42,20,15,0)
	billboard.ResetOnSpawn = false
	billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	billboard.Parent = localPlayer.PlayerGui
	adorneeToBillboardGui[adornee] = billboard

	local ancestorCon
	ancestorCon = adornee.AncestryChanged:connect(function(child, parent)
		if parent == nil then
			ancestorCon:disconnect()
			ancestorCon = nil

			local adorneeBillboard = adorneeToBillboardGui[adornee]
			adorneeBillboard:Destroy()
			adorneeToBillboardGui[adornee] = nil
		end
	end)

	return billboard
end

function DamageBillboardHandler:ShowDamageBillboard(damageAmount, adornee)
	damageAmount = math.ceil(damageAmount)

	local billboard = self:CreateBillboardForAdornee(adornee)

	local randomXPos = math.random(-10,10)/30

	local damageNumber = Instance.new("TextLabel")
	damageNumber.AnchorPoint = Vector2.new(0.5, 1)
	damageNumber.BackgroundTransparency = 1
	damageNumber.BorderSizePixel = 0
	damageNumber.Position = UDim2.fromScale(0.5 + randomXPos,1)
	damageNumber.Size = UDim2.fromScale(0,0.25)
	damageNumber.Font = Enum.Font.GothamBlack
	damageNumber.Text = tostring(damageAmount)
	damageNumber.TextColor3 = Color3.new(0.7,0.7,0.7)
	damageNumber.TextScaled = true
	damageNumber.TextStrokeTransparency = 0
	damageNumber.TextTransparency = 0
	damageNumber.TextXAlignment = Enum.TextXAlignment.Center
	damageNumber.TextYAlignment = Enum.TextYAlignment.Bottom
	damageNumber.Parent = billboard

	local appearTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Elastic,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0) --delayTime
	local appearTween = TweenService:Create(
		damageNumber,
		appearTweenInfo, {
			Size = UDim2.fromScale(1, damageNumber.Size.Y.Scale),
			TextColor3 = Color3.new(1,1,1)
		}
	)

	local upTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Linear,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0.2) --delayTime
	local upTween = TweenService:Create(
		damageNumber,
		upTweenInfo, {
			Position = UDim2.fromScale(damageNumber.Position.X.Scale, 0.25),
			TextTransparency = 1,
			TextStrokeTransparency = 4,
			Rotation = math.random(-5,5)
		}
	)

	local completedCon
	completedCon = upTween.Completed:connect(function()
		completedCon:disconnect()
		completedCon = nil
		damageNumber:Destroy()
	end)

	appearTween:Play()
	upTween:Play()
end

return DamageBillboardHandler
end))
ModuleScript149.Name = "DirectionalIndicatorGuiManager"
ModuleScript149.Parent = Folder147
table.insert(cors,sandbox(ModuleScript149,function()
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local DirectionalIndicatorGuiManager = {}
DirectionalIndicatorGuiManager.__index = DirectionalIndicatorGuiManager

local function GetConfigValue(config, propertyName, default)
	if config then
		local property = config:FindFirstChild(propertyName)
		if property then
			return property.Value
		end
	end
	return default
end

function DirectionalIndicatorGuiManager.new(weaponsGui)
	local self = setmetatable({}, DirectionalIndicatorGuiManager)
	self.weaponsGui = weaponsGui
	self.connections = {}
	self.enabled = false

	-- Note DI is an abbreviation for DirectionalIndicator
	self.DIFolder = self.weaponsGui.scalingElementsFolder:WaitForChild("DirectionalIndicators")
	self.DIInfo = {}

	for _, DIFrame in ipairs(self.DIFolder:GetChildren()) do
		if DIFrame:IsA("Frame") and DIFrame:FindFirstChildOfClass("ImageLabel") then
			local config = DIFrame:FindFirstChildOfClass("Configuration")
			local name = GetConfigValue(config, "Name", DIFrame.Name)
			self.DIInfo[name] = self:GetDIInfoFromFrame(DIFrame)

			DIFrame.Visible = true
			self.DIInfo[name].image.ImageTransparency = 1
		end
	end

	return self
end

function DirectionalIndicatorGuiManager:GetDIInfoFromFrame(frame)
	local diInfo = {}
	diInfo.frame = frame
	diInfo.image = frame:FindFirstChildOfClass("ImageLabel")
	diInfo.config = frame:FindFirstChildOfClass("Configuration")
	diInfo.active = false
	diInfo.dieOnFade = false -- will only be true for copies of original DIs
	return diInfo
end

function DirectionalIndicatorGuiManager:ActivateDirectionalIndicator(DIName, otherPosition)
	-- Use original DI, or make a copy if it's already active
	local diInfo = self.DIInfo[DIName]
	if not diInfo then
		warn("Warning: invalid name given to ActivateDirectionalIndicator")
		return
	end

	if diInfo.active then
		local newFrame = diInfo.frame:Clone()
		newFrame.Parent = diInfo.frame.Parent
		diInfo = self:GetDIInfoFromFrame(newFrame)
		diInfo.dieOnFade = true
	end
	diInfo.active = true

	-- Update distance from center
	local distanceLevel = GetConfigValue(diInfo.config, "DistanceLevelFromCenter", 6)
	local widthLevel = GetConfigValue(diInfo.config, "WidthLevel", distanceLevel)
	local levelMultiplier = 0.03
	self.weaponsGui.originalScaleAmounts[diInfo.frame] = Vector2.new(widthLevel * levelMultiplier, distanceLevel * levelMultiplier * 2)
	self.weaponsGui:updateScale(diInfo.frame, workspace.CurrentCamera.ViewportSize)

	-- Set initial indicator rotation and transparency
	diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
	diInfo.image.ImageTransparency = GetConfigValue(diInfo.config, "TransparencyBeforeFade", 0)

	-- Update rotation of indicator as player rotates
	coroutine.wrap(function()
		while diInfo.image.ImageTransparency < 1 do
			diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
			RunService.RenderStepped:Wait()
		end

		diInfo.active = false
		if diInfo.dieOnFade then
			diInfo.frame:Destroy()
			diInfo = nil
		end
	end)()

	-- Show indicator for a bit, then fade out
	coroutine.wrap(function()
		wait(GetConfigValue(diInfo.config, "TimeBeforeFade", 1))
		local tweenInfo = TweenInfo.new(GetConfigValue(diInfo.config, "FadeTime", 1))
		local goal = {}
		goal.ImageTransparency = 1
		local tween = TweenService:Create(diInfo.image, tweenInfo, goal)
		tween:Play()
	end)()
end

function DirectionalIndicatorGuiManager:CalculateDIRotation(otherPosition)
	local camera = self.weaponsGui.weaponsSystem.camera
	local localPlayerOffsetPositionXZ = Vector3.new(camera.currentCamera.Focus.X, 0, camera.currentCamera.Focus.Z)
	local otherPlayerPositionXZ = Vector3.new(otherPosition.X, 0, otherPosition.Z)
	local toOtherPlayer = (localPlayerOffsetPositionXZ - otherPlayerPositionXZ).Unit
	local forward = (Vector3.new(camera.currentCFrame.LookVector.X, 0, camera.currentCFrame.LookVector.Z)).Unit
	if toOtherPlayer == Vector3.new() then
		toOtherPlayer = forward
	end
	local dotProduct = forward:Dot(toOtherPlayer)
	local crossProduct = forward:Cross(toOtherPlayer)
	local acosAngle = math.deg(math.acos(dotProduct))
	local asinAngle = math.deg(math.asin(crossProduct.Y))
	if asinAngle >= 0 then
		acosAngle = 360 - acosAngle
	end
	return acosAngle
end

return DirectionalIndicatorGuiManager
end))
ModuleScript150.Name = "Parabola"
ModuleScript150.Parent = Folder147
table.insert(cors,sandbox(ModuleScript150,function()
local RunService = game:GetService("RunService")

local MIN_HORZ_SPEED = 0.01 --The minimum X and Z velocity for a physical-launch parabola to be considered vertical, helps avoid numerical instability
local DEFAULT_NUM_SAMPLES = RunService:IsServer() and 32 or 32
local DEFAULT_NORMAL = Vector3.new(0, 1, 0)
local ROT_OFFSET = {
	[0] = CFrame.Angles(0, math.rad(90), 0) * CFrame.Angles(math.rad(90), 0, 0),
	[1] = CFrame.Angles(0, math.rad(-90), 0) * CFrame.Angles(math.rad(90), 0, 0)
}
local UP_VECTOR = Vector3.new(0, 1, 0)
local ONE_THIRD, TWO_THIRDS = 1/3, 2/3

local Parabola = {}
Parabola.__index = Parabola

function Parabola.new(a, b, c, x0, x1)
	local self = setmetatable({}, Parabola)

	self.referenceFrame = CFrame.new()

	self.a = a or 1
	self.b = b or 1
	self.c = c or 0

	self.x0 = x0 or 0
	self.x1 = x1 or 10

	self.velocity = Vector2.new()
	self.gravity = 0

	self.numSamples = DEFAULT_NUM_SAMPLES

	return self
end

function Parabola:setPhysicsLaunch(startPoint, velocity, endpointY, gravity)
	gravity = gravity or -workspace.Gravity

	local flatVelocity = velocity * Vector3.new(1, 0, 1)
	if flatVelocity.Magnitude > MIN_HORZ_SPEED then
		self.referenceFrame = CFrame.new(startPoint, startPoint + flatVelocity)
	else
		self.referenceFrame = CFrame.new(startPoint)
	end
	local relativeVelocity = self.referenceFrame:vectorToObjectSpace(velocity)
	local xVelocity, yVelocity = math.max(MIN_HORZ_SPEED, -relativeVelocity.Z), relativeVelocity.Y
	self.a = (0.5 * gravity) * (1 / (xVelocity ^ 2))
	self.b = yVelocity / xVelocity
	self.c = 0

	self.velocity = Vector2.new(xVelocity, yVelocity)
	self.gravity = gravity

	if math.abs(gravity) > 1e-3 then
		self.x0 = 0

		if endpointY and startPoint.Y - endpointY > 0 then
			--y = ax^2 + bx + c
			--0 = ax^2 + bx - y
			--x = (-b +- sqrt(b^2 - 4ac)) / 2a

			local a, b, c = self.a, self.b, startPoint.Y - endpointY
			local det = math.sqrt(b^2 - 4 * a * c)
			local s1, s2 = (-b + det) / (2 * a), (-b - det) / (2 * a)

			self.x1 = math.max(s1, s2)
		else
			self.x1 = math.abs(2 * xVelocity * yVelocity) / math.abs(gravity)
		end
	else
		self.x0 = 0
		self.x1 = 100
	end
end

function Parabola:setNumSamples(numSamples)
	self.numSamples = numSamples
end

function Parabola:setDomain(x0, x1)
	self.x0 = x0
	self.x1 = x1
end

function Parabola:samplePoint(t)
	local a, b, c = self.a, self.b, self.c
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (a * x * x) + (b * x) + c
	return self.referenceFrame:pointToWorldSpace(Vector3.new(0, y, -x))
end

function Parabola:sampleSlope(t)
	local a, b = self.a, self.b
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (2 * a * x) + b
	return y
end

function Parabola:sampleVelocity(t)
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local xVelocity = self.velocity.X
	local xT = x / xVelocity
	local yVelocity = self.velocity.Y + (self.gravity * xT)
	return self.referenceFrame:vectorToWorldSpace(Vector3.new(0, yVelocity, -xVelocity))
end

function Parabola:_penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, UP_VECTOR, Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Parabola:_findPart(funcName, list)
	list = list or {}

	local numSamples = self.numSamples
	local hitPart, hitPoint, hitNormal, hitMaterial, hitT = nil, self.referenceFrame.p, DEFAULT_NORMAL, Enum.Material.Air, 0

	local func = funcName ~= "penetrateCast" and workspace[funcName] or Parabola._penetrateCast

	for i = 1, numSamples do
		local t0 = (i - 1) / numSamples
		local t1 = i / numSamples

		local p0 = self:samplePoint(t0)
		local p1 = self:samplePoint(t1)
		local ray = Ray.new(p0, p1 - p0)

		hitPart, hitPoint, hitNormal, hitMaterial = func(workspace, ray, list)
		if hitPart then
			local hitX = -self.referenceFrame:pointToObjectSpace(hitPoint).Z

			hitT = ((hitX - self.x0) / (self.x1 - self.x0))
			break
		end
	end
	if not hitPart then
		hitT = 1
	end
	return hitPart, hitPoint, hitNormal, hitMaterial, hitT
end

function Parabola:findPart(ignoreList)
	return self:_findPart("penetrateCast", ignoreList)
end
function Parabola:findPartWithWhitelist(whitelist)
	return self:_findPart("FindPartOnRayWithWhitelist", whitelist)
end

function Parabola:findSpheresHit(sphereTable, radius)

end

function Parabola:_setBeamControlPoint(beam, attachment, idx, pos, refFrame)
	local attachmentPos = attachment.WorldPosition
	local vecFromAttachment = pos - attachmentPos
	local curveSize = vecFromAttachment.Magnitude

	attachment.CFrame = refFrame:toObjectSpace(CFrame.new(attachmentPos, pos) * ROT_OFFSET[idx])
	if idx == 0 then
		beam.CurveSize0 = curveSize
	else
		beam.CurveSize1 = curveSize
	end
end

function Parabola:renderToBeam(beam)
	local att0, att1 = beam.Attachment0, beam.Attachment1
	--assert(att0 and att1 and att0.Parent and att0.Parent:IsA("BasePart") and att1.Parent and att1.Parent:IsA("BasePart"), "Beam must have valid attachments that are in a BasePart")

	if not att0.Parent or not att1.Parent then
		return
	end

	local root0, root1 = att0.Parent.CFrame, att1.Parent.CFrame

	local referenceFrame = self.referenceFrame

	local x0, x1 = self.x0, self.x1
	local domain = x1 - x0
	local halfDomain = domain * 0.5
	local p0 = self:samplePoint(0)
	local p1 = self:samplePoint(1)
	local a, b, c = self.a, self.b, self.c
	local x = x0 + (0 * (x1 - x0))
	local cY = ((a * x * x) + (b * x) + c) + self:sampleSlope(0) * halfDomain
	c = referenceFrame:pointToWorldSpace(Vector3.new(0, cY, -(x0 + x1) / 2))
	local c0 = TWO_THIRDS * c + ONE_THIRD * p0
	local c1 = TWO_THIRDS * c + ONE_THIRD * p1

	att0.Position = root0:pointToObjectSpace(p0)
	att1.Position = root1:pointToObjectSpace(p1)

	self:_setBeamControlPoint(beam, att0, 0, c0, root0)
	self:_setBeamControlPoint(beam, att1, 1, c1, root1)
end

return Parabola

end))
ModuleScript151.Name = "Ragdoll"
ModuleScript151.Parent = Folder147
table.insert(cors,sandbox(ModuleScript151,function()
local RunService = game:GetService("RunService")

local JOINT_INFO = {
	LeftShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(45))
	},
	LeftElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	LeftWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},
	RightShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(-45))
	},
	RightElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	RightWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},

	Waist = {
		Limits = { Lower = -45, Upper = 30 }
	},
	Neck = {
		Limits = { Cone = 20, Twist = 20 }
	},

	LeftHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(35)),
	},
	LeftKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	LeftAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	},
	RightHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(-35))
	},
	RightKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	RightAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	}
}

local GROUPS = {
	UpperBody = {
		"Waist",
		"Neck",
		"LeftShoulder",
		"RightShoulder",
		"LeftElbow",
		"RightElbow",
		"LeftWrist",
		"RightWrist"
	},
	LowerBody = {
		"LeftHip",
		"RightHip",
		"LeftKnee",
		"RightKnee",
		"LeftAnkle",
		"RightAnkle"
	},
	LeftArm = {
		"LeftShoulder",
		"LeftElbow",
		"LeftWrist",
	},
	RightArm = {
		"RightShoulder",
		"RightElbow",
		"RightWrist"
	},
	LeftLeg = {
		"LeftHip",
		"LeftKnee",
		"LeftAnkle"
	},
	RightLeg = {
		"RightHip",
		"RightKnee",
		"RightAnkle"
	},
}

local Ragdoll = {}
Ragdoll.__index = Ragdoll

function Ragdoll.new(character)
	local self = setmetatable({}, Ragdoll)
	self.character = character
	self.humanoid = character:WaitForChild("Humanoid")

	self.joints = {}
	for jointName, info in pairs(JOINT_INFO) do
		self.joints[jointName] = self:setupJoint(jointName, info)
	end

	return self
end

function Ragdoll:setupJoint(jointName, info)
	if self.joints[jointName] then
		return self.joints[jointName]
	end

	local constraintName = jointName .. "Constraint"
	local rigAttachmentName = jointName .. "RigAttachment"
	local existingConstraint = self.character:FindFirstChild(constraintName, true)
	local existingMotor = self.character:FindFirstChild(jointName, true)
	if not existingMotor then
		return nil
	end

	if existingConstraint or RunService:IsClient() then
		existingConstraint = self.character:WaitForChild(constraintName)
		return {
			constraint = existingConstraint,
			motor = existingMotor,
			ragdolled = existingMotor.Part1 ~= nil
		}
	else
		local constraintType = "HingeConstraint"
		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraintType = "BallSocketConstraint"
		end

		local constraint = Instance.new(constraintType)
		constraint.Name = constraintName
		constraint.Enabled = false
		constraint.Attachment0 = existingMotor.Part0:FindFirstChild(rigAttachmentName)
		constraint.Attachment1 = existingMotor.Part1:FindFirstChild(rigAttachmentName)
		constraint.LimitsEnabled = info.Limits ~= nil

		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraint.UpperAngle = info.Limits.Cone
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = -info.Limits.Twist
			constraint.TwistUpperAngle = info.Limits.Twist
		elseif info.Limits and info.Limits.Lower and info.Limits.Upper then
			constraint.LowerAngle = info.Limits.Lower
			constraint.UpperAngle = info.Limits.Upper
		end

		constraint.Parent = existingMotor.Parent

		return {
			constraint = constraint,
			motor = existingMotor,
			ragdolled = false
		}
	end
end

function Ragdoll:setJointRagdolled(jointName, ragdolled)
	local joint = self.joints[jointName]
	if not joint then return end

	joint.constraint.Enabled = ragdolled
	if joint.motor and joint.motor:IsA("Motor6D") then
		if ragdolled then
			joint.motor.Part1 = nil
		else
			joint.motor.Part1 = joint.motor.Parent
		end
	end
end

function Ragdoll:setGroupRagdolled(groupName, ragdolled)
	local groupJoints = GROUPS[groupName]
	assert(groupJoints, string.format("%s is not a valid ragdoll group", tostring(groupName)))

	for _, jointName in pairs(groupJoints) do
		self:setJointRagdolled(jointName, ragdolled)
	end
end

function Ragdoll:setRagdolled(ragdolled, whitelist)
	for jointName in pairs(self.joints) do
		if not whitelist or whitelist[jointName] then
			self:setJointRagdolled(jointName, ragdolled)
		end
	end
end

function Ragdoll:destroy()
	self:setRagdolled(false)
	for _, joint in pairs(self.joints) do
		if joint.constraint then
			joint.constraint:Destroy()
		end
	end
	self.joints = {}
end

return Ragdoll

end))
ModuleScript152.Name = "Roblox"
ModuleScript152.Parent = Folder147
table.insert(cors,sandbox(ModuleScript152,function()
local TweenService 		= game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local RunService 		= game:GetService("RunService")
local UserInputService	= game:GetService("UserInputService")

local Roblox = {}

Roblox.Random = Random.new()
Roblox.zeroVector2 = Vector2.new()
Roblox.zeroVector3 = Vector3.new()
Roblox.identityCFrame = CFrame.new()
Roblox.upVector2 = Vector2.new(0, 1)
Roblox.upVector3 = Vector3.new(0, 1, 0)

local guidCharsText = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+./"
local guidChars = {}
for i = 1, #guidCharsText do
	guidChars[i] = guidCharsText:sub(i, i)
end
local guidRandom = Random.new()

function Roblox.newGuid()
	local guid = ""
	for _ = 1, 10 do
		local char = guidRandom:NextInteger(1,#guidChars)
		guid = guid .. guidChars[char]
	end
	return guid
end

function Roblox.isPlaySolo()
	return RunService:IsClient() and RunService:IsServer() and RunService:IsStudio()
end

function Roblox.waitForDescendant(instance, descendantName, timeout)
	timeout = timeout or 60
	local found = instance:FindFirstChild(descendantName, true)
	if found then
		return found
	end

	if timeout < 1e6 and timeout > 0 then
		coroutine.wrap(function()
			wait(timeout)
			if not found then
				warn("Roblox.waitForDescendant(%s, %s) is taking too long")
			end
		end)()
	end

	while not found do
		local newDescendant = instance.DescendantAdded:Wait()
		if newDescendant.Name == descendantName then
			found = newDescendant
			return newDescendant
		end
	end
end

function Roblox.create(className)
	return function(props)
		local instance = Instance.new(className)
		for key, val in pairs(props) do
			if key ~= "Parent" then
				instance[key] = val
			end
		end
		instance.Parent = props.Parent
		return instance
	end
end

function Roblox.weldModel(model)
	local rootPart = model.PrimaryPart
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and part ~= rootPart then
			local weld = Instance.new("WeldConstraint")
			weld.Part0 = rootPart
			weld.Part1 = part
			weld.Parent = part
		end
	end
end

function Roblox.setNetworkOwner(model, owner)
	if not model then warn("Cannot setNetworkOwner on nil model") return end
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and not part.Anchored then
			part:SetNetworkOwner(owner)
		end
	end
end

function Roblox.createMotor6D(root, child)
	local motor = Instance.new("Motor6D")
	motor.Part0 = root
	motor.Part1 = child

	motor.C0 = root.CFrame:toObjectSpace(child.CFrame)
	motor.C1 = CFrame.new()

	motor.Parent = root
	return motor
end

function Roblox.getTotalMass(part)
	local allConnected = part:GetConnectedParts(true)
	local total = 0
	for _, v in pairs(allConnected) do
		total = total + v:GetMass()
	end
	return total
end

function Roblox.waitForTween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
	tween.Completed:wait()
end

function Roblox.tween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
end

function Roblox.fadeAway(gui, duration, level)
	duration = duration or 0.5
	level = level or 0

	local tweenInfo = TweenInfo.new(duration)
	local tweenProps = { BackgroundTransparency = 1 }

	if gui:IsA("TextButton") or gui:IsA("TextLabel") or gui:IsA("TextBox") then
		tweenProps.TextTransparency = 1
		tweenProps.TextStrokeTransparency = 1
	elseif gui:IsA("ImageLabel") or gui:IsA("ImageButton") then
		tweenProps.ImageTransparency = 1
	else
		return
	end

	for _, v in pairs(gui:GetChildren()) do
		Roblox.fadeAway(v, duration, level + 1)
	end


	if level == 0 then
		coroutine.wrap(function()
			Roblox.waitForTween(gui, tweenInfo, tweenProps)
			gui:Destroy()
		end)()
	else
		Roblox.tween(gui, tweenInfo, tweenProps)
	end
end

function Roblox.setModelAnchored(model, anchored)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = anchored
		end
	end
end

function Roblox.setModelLocalVisible(model, visible)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.LocalTransparencyModifier = visible and 0 or 1
		elseif part:IsA("SurfaceGui") then
			part.Enabled = visible
		elseif part:IsA("Decal") then
			part.Transparency = visible and 0 or 1
		end
	end
end

function Roblox.forAllTagged(tagName, enterFunc, exitFunc)
	for _, obj in pairs(CollectionService:GetTagged(tagName)) do
		if enterFunc then
			enterFunc(obj, tagName)
		end
	end
	if enterFunc then
		CollectionService:GetInstanceAddedSignal(tagName):Connect(function(obj) enterFunc(obj, tagName) end)
	end
	if exitFunc then
		CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(obj) exitFunc(obj, tagName) end)
	end
end

function Roblox.getHumanoidFromCharacterPart(part)
	local currentNode = part
	while currentNode do
		local humanoid = currentNode:FindFirstChildOfClass("Humanoid")
		if humanoid then return humanoid end
		currentNode = currentNode.Parent
	end
	return nil
end

local addEsEndings = {
	s = true,
	sh = true,
	ch = true,
	x = true,
	z = true
}
local vowels = {
	a = true,
	e = true,
	i = true,
	o = true,
	u = true
}
function Roblox.formatPlural(num, name, wordOnly)
	if num ~= 1 then
		local lastTwo = name:sub(-2):lower()
		local lastOne = name:sub(-1):lower()

		local suffix = "s"
		if addEsEndings[lastTwo] or addEsEndings[lastOne] then
			suffix = "es"
		elseif lastOne == "o" and #lastTwo == 2 then
			local secondToLast = lastTwo:sub(1, 1)
			if not vowels[secondToLast] then
				suffix = "es"
			end
		end
		name = name .. suffix
	end
	if not wordOnly then
		return ("%s %s"):format(Roblox.formatInteger(num), name)
	else
		return name
	end
end

function Roblox.formatNumberTight(number)
	local order = math.log10(number)
	if order >= 3 and order < 6 then
		return ("%.1fK"):format(number / (10^3))
	end
	if order >= 6 and order < 9 then
		return ("%.1fM"):format(number / (10^6))
	end
	if order >= 9 then
		return ("%.1fB"):format(number / (10^9))
	end

	return tostring(math.floor(number + 0.5))
end

function Roblox.formatInteger(amount)
	amount = math.floor(amount + 0.5)
	local formatted = amount
	local numMatches
	repeat
		formatted, numMatches = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
	until numMatches == 0
	return formatted
end

function Roblox.round(val, decimal)
	if decimal then
		return math.floor((val * 10 ^ decimal) + 0.5) / (10 ^ decimal)
	else
		return math.floor(val + 0.5)
	end
end

function Roblox.formatNumber(number)
	local result, integral, fractional

	integral, fractional = math.modf(number)
	result = Roblox.formatInteger(integral)

	if fractional ~= 0 then
		result = result .. "." .. string.sub(tostring(math.abs(fractional)),3)
	end
	if number < 0 then
		result = "-" .. result
	end

	return result
end

function Roblox.isPointInsidePart(point, part)
	local localPos = part.CFrame:pointToObjectSpace(point)
	return math.abs(localPos.X) <= part.Size.X * 0.5 and math.abs(localPos.Y) <= part.Size.Y * 0.5 and math.abs(localPos.Z) <= part.Size.Z * 0.5
end

function Roblox.rayPlaneIntersect(ray, pointOnPlane, planeNormal)
	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function Roblox.debugPrint(t, level)
	level = level or 0
	local tabs = string.rep("\t", level)
	if typeof(t) == "table" then
		for key, val in pairs(t) do
			print(tabs, key, "=", val)
			if typeof(val) == "table" then
				Roblox.debugPrint(val, level + 1)
			end
		end
	end
end

local function findInstanceImpl(root, path, getChildFunc)
	local currentInstance = root

	while true do
		local nextChildName
		local nextSeparator = path:find("%.")
		if not nextSeparator then
			nextChildName = path
		else
			nextChildName = path:sub(1, nextSeparator - 1)
			path = path:sub(nextSeparator + 1)
		end

		local child = getChildFunc(currentInstance, nextChildName)
		if child then
			currentInstance = child
		else
			return nil
		end
	end
end

local function findFirstChildImpl(parent, childName)
	return parent:FindFirstChild(childName)
end
local function waitForChildImpl(parent, childName)
	return parent:WaitForChild(childName)
end

function Roblox.findInstance(root, path)
	return findInstanceImpl(root, path, findFirstChildImpl)
end

function Roblox.waitForInstance(root, path)
	return findInstanceImpl(root, path, waitForChildImpl)
end

function Roblox.penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and (not hitPart.CanCollide or CollectionService:HasTag(hitPart, "DroppedItemPart") or CollectionService:HasTag(hitPart, "Hidden")) and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Roblox.posInGuiObject(pos, guiObject)
	local guiMin = guiObject.AbsolutePosition
	local guiMax = guiMin + guiObject.AbsoluteSize
	return pos.X >= guiMin.X and pos.X <= guiMax.X and pos.Y >= guiMin.Y and pos.Y <= guiMax.Y
end

function Roblox.getUTCTime()
	local dateInfo = os.date("!*t")
	return string.format("%04d-%02d-%02d %02d:%02d:%02d", dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.min, dateInfo.sec)
end

function Roblox.getUTCTimestamp()
	return os.time(os.date("!*t"))
end

local DURATION_TOKENS = {
	{ "years",   "y",  31536000 },
	{ "months",  "mo", 2592000 },
	{ "weeks",   "w",  604800 },
	{ "days",    "d",  86400 },
	{ "hours",   "h",  3600 },
	{ "minutes", "m",  60 },
	{ "seconds", "s",  1 },
}
function Roblox.parseDurationInSeconds(inputStr)
	local tokensFound = {}
	local totalDurationSeconds = 0
	for _, tokenInfo in pairs(DURATION_TOKENS) do
		local numFound = string.match(inputStr, "(%d+)" .. tokenInfo[2])
		if numFound then
			local num = tonumber(numFound) or 0
			if num > 0 then
				table.insert(tokensFound, string.format("%d %s", num, tokenInfo[1]))
			end
			totalDurationSeconds = totalDurationSeconds + (num * tokenInfo[3])
		end
	end

	local outputStr = table.concat(tokensFound, ", ")
	return totalDurationSeconds, outputStr
end

local random = Random.new()
function Roblox.chooseWeighted(choiceTable)
    local sum = 0
    for _, weight in pairs(choiceTable) do
        sum = sum + weight
    end

    local roll = random:NextNumber(0, 1)
    local choiceSum = 0
    for choiceName, weight in pairs(choiceTable) do
        local chance = weight / sum
        if roll >= choiceSum and roll < choiceSum + chance then
            return choiceName
        else
            choiceSum = choiceSum + chance
        end
    end

    return nil
end

function Roblox.hasMatchingTag(instance, tagPattern)
	for _, tagName in pairs(CollectionService:GetTags(instance)) do
		if tagName:match(tagPattern) ~= nil then
			return true
		end
	end
	return false
end

local highlightTweens = setmetatable({}, { __mode = 'k' })
function Roblox.showHighlight(instance, show)
	local highlightInstance = instance:FindFirstChild("Highlight")
	if not highlightInstance or not highlightInstance:IsA("ImageLabel") then
		return
	end

	local existingTween = highlightTweens[instance]
	if existingTween then
		if show then
			return
		else
			existingTween:Cancel()
			highlightTweens[instance] = nil
			highlightInstance.ImageTransparency = 1
		end
	else
		if not show then
			return
		else
			coroutine.wrap(function()
				highlightInstance.ImageTransparency = 1
				local newTween = TweenService:Create(highlightInstance, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, true), { ImageTransparency = 0 })
				highlightTweens[instance] = newTween
				while highlightTweens[instance] == newTween do
					newTween:Play()
					newTween.Completed:Wait()
				end
			end)()
		end
	end
end

function Roblox.getClickVerb(capitalize)
	local verb = "Click"
	if UserInputService.TouchEnabled then
		verb = "Tap"
	end

	if not capitalize then
		verb = verb:lower()
	end
	return verb
end

function Roblox.computeLaunchAngle(relativePoint, launchVelocity)
	local dx, dy = -relativePoint.Z, relativePoint.Y

	local g = workspace.Gravity
	local invRoot = (launchVelocity ^ 4) - (g * ((g * dx * dx) + (2 * dy * launchVelocity * launchVelocity)))
	if invRoot <= 0 then
		return math.pi / 4
	end

	local root = math.sqrt(invRoot)
	local angle1 = math.atan(((launchVelocity * launchVelocity) + root) / (g * dx))
	local angle2 = math.atan(((launchVelocity * launchVelocity) - root) / (g * dx))

	local chosenAngle = math.min(angle1, angle2)

	return chosenAngle
end

function Roblox.getClosestPointOnLine(line0, line1, point, doClamp)
	local lineVec = line1 - line0
	local pointFromLine0 = point - line0

	local dotProduct = lineVec:Dot(pointFromLine0)
	local t = dotProduct / (lineVec.Magnitude ^ 2)
	if doClamp ~= false then
		t = math.clamp(t, 0, 1)
	end
	local pointOnLine = line0:Lerp(line1, t)
	return pointOnLine, t, (point - pointOnLine).Magnitude
end

function Roblox.getClosestPointOnLines(referencePoint, lines)
	local closestPoint, closestDist, closestLine, closestT = nil, math.huge, nil, 0
	for i = 1, #lines do
		local lineA, lineB = lines[i][1], lines[i][2]

		local point, t, dist = Roblox.getClosestPointOnLine(lineA, lineB, referencePoint)
		if dist < closestDist then
			closestPoint = point
			closestDist = dist
			closestLine = i
			closestT = t
		end
	end

	return closestPoint, closestDist, closestLine, closestT
end

function Roblox.getPointInFrontOnLines(referencePoint, forwardOffset, lines)
	local closestPoint, _, closestLine, closestT = Roblox.getClosestPointOnLines(referencePoint, lines)
	if closestPoint then
		local pointOffset = closestPoint
		local offsetBudget = forwardOffset

		if closestLine == 1 and closestT == 0 then
			local beforeDist = (lines[1][1] - Roblox.getClosestPointOnLine(lines[1][1], lines[1][2], referencePoint, false)).Magnitude
			offsetBudget = offsetBudget - beforeDist
		end

		local lineDir = Vector3.new(0, 0, 0)
		while offsetBudget > 0 and closestLine <= #lines do
			local lineA, lineB = lines[closestLine][1], lines[closestLine][2]
			local lineVec = lineB - lineA
			local lineLength = lineVec.Magnitude
			local pointDistAlongLine = (pointOffset - lineA).Magnitude
			local distLeftOnLine = lineLength - pointDistAlongLine
			lineDir = lineVec.Unit

			if offsetBudget > distLeftOnLine then
				offsetBudget = offsetBudget - distLeftOnLine
				pointOffset = lineB
				closestLine = closestLine + 1
			else
				break
			end
		end
		pointOffset = pointOffset + lineDir * offsetBudget

		return pointOffset
	end
	return closestPoint
end

function Roblox.applySpread(unspreadDir, randomGenerator, minSpread, maxSpread)
	local spreadRotation = randomGenerator:NextNumber(-math.pi, math.pi)
	local spreadOffset = randomGenerator:NextNumber(minSpread, maxSpread)
	local spreadTransform = CFrame.fromAxisAngle(Vector3.new(math.cos(spreadRotation), math.sin(spreadRotation), 0), spreadOffset)
	local unspreadCFrame = CFrame.new(Vector3.new(), unspreadDir)
	return (unspreadCFrame * spreadTransform).LookVector
end

return Roblox

end))
ModuleScript153.Name = "ShoulderCamera"
ModuleScript153.Parent = Folder147
table.insert(cors,sandbox(ModuleScript153,function()
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local UserGameSettings = UserSettings():GetService("UserGameSettings")

local LocalPlayer = Players.LocalPlayer
if RunService:IsClient() then
	while not LocalPlayer do
		Players.PlayerAdded:Wait()
		LocalPlayer = Players.LocalPlayer
	end
end
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

local CAMERA_RENDERSTEP_NAME = "ShoulderCameraUpdate"
local ZOOM_ACTION_NAME = "ShoulderCameraZoom"
local SPRINT_ACTION_NAME = "ShoulderCameraSprint"
local CONTROLLABLE_HUMANOID_STATES = {
	[Enum.HumanoidStateType.Running] = true,
	[Enum.HumanoidStateType.RunningNoPhysics] = true,
	[Enum.HumanoidStateType.Freefall] = true,
	[Enum.HumanoidStateType.Jumping] = true,
	[Enum.HumanoidStateType.Swimming] = false,
	[Enum.HumanoidStateType.Landed] = true
}

-- Gamepad thumbstick utilities
local k = 0.5
local lowerK = 0.9
local function SCurveTransform(t)
	t = math.clamp(t, -1,1)
	if t >= 0 then
		return (k*t) / (k - t + 1)
	end
	return -((lowerK*-t) / (lowerK + t + 1))
end

local DEADZONE = 0.25
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
end

local function fromSCurveSpace(t)
	return t/2 + 0.5
end

-- Applies a nonlinear transform to the thumbstick position to serve as the acceleration for camera rotation.
-- See https://www.desmos.com/calculator/xw2ytjpzco for a visual reference.
local function gamepadLinearToCurve(thumbstickPosition)
	return Vector2.new(
		math.clamp(math.sign(thumbstickPosition.X) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.X)))), -1, 1),
		math.clamp(math.sign(thumbstickPosition.Y) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.Y)))), -1, 1))
end


-- Remove back accessories since they frequently block the camera
local function isBackAccessory(instance)
	if instance and instance:IsA("Accessory") then
		local handle = instance:WaitForChild("Handle", 5)
		if handle and handle:IsA("Part") then
			local bodyBackAttachment = handle:WaitForChild("BodyBackAttachment", 5)
			if bodyBackAttachment and bodyBackAttachment:IsA("Attachment") then
				return true
			end

			local waistBackAttachment = handle:WaitForChild("WaistBackAttachment", 5)
			if waistBackAttachment and waistBackAttachment:IsA("Attachment") then
				return true
			end
		end
	end

	return false
end

local function removeBackAccessoriesFromCharacter(character)
	for _, child in ipairs(character:GetChildren()) do
		coroutine.wrap(function()
			if isBackAccessory(child) then
				child:Destroy()
			end
		end)()
	end
end

local descendantAddedConnection = nil
local function onCharacterAdded(character)
	removeBackAccessoriesFromCharacter(character)
	descendantAddedConnection = character.DescendantAdded:Connect(function(descendant)
		coroutine.wrap(function()
			if isBackAccessory(descendant) then
				descendant:Destroy()
			end
		end)()
	end)
end

local function onCharacterRemoving(character)
	if descendantAddedConnection then
		descendantAddedConnection:Disconnect()
		descendantAddedConnection = nil
	end
end

-- Set up the Local Player
if RunService:IsClient() then
	if LocalPlayer.Character then
		onCharacterAdded(LocalPlayer.Character)
	end
	LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
	LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)
end


local ShoulderCamera = {}
ShoulderCamera.__index = ShoulderCamera
ShoulderCamera.SpringService = nil

function ShoulderCamera.new(weaponsSystem)
	local self = setmetatable({}, ShoulderCamera)
	self.weaponsSystem = weaponsSystem

	-- Configuration parameters (constants)
	self.fieldOfView = 70
	self.minPitch = math.rad(-75) -- min degrees camera can angle down
	self.maxPitch = math.rad(75) -- max degrees camera can cangle up
	self.normalOffset = Vector3.new(2.25, 2.25, 10.5) -- this is the camera's offset from the player
	self.zoomedOffsetDistance = 8 -- number of studs to zoom in from default offset when zooming
	self.normalCrosshairScale = 1
	self.zoomedCrosshairScale = 0.75
	self.defaultZoomFactor = 1
	self.canZoom = true
	self.zoomInputs = { Enum.UserInputType.MouseButton2, Enum.KeyCode.ButtonL2 }
	self.sprintInputs = { Enum.KeyCode.LeftShift }
	self.mouseRadsPerPixel = Vector2.new(1 / 480, 1 / 480)
	self.zoomedMouseRadsPerPixel = Vector2.new(1 / 1200, 1 / 1200)
	self.touchSensitivity = Vector2.new(1 / 100, 1 / 100)
	self.zoomedTouchSensitivity = Vector2.new(1 / 200, 1 / 200)
	self.touchDelayTime = 0.25 -- max time for a touch to count as a tap (to shoot the weapon instead of control camera),
	                           -- also the amount of time players have to start a second touch after releasing the first time to trigger automatic fire
	self.recoilDecay = 2 -- higher number means faster recoil decay rate
	self.rotateCharacterWithCamera = true
	self.gamepadSensitivityModifier = Vector2.new(0.85, 0.65)
	-- Walk speeds
	self.zoomWalkSpeed = 8
	self.normalWalkSpeed = 16
	self.sprintingWalkSpeed = 24

	-- Current state
	self.enabled = false
	self.yaw = 0
	self.pitch = 0
	self.currentCFrame = CFrame.new()
	self.currentOffset = self.normalOffset
	self.currentRecoil = Vector2.new(0, 0)
	self.currentMouseRadsPerPixel = self.mouseRadsPerPixel
	self.currentTouchSensitivity = self.touchSensitivity
	self.mouseLocked = true
	self.touchPanAccumulator = Vector2.new(0, 0) -- used for touch devices, represents amount the player has dragged their finger since starting a touch
	self.currentTool = nil
	self.sprintingInputActivated = false
	self.desiredWalkSpeed = self.normalWalkSpeed
	self.sprintEnabled = false -- true means player will move faster while doing sprint inputs
	self.slowZoomWalkEnabled = false -- true means player will move slower while doing zoom inputs
	self.desiredFieldOfView = self.fieldOfView
	-- Zoom variables
	self.zoomedFromInput = false -- true if player has performed input to zoom
	self.forcedZoomed = false -- ignores zoomedFromInput and canZoom
	self.zoomState = false -- true if player is currently zoomed in
	self.zoomAlpha = 0
	self.hasScope = false
	self.hideToolWhileZoomed = false
	self.currentZoomFactor = self.defaultZoomFactor
	self.zoomedFOV = self.fieldOfView
	-- Gamepad variables
	self.gamepadPan = Vector2.new(0, 0) -- essentially the amount the gamepad has moved from resting position
	self.movementPan = Vector2.new(0, 0) -- this is for movement (gamepadPan is for camera)
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.lastThumbstickTime = nil
	self.currentGamepadSpeed = 0
	self.lastGamepadVelocity = Vector2.new(0, 0)

	-- Occlusion
	self.lastOcclusionDistance = 0
	self.lastOcclusionReachedTime = 0 -- marks the last time camera was at the true occlusion distance
	self.defaultTimeUntilZoomOut = 0
	self.timeUntilZoomOut = self.defaultTimeUntilZoomOut -- time after lastOcclusionReachedTime that camera will zoom out
	self.timeLastPoppedWayIn = 0 -- this holds the last time camera popped nearly into first person
	self.isZoomingOut = false
	self.tweenOutTime = 0.2
	self.curOcclusionTween = nil
	self.occlusionTweenObject = nil

	-- Side correction (when player is against a wall)
	self.sideCorrectionGoalVector = nil
	self.lastSideCorrectionMagnitude = 0
	self.lastSideCorrectionReachedTime = 0 -- marks the last time the camera was at the true correction distance
	self.revertSideCorrectionSpeedMultiplier = 2 -- speed at which camera reverts the side correction (towards 0 correction)
	self.defaultTimeUntilRevertSideCorrection = 0.75
	self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection -- time after lastSideCorrectionReachedTime that camera will revert the correction
	self.isRevertingSideCorrection = false

	-- Datamodel references
	self.eventConnections = {}
	self.raycastIgnoreList = {}
	self.currentCamera = nil
	self.currentCharacter = nil
	self.currentHumanoid = nil
	self.currentRootPart = nil
	self.controlModule = nil -- used to get player's touch input for moving character
	self.random = Random.new()

	return self
end

function ShoulderCamera:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end
	self.enabled = enabled

	if self.enabled then
		RunService:BindToRenderStep(CAMERA_RENDERSTEP_NAME, Enum.RenderPriority.Camera.Value - 1, function(dt) self:onRenderStep(dt) end)
		ContextActionService:BindAction(ZOOM_ACTION_NAME, function(...) self:onZoomAction(...) end, false, unpack(self.zoomInputs))
		ContextActionService:BindAction(SPRINT_ACTION_NAME, function(...) self:onSprintAction(...) end, false, unpack(self.sprintInputs))

		table.insert(self.eventConnections, LocalPlayer.CharacterAdded:Connect(function(character) self:onCurrentCharacterChanged(character) end))
		table.insert(self.eventConnections, LocalPlayer.CharacterRemoving:Connect(function() self:onCurrentCharacterChanged(nil) end))
		table.insert(self.eventConnections, workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() self:onCurrentCameraChanged(workspace.CurrentCamera) end))
		table.insert(self.eventConnections, UserInputService.InputBegan:Connect(function(inputObj, wasProcessed) self:onInputBegan(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputChanged:Connect(function(inputObj, wasProcessed) self:onInputChanged(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputEnded:Connect(function(inputObj, wasProcessed) self:onInputEnded(inputObj, wasProcessed) end))

		self:onCurrentCharacterChanged(LocalPlayer.Character)
		self:onCurrentCameraChanged(workspace.CurrentCamera)

		-- Make transition to shouldercamera smooth by facing in same direction as previous camera
		local cameraLook = self.currentCamera.CFrame.lookVector
		self.yaw = math.atan2(-cameraLook.X, -cameraLook.Z)
		self.pitch = math.asin(cameraLook.Y)

		self.currentCamera.CameraType = Enum.CameraType.Scriptable

		self:setZoomFactor(self.currentZoomFactor) -- this ensures that zoomedFOV reflecs currentZoomFactor

		workspace.CurrentCamera.CameraSubject = self.currentRootPart

		self.occlusionTweenObject = Instance.new("NumberValue")
		self.occlusionTweenObject.Name = "OcclusionTweenObject"
		self.occlusionTweenObject.Parent = script
		self.occlusionTweenObject.Changed:Connect(function(value)
			self.lastOcclusionDistance = value
		end)

		-- Sets up weapon system to use camera for raycast direction instead of gun look vector
		self.weaponsSystem.aimRayCallback = function()
			local cameraCFrame = self.currentCFrame
			return Ray.new(cameraCFrame.p, cameraCFrame.LookVector * 500)
		end
	else
		RunService:UnbindFromRenderStep(CAMERA_RENDERSTEP_NAME)
		ContextActionService:UnbindAction(ZOOM_ACTION_NAME)
		ContextActionService:UnbindAction(SPRINT_ACTION_NAME)

		if self.currentHumanoid then
			self.currentHumanoid.AutoRotate = true
		end

		if self.currentCamera then
			self.currentCamera.CameraType = Enum.CameraType.Custom
		end

		self:updateZoomState()

		self.yaw = 0
		self.pitch = 0

		for _, conn in pairs(self.eventConnections) do
			conn:Disconnect()
		end
		self.eventConnections = {}

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end
end

function ShoulderCamera:onRenderStep(dt)
	if not self.enabled or
	   not self.currentCamera or
	   not self.currentCharacter or
	   not self.currentHumanoid or
	   not self.currentRootPart
	then
		return
	end

	-- Hide mouse and lock to center if applicable
	if self.mouseLocked and not GuiService:GetEmotesMenuOpen() then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end

	-- Handle gamepad input
	self:processGamepadInput(dt)

	-- Smoothly zoom to desired values
	if self.hasScope then
		ShoulderCamera.SpringService:Target(self, 0.8, 8, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 8, { FieldOfView = self.desiredFieldOfView })
	else
		ShoulderCamera.SpringService:Target(self, 0.8, 3, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 3, { FieldOfView = self.desiredFieldOfView })
	end

	-- Handle walk speed changes
	if self.sprintEnabled or self.slowZoomWalkEnabled then
		self.desiredWalkSpeed = self.normalWalkSpeed
		if self.sprintEnabled and (self.sprintingInputActivated or self:sprintFromTouchInput() or self:sprintFromGamepadInput()) and not self.zoomState then
			self.desiredWalkSpeed = self.sprintingWalkSpeed
		end
		if self.slowZoomWalkEnabled and self.zoomAlpha > 0.1 then
			self.desiredWalkSpeed = self.zoomWalkSpeed
		end

		ShoulderCamera.SpringService:Target(self.currentHumanoid, 0.95, 4, { WalkSpeed = self.desiredWalkSpeed })
	end

	-- Initialize variables used for side correction, occlusion, and calculating camera focus/rotation
	local rootPartPos = self.currentRootPart.CFrame.Position
	local rootPartUnrotatedCFrame = CFrame.new(rootPartPos)
	local yawRotation = CFrame.Angles(0, self.yaw, 0)
	local pitchRotation = CFrame.Angles(self.pitch + self.currentRecoil.Y, 0, 0)
	local xOffset = CFrame.new(self.normalOffset.X, 0, 0)
	local yOffset = CFrame.new(0, self.normalOffset.Y, 0)
	local zOffset = CFrame.new(0, 0, self.normalOffset.Z)
	local collisionRadius = self:getCollisionRadius()
	local cameraYawRotationAndXOffset =
		yawRotation * 		-- First rotate around the Y axis (look left/right)
		xOffset 			-- Then perform the desired offset (so camera is centered to side of player instead of directly on player)
	local cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset

	-- Handle/Calculate side correction when player is adjacent to a wall (so camera doesn't go in the wall)
	local vecToFocus = cameraFocus.p - rootPartPos
	local rayToFocus = Ray.new(rootPartPos, vecToFocus + (vecToFocus.Unit * collisionRadius))
	local hitPart, hitPoint, hitNormal = self:penetrateCast(rayToFocus, self.raycastIgnoreList)
	local currentTime = tick()
	local sideCorrectionGoalVector = Vector3.new() -- if nothing is adjacent to player, goal vector is (0, 0, 0)
	if hitPart then
		hitPoint = hitPoint + (hitNormal * collisionRadius)
		sideCorrectionGoalVector = hitPoint - cameraFocus.p
		if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then -- make it easy for camera to pop closer to player (move left)
			if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection and self.lastSideCorrectionMagnitude ~= 0 then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection * 2 -- double time until revert if popping in repeatedly
			elseif self.lastSideCorrectionMagnitude == 0 and self.timeUntilRevertSideCorrection ~= self.defaultTimeUntilRevertSideCorrection then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection
			end
			self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
			self.lastSideCorrectionReachedTime = currentTime
			self.isRevertingSideCorrection = false
		else
			self.isRevertingSideCorrection = true
		end
	elseif self.lastSideCorrectionMagnitude ~= 0 then
		self.isRevertingSideCorrection = true
	end
	if self.isRevertingSideCorrection then -- make it hard/slow for camera to revert side correction (move right)
		if sideCorrectionGoalVector.Magnitude > self.lastSideCorrectionMagnitude - 1 and sideCorrectionGoalVector.Magnitude ~= 0 then
			self.lastSideCorrectionReachedTime = currentTime -- reset timer if occlusion significantly increased since last frame
		end
		if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection then
			local sideCorrectionChangeAmount = dt * (vecToFocus.Magnitude) * self.revertSideCorrectionSpeedMultiplier
			self.lastSideCorrectionMagnitude = self.lastSideCorrectionMagnitude - sideCorrectionChangeAmount
			if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then
				self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
				self.lastSideCorrectionReachedTime = currentTime
				self.isRevertingSideCorrection = false
			end
		end
	end

	-- Update cameraFocus to reflect side correction
	cameraYawRotationAndXOffset = cameraYawRotationAndXOffset + (-vecToFocus.Unit * self.lastSideCorrectionMagnitude)
	cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset
	self.currentCamera.Focus = cameraFocus

	-- Calculate and apply CFrame for camera
	local cameraCFrameInSubjectSpace =
		cameraYawRotationAndXOffset *
		pitchRotation * 	-- rotate around the X axis (look up/down)
		yOffset *			-- move camera up/vertically
		zOffset				-- move camera back
	self.currentCFrame = rootPartUnrotatedCFrame * cameraCFrameInSubjectSpace

	-- Move camera forward if zoomed in
	if self.zoomAlpha > 0 then
		local trueZoomedOffset = math.max(self.zoomedOffsetDistance - self.lastOcclusionDistance, 0) -- don't zoom too far in if already occluded
		self.currentCFrame = self.currentCFrame:lerp(self.currentCFrame + trueZoomedOffset * self.currentCFrame.LookVector.Unit, self.zoomAlpha)
	end

	self.currentCamera.CFrame = self.currentCFrame

	-- Handle occlusion
	local occlusionDistance = self.currentCamera:GetLargestCutoffDistance(self.raycastIgnoreList)
	if occlusionDistance > 1e-5 then
		occlusionDistance = occlusionDistance + collisionRadius
	end
	if occlusionDistance >= self.lastOcclusionDistance then -- make it easy for the camera to pop in towards the player
		if self.curOcclusionTween ~= nil then
			self.curOcclusionTween:Cancel()
			self.curOcclusionTween = nil
		end
		if currentTime > self.lastOcclusionReachedTime + self.timeUntilZoomOut and self.lastOcclusionDistance ~= 0 then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut * 2 -- double time until zoom out if popping in repeatedly
		elseif self.lastOcclusionDistance == 0  and self.timeUntilZoomOut ~= self.defaultTimeUntilZoomOut then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut
		end

		if occlusionDistance / self.normalOffset.Z > 0.8 and self.timeLastPoppedWayIn == 0 then
			self.timeLastPoppedWayIn = currentTime
		end

		self.lastOcclusionDistance = occlusionDistance
		self.lastOcclusionReachedTime = currentTime
		self.isZoomingOut = false
	else -- make it hard/slow for camera to zoom out
		self.isZoomingOut = true
		if occlusionDistance > self.lastOcclusionDistance - 2 and occlusionDistance ~= 0 then -- reset timer if occlusion significantly increased since last frame
			self.lastOcclusionReachedTime = currentTime
		end

		-- If occlusion pops camera in to almost first person for a short time, pop out instantly
		if currentTime < self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.lastOcclusionDistance / self.normalOffset.Z > 0.8 then
			self.lastOcclusionDistance = occlusionDistance
			self.lastOcclusionReachedTime = currentTime
			self.isZoomingOut = false
		elseif currentTime >= self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.timeLastPoppedWayIn ~= 0 then
			self.timeLastPoppedWayIn = 0
		end
	end

	-- Update occlusion amount if timeout time has passed
	if currentTime >= self.lastOcclusionReachedTime + self.timeUntilZoomOut and not self.zoomState then
		if self.curOcclusionTween == nil then
			self.occlusionTweenObject.Value = self.lastOcclusionDistance
			local tweenInfo = TweenInfo.new(self.tweenOutTime)
			local goal = {}
			goal.Value = self.lastOcclusionDistance - self.normalOffset.Z
			self.curOcclusionTween = TweenService:Create(self.occlusionTweenObject, tweenInfo, goal)
			self.curOcclusionTween:Play()
		end
	end

	-- Apply occlusion to camera CFrame
	local currentOffsetDir = self.currentCFrame.LookVector.Unit
	self.currentCFrame = self.currentCFrame + (currentOffsetDir * self.lastOcclusionDistance)
	self.currentCamera.CFrame = self.currentCFrame

	-- Apply recoil decay
	self.currentRecoil = self.currentRecoil - (self.currentRecoil * self.recoilDecay * dt)

	if self:isHumanoidControllable() and self.rotateCharacterWithCamera then
		self.currentHumanoid.AutoRotate = false
		self.currentRootPart.CFrame = CFrame.Angles(0, self.yaw, 0) + self.currentRootPart.Position -- rotate character to be upright and facing the same direction as camera
		self:applyRootJointFix()
	else
		self.currentHumanoid.AutoRotate = true
	end

	self:handlePartTransparencies()
	self:handleTouchToolFiring()
end

-- This function keeps the held weapon from bouncing up and down too much when you move
function ShoulderCamera:applyRootJointFix()
	if self.rootJoint then
		local translationScale = self.zoomState and Vector3.new(0.25, 0.25, 0.25) or Vector3.new(0.5, 0.5, 0.5)
		local rotationScale = self.zoomState and 0.15 or 0.2
		local rootRotation = self.rootJoint.Part0.CFrame - self.rootJoint.Part0.CFrame.Position
		local rotation = self.rootJoint.Transform - self.rootJoint.Transform.Position
		local yawRotation = CFrame.Angles(0, self.yaw, 0)
		local leadRotation = rootRotation:toObjectSpace(yawRotation)
		local rotationFix = self.rootRigAttach.CFrame
		if self:isHumanoidControllable() then
			rotationFix = self.rootJoint.Transform:inverse() * leadRotation * rotation:Lerp(CFrame.new(), 1 - rotationScale) + (self.rootJoint.Transform.Position * translationScale)
		end

		self.rootJoint.C0 = CFrame.new(self.rootJoint.C0.Position, self.rootJoint.C0.Position + rotationFix.LookVector.Unit)
	end
end

function ShoulderCamera:sprintFromTouchInput()
	local moveVector = nil
	local activeController = nil
	local activeControllerIsTouch = nil
	if self.controlModule then
		moveVector = self.controlModule:GetMoveVector()
		activeController = self.controlModule:GetActiveController()
	end
	if moveVector and activeController then
		activeControllerIsTouch = activeController.thumbstickFrame ~= nil or activeController.thumbpadFrame ~= nil
	end

	if activeControllerIsTouch then
		return (moveVector and moveVector.Magnitude >= 0.9)
	else
		return false
	end
end

function ShoulderCamera:sprintFromGamepadInput()
	return self.movementPan.Magnitude > 0.9
end

function ShoulderCamera:onCurrentCharacterChanged(character)
	self.currentCharacter = character
	if self.currentCharacter then
		self.raycastIgnoreList[1] = self.currentCharacter
		self.currentHumanoid = character:WaitForChild("Humanoid")
		self.currentRootPart = character:WaitForChild("HumanoidRootPart")

		self.rootRigAttach = self.currentRootPart:WaitForChild("RootRigAttachment")
		self.rootJoint = character:WaitForChild("LowerTorso"):WaitForChild("Root")
		self.currentWaist = character:WaitForChild("UpperTorso"):WaitForChild("Waist")
		self.currentWrist = character:WaitForChild("RightHand"):WaitForChild("RightWrist")
		self.wristAttach0 = character:WaitForChild("RightLowerArm"):WaitForChild("RightWristRigAttachment")
		self.wristAttach1 = character:WaitForChild("RightHand"):WaitForChild("RightWristRigAttachment")
		self.rightGripAttachment = character:WaitForChild("RightHand"):WaitForChild("RightGripAttachment")

		self.currentTool = character:FindFirstChildOfClass("Tool")

		self.eventConnections.humanoidDied = self.currentHumanoid.Died:Connect(function()
			self.zoomedFromInput = false
			self:updateZoomState()
		end)
		self.eventConnections.characterChildAdded = character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.currentTool = child
				self:updateZoomState()
			end
		end)
		self.eventConnections.characterChildRemoved = character.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") and self.currentTool == child then
				self.currentTool = character:FindFirstChildOfClass("Tool")
				self:updateZoomState()
			end
		end)

		if Players.LocalPlayer then
			local PlayerScripts = Players.LocalPlayer:FindFirstChild("PlayerScripts")
			if PlayerScripts then
				local PlayerModule = PlayerScripts:FindFirstChild("PlayerModule")
				if PlayerModule then
					self.controlModule = require(PlayerModule:FindFirstChild("ControlModule"))
				end
			end
		end
	else
		if self.eventConnections.humanoidDied then
			self.eventConnections.humanoidDied:Disconnect()
			self.eventConnections.humanoidDied = nil
		end
		if self.eventConnections.characterChildAdded then
			self.eventConnections.characterChildAdded:Disconnect()
			self.eventConnections.characterChildAdded = nil
		end
		if self.eventConnections.characterChildRemoved then
			self.eventConnections.characterChildRemoved:Disconnect()
			self.eventConnections.characterChildRemoved = nil
		end

		self.currentTool = nil
		self.currentHumanoid = nil
		self.currentRootPart = nil
		self.controlModule = nil
	end
end

function ShoulderCamera:onCurrentCameraChanged(camera)
	if self.currentCamera == camera then
		return
	end

	self.currentCamera = camera

	if self.currentCamera then
		self.raycastIgnoreList[2] = self.currentCamera

		if self.eventConnections.cameraTypeChanged then
			self.eventConnections.cameraTypeChanged:Disconnect()
			self.eventConnections.cameraTypeChanged = nil
		end
		self.eventConnections.cameraTypeChanged = self.currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
			if self.enabled then
				self.currentCamera.CameraType = Enum.CameraType.Scriptable
			end
		end)
	end
end

function ShoulderCamera:isHumanoidControllable()
	if not self.currentHumanoid then
		return false
	end
	local humanoidState = self.currentHumanoid:GetState()
	return CONTROLLABLE_HUMANOID_STATES[humanoidState] == true
end

function ShoulderCamera:getCollisionRadius()
	if not self.currentCamera then
		return 0
	end
	local viewportSize = self.currentCamera.ViewportSize
	local aspectRatio = viewportSize.X / viewportSize.Y
	local fovRads = math.rad(self.fieldOfView)
	local imageHeight = math.tan(fovRads) * math.abs(self.currentCamera.NearPlaneZ)
	local imageWidth = imageHeight * aspectRatio

	local cornerPos = Vector3.new(imageWidth, imageHeight, self.currentCamera.NearPlaneZ)
	return cornerPos.Magnitude
end

function ShoulderCamera:penetrateCast(ray, ignoreList)
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function ShoulderCamera:getRelativePitch()
	if self.currentRootPart then
		local pitchRotation = CFrame.Angles(self.pitch, 0, 0)
		local relativeRotation = self.currentRootPart.CFrame:toObjectSpace(pitchRotation)
		local relativeLook = relativeRotation.lookVector

		local angle = math.asin(relativeLook.Y)
		return math.clamp(angle, self.minPitch, self.maxPitch)
	end
	return self.pitch
end

function ShoulderCamera:getCurrentFieldOfView()
	if self.zoomState then
		return self.zoomedFOV
	else
		return self.fieldOfView
	end
end

function ShoulderCamera:handlePartTransparencies()
	local partsLookup = {}
	local accoutrementsLookup = {}

	for _, child in pairs(self.currentCharacter:GetChildren()) do
		local hidden = false
		if child:IsA("BasePart") then
			hidden = partsLookup[child.Name] == true
			child.LocalTransparencyModifier = hidden and 1 or 0
		elseif child:IsA("Accoutrement") then
			local descendants = child:GetDescendants()
			local accoutrementParts = {}
			for _, desc in pairs(descendants) do
				if desc:IsA("Attachment") and accoutrementsLookup[desc.Name] then
					hidden = true
				elseif desc:IsA("BasePart") then
					table.insert(accoutrementParts, desc)
				end
			end
			for _, part in pairs(accoutrementParts) do
				part.LocalTransparencyModifier = hidden and 1 or 0
			end
		elseif child:IsA("Tool") then
			hidden = self.zoomState and (self.hasScope or self.hideToolWhileZoomed)
			for _, part in pairs(child:GetDescendants()) do
				if part:IsA("BasePart") then
					part.LocalTransparencyModifier = hidden and 1 or 0
				end
			end
		end
	end
end

function ShoulderCamera:setSprintEnabled(enabled)
	self.sprintEnabled = enabled
end

function ShoulderCamera:setSlowZoomWalkEnabled(enabled)
	self.slowZoomWalkEnabled = enabled
end

function ShoulderCamera:setHasScope(hasScope)
	if self.hasScope == hasScope then
		return
	end

	self.hasScope = hasScope
	self:updateZoomState()
end

function ShoulderCamera:onSprintAction(actionName, inputState, inputObj)
	self.sprintingInputActivated = inputState == Enum.UserInputState.Begin
end


-- Zoom related functions

function ShoulderCamera:isZoomed()
	return self.zoomState
end

function ShoulderCamera:setHideToolWhileZoomed(hide)
	self.hideToolWhileZoomed = hide
end

function ShoulderCamera:setZoomFactor(zoomFactor)
	self.currentZoomFactor = zoomFactor
	local nominalFOVRadians = math.rad(self.fieldOfView)
	local nominalImageHeight = math.tan(nominalFOVRadians / 2)
	local zoomedImageHeight = nominalImageHeight / self.currentZoomFactor
	self.zoomedFOV = math.deg(math.atan(zoomedImageHeight) * 2)
	self:updateZoomState()
end

function ShoulderCamera:resetZoomFactor()
	self:setZoomFactor(self.defaultZoomFactor)
end

function ShoulderCamera:setForceZoomed(zoomed)
	if self.forcedZoomed == zoomed then return end
	self.forcedZoomed = zoomed
	self:updateZoomState()
end

function ShoulderCamera:setZoomedFromInput(zoomedFromInput)
	if self.zoomedFromInput == zoomedFromInput or (self.currentHumanoid and self.currentHumanoid:GetState() == Enum.HumanoidStateType.Dead) then
		return
	end

	self.zoomedFromInput = zoomedFromInput
	self:updateZoomState()
end

function ShoulderCamera:updateZoomState()
	local isZoomed = self.forcedZoomed
	if self.canZoom and not self.forcedZoomed then
		isZoomed = self.zoomedFromInput
	end

	if not self.enabled or not self.currentTool then
		isZoomed = false
	end

	self.zoomState = isZoomed

	self.currentMouseRadsPerPixel = isZoomed and self.zoomedMouseRadsPerPixel or self.mouseRadsPerPixel
	self.currentTouchSensitivity = isZoomed and self.zoomedTouchSensitivity or self.touchSensitivity

	if self.weaponsSystem and self.weaponsSystem.gui then
		self.weaponsSystem.gui:setCrosshairScaleTarget(self.zoomState and self.zoomedCrosshairScale or self.normalCrosshairScale)
		self.weaponsSystem.gui:setCrosshairEnabled(not self.zoomState or not self.hasScope)
		self.weaponsSystem.gui:setScopeEnabled(self.zoomState and self.hasScope)
		if self.currentTool then
			self.currentTool.ManualActivationOnly = self.zoomState and self.hasScope and UserInputService.TouchEnabled
		end
	end

	if self.currentCamera then
		self.desiredFieldOfView = self:getCurrentFieldOfView()
	end
end

function ShoulderCamera:onZoomAction(actionName, inputState, inputObj)
	if not self.enabled or not self.canZoom or not self.currentCamera or not self.currentCharacter or not self.weaponsSystem.currentWeapon then
		self:setZoomedFromInput(false)
		return Enum.ContextActionResult.Pass
	end

	self:setZoomedFromInput(inputState == Enum.UserInputState.Begin)
	return Enum.ContextActionResult.Sink
end


-- Recoil related functions

function ShoulderCamera:setCurrentRecoilIntensity(x, y)
	self.currentRecoil = Vector2.new(x, y)
end

function ShoulderCamera:addRecoil(recoilAmount)
	self.currentRecoil = self.currentRecoil + recoilAmount
end


-- Input related functions

function ShoulderCamera:applyInput(yaw, pitch)
	local yInvertValue = UserGameSettings:GetCameraYInvertValue()
	self.yaw = self.yaw + yaw
	self.pitch = math.clamp(self.pitch + pitch * yInvertValue, self.minPitch, self.maxPitch)
end

function ShoulderCamera:processGamepadInput(dt)
	local gamepadPan = self.gamepadPan
	if gamepadPan then
		gamepadPan = gamepadLinearToCurve(gamepadPan)
		if gamepadPan.X == 0 and gamepadPan.Y == 0 then
			self.lastThumbstickTime = nil
			if self.lastThumbstickPos.X == 0 and self.lastThumbstickPos.Y == 0 then
				self.currentGamepadSpeed = 0
			end
		end

		local finalConstant = 0
		local currentTime = tick()

		if self.lastThumbstickTime then
			local elapsed = (currentTime - self.lastThumbstickTime) * 10
			self.currentGamepadSpeed = self.currentGamepadSpeed + (6 * ((elapsed ^ 2) / 0.7))

			if self.currentGamepadSpeed > 6 then self.currentGamepadSpeed = 6 end

			if self.lastGamepadVelocity then
				local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
				local velocityDeltaMag = (velocity - self.lastGamepadVelocity).Magnitude

				if velocityDeltaMag > 12 then
					self.currentGamepadSpeed = self.currentGamepadSpeed * (20 / velocityDeltaMag)
					if self.currentGamepadSpeed > 6 then
						self.currentGamepadSpeed = 6
					end
				end
			end

			finalConstant = GameSettings.GamepadCameraSensitivity * self.currentGamepadSpeed * dt
			self.lastGamepadVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickTime = currentTime

		local yawInput = -gamepadPan.X * finalConstant * self.gamepadSensitivityModifier.X
		local pitchInput = finalConstant * gamepadPan.Y * GameSettings:GetCameraYInvertValue() * self.gamepadSensitivityModifier.Y

		self:applyInput(yawInput, pitchInput)
	end
end

function ShoulderCamera:handleTouchToolFiring()
	if self.touchObj then
		if self.lastTapEndTime then -- and not (self.zoomState and self.hasScope) then
			local touchTime = tick() - self.lastTapEndTime
			if touchTime < self.touchDelayTime and self.currentTool and self.touchPanAccumulator.Magnitude < 0.5 and not self.firingTool and not self.applyingTouchPan then
				self.firingTool = true
				self.currentTool:Activate()
			end
		end
	else
		if self.currentTool and self.firingTool then
			self.currentTool:Deactivate()
		end
		self.firingTool = false
	end
end

function ShoulderCamera:isTouchPositionForCamera(pos)
	if LocalPlayer then
		local guiObjects = LocalPlayer.PlayerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)
		for _, guiObject in ipairs(guiObjects) do
			if guiObject.Name == "DynamicThumbstickFrame" then
				return false
			end
		end
		return true
	end
	return false
end

function ShoulderCamera:onInputBegan(inputObj, wasProcessed)
	if self.touchObj then
		self.touchObj = nil
		wasProcessed = false
	end

	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		local touchStartPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
		if not wasProcessed and self:isTouchPositionForCamera(touchStartPos) and not self.touchObj then
			self.touchObj = inputObj
			self.touchStartTime = tick()
			self.eventConnections.touchChanged = inputObj.Changed:Connect(function(prop)
				if prop == "Position" then
					local touchTime = tick() - self.touchStartTime

					local newTouchPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
					local delta = (newTouchPos - touchStartPos) * self.currentTouchSensitivity
					local yawInput = -delta.X
					local pitchInput = -delta.Y
					if self.touchPanAccumulator.Magnitude > 0.01 and touchTime > self.touchDelayTime then
						if not self.applyingTouchPan then
							self.applyingTouchPan = true
							self.touchPanAccumulator = Vector2.new(0, 0)
						end
					end
					self:applyInput(yawInput, pitchInput)
					self.touchPanAccumulator = self.touchPanAccumulator + Vector2.new(yawInput, pitchInput)
					touchStartPos = newTouchPos
				end
			end)
		end
	end
end

function ShoulderCamera:onInputChanged(inputObj, wasProcessed)
	if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
		local yawInput = -inputObj.Delta.X * self.currentMouseRadsPerPixel.X
		local pitchInput = -inputObj.Delta.Y * self.currentMouseRadsPerPixel.Y

		self:applyInput(yawInput, pitchInput)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	end
end

function ShoulderCamera:onInputEnded(inputObj, wasProcessed)
	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(0, 0)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(0, 0)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		if self.touchObj == inputObj then
			if self.eventConnections and self.eventConnections.touchChanged then
				self.eventConnections.touchChanged:Disconnect()
				self.eventConnections.touchChanged = nil
			end

			local touchTime = tick() - self.touchStartTime
			if self.currentTool and self.firingTool then
				self.currentTool:Deactivate()
			elseif self.zoomState and self.hasScope and touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.currentTool:Activate() -- this makes sure to shoot the sniper with a single tap when it is zoomed in
				self.currentTool:Deactivate()
			end
			self.firingTool = false

			self.touchPanAccumulator = Vector2.new(0, 0)
			if touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.lastTapEndTime = tick()
			else
				self.lastTapEndTime = nil
			end
			self.applyingTouchPan = false

			self.gamepadPan = Vector2.new(0, 0)
			self.touchObj = nil
		end
	end
end

return ShoulderCamera

end))
ModuleScript154.Name = "SpringService"
ModuleScript154.Parent = Folder147
table.insert(cors,sandbox(ModuleScript154,function()
-- SpringService.lua
-- Binds properties to spring simulations
-- @author Parker Stebbins <pstebbins@roblox.com>

local RunService = game:GetService('RunService')

local LinearSpring = {} do
	LinearSpring.__index = LinearSpring

	local pi = math.pi
	local exp = math.exp
	local sin = math.sin
	local cos = math.cos
	local sqrt = math.sqrt

	function LinearSpring.new(dampingRatio, frequency, goal)
		assert(
			dampingRatio*frequency >= 0,
			'No steady state solution for the given damping ratio & frequency'
		)

		return setmetatable(
			{
				d = dampingRatio, -- Damping ratio - Dimensionless
				f = frequency, -- Undamped frequency - Hertz
				g = goal, -- Goal position - Vector
				v = goal*0, -- Current velocity - Vector
			},
			LinearSpring
		)
	end

	function LinearSpring:setGoal(goal)
		self.g = goal
	end

	function LinearSpring:canSleep()
		return false -- @todo add sleeping
	end

	function LinearSpring:step(dt, p0)

		-- Problem: Advance the spring simulation by t seconds.
		-- Start by taking the ODE of a damped harmonic oscillator:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is desired position, f is angular frequency, and d is damping ratio.
		-- Apply some constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- The IVP can now be solved to obtain analytic expressions for X[t] and X'[t].
		-- The solution takes on one of three forms depending on the value of d.

		local d = self.d
		local f = self.f*pi*2 -- cycle/s -> rad/s
		local g = self.g
		local v0 = self.v

		local o = p0 - g
		local decay = exp(-dt*d*f)

		local p1, v1

		if d == 1 then -- Critically damped

			p1 = (v0*dt + o*(f*dt + 1))*decay + g
			v1 = (v0 - (o*f + v0)*(f*dt))*decay

		elseif d < 1 then -- Underdamped

			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- @todo improve stability as d approaches 1

			p1 = (o*i + (v0 + o*(d*f))*j/(f*c))*decay + g
			v1 = (v0*(i*c) - (v0*d + o*f)*j)*(decay/c)

		else -- Overdamped

			local c = sqrt(d*d - 1)

			local r1 = -f*(d - c)
			local r2 = -f*(d + c)

			-- @todo improve stability as d approaches 1

			local co2 = (v0 - o*r1)/(2*f*c)
			local co1 = o - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			p1 = e1 + e2 + g
			v1 = r1*e1 + r2*e2
		end

		self.v = v1

		return p1
	end
end

local LinearValue = {} do
	LinearValue.__index = LinearValue

	function LinearValue.new(...)
		return setmetatable(
			{
				...
			},
			LinearValue
		)
	end

	function LinearValue:__add(rhs)
		-- vector + vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] + rhs[i]
		end

		return out
	end

	function LinearValue:__sub(rhs)
		-- vector - vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] - rhs[i]
		end

		return out
	end

	function LinearValue:__mul(rhs)
		-- vector*scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]*rhs
		end

		return out
	end

	function LinearValue:__div(rhs)
		-- vector/scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]/rhs
		end

		return out
	end
end

local springMetadata = {
	-- Defines a spring type with functions for converting to/from values that the spring can digest
	number = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value)
		end,
		fromIntermediate = function(value)
			return value[1]
		end,
	},

	UDim = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.Scale, value.Offset)
		end,
		fromIntermediate = function(value)
			return UDim.new(value[1], value[2])
		end,
	},

	UDim2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return LinearValue.new(x.Scale, x.Offset, y.Scale, y.Offset)
		end,
		fromIntermediate = function(value)
			return UDim2.new(value[1], value[2], value[3], value[4])
		end,
	},

	Vector2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y)
		end,
		fromIntermediate = function(value)
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y, value.Z)
		end,
		fromIntermediate = function(value)
			return Vector3.new(value[1], value[2], value[3])
		end,
	},
}

local springStates = {} -- {[object] = {[property] = Spring}

local steppedEvent = RunService:IsClient() and RunService.RenderStepped or RunService.Heartbeat
steppedEvent:Connect(function(dt)
	for object, state in pairs(springStates) do
		for name, spring in pairs(state) do
			local oldValue = object[name]
			local meta = assert(springMetadata[typeof(oldValue)])

			local oldIntermediate = meta.toIntermediate(oldValue)
			local newIntermediate = spring:step(dt, oldIntermediate)

			if spring:canSleep() then
				state[name] = nil
			end

			object[name] = meta.fromIntermediate(newIntermediate)
		end

		if not next(state) then
			springStates[object] = nil
		end
	end
end)

local SpringService = {} do
	function SpringService:Target(object, dampingRatio, frequency, properties)
		local state = springStates[object]

		if not state then
			state = {}
			springStates[object] = state
		end

		for name, goal in pairs(properties) do
			local spring = state[name]

			local meta = assert(
				springMetadata[typeof(goal)],
				'Unsupported type: ' .. typeof(goal)
			)
			local intermediateGoal = meta.toIntermediate(goal)

			if spring then
				spring:setGoal(intermediateGoal)
			else
				spring = meta.springType.new(dampingRatio, frequency, intermediateGoal)
				state[name] = spring
			end
		end
	end

	function SpringService:Stop(object, property)
		if property then
			-- Unbind a property
			local state = springStates[object]
			if state then
				state[property] = nil
			end
		else
			-- Unbind all the properties
			springStates[object] = nil
		end
	end
end

return SpringService

end))
ModuleScript155.Name = "WeaponsGui"
ModuleScript155.Parent = Folder147
table.insert(cors,sandbox(ModuleScript155,function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer

local WeaponsSystemFolder = script.Parent.Parent
local WeaponData = WeaponsSystemFolder:WaitForChild("WeaponData")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local SpringService = require(Libraries:WaitForChild("SpringService"))

local DirectionalIndicatorGuiManager = require(Libraries:WaitForChild("DirectionalIndicatorGuiManager"))
local DamageBillboardHandler = require(Libraries:WaitForChild("DamageBillboardHandler"))

local WeaponsSystemGuiTemplate = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("WeaponsSystemGui")

local AIM_ON_NORMAL = "rbxassetid://2804583948"
local AIM_OFF_NORMAL = "rbxassetid://2804597178"
local AIM_ON_PRESSED = "rbxassetid://2804598866"
local AIM_OFF_PRESSED = "rbxassetid://2804599869"

local FIRE_NORMAL = "rbxassetid://2804818047"
local FIRE_PRESSED = "rbxassetid://2804818076"

local WeaponsGui = {}
WeaponsGui.__index = WeaponsGui

function WeaponsGui.new(weaponsSystem)
	local self = setmetatable({}, WeaponsGui)
	self.weaponsSystem = weaponsSystem
	self.connections = {}
	self.enabled = false

	self.referenceViewportSize = Vector2.new(1000, 1000) -- viewport size that ui elements in scalingElementsFolder were designed on
	self.scaleWeight = 0.75 -- determines weight of scaling (a higher value increases the degree to which elements are scaled)
	self.originalScaleAmounts = {}

	self.crosshairDampingRatio = 0.9
	self.crosshairFrequency = 3
	self.crosshairScaleTarget = 1
	self.crosshairScale = 1
	self.crosshairWeaponScale = 1
	self.crosshairEnabled = true

	self.scopeEnabled = false
	self.isZoomed = false

	self.gui = WeaponsSystemGuiTemplate:Clone()
	self.gui.Enabled = false

	coroutine.wrap(function()
		self.scalingElementsFolder = self.gui:WaitForChild("ScalingElements")

		self.DirectionalIndicatorGuiManager = DirectionalIndicatorGuiManager.new(self)

		self.crosshairFrame = self.scalingElementsFolder:WaitForChild("Crosshair")
		self.crosshairBottom = self.crosshairFrame:WaitForChild("Bottom")
		self.crosshairLeft = self.crosshairFrame:WaitForChild("Left")
		self.crosshairRight = self.crosshairFrame:WaitForChild("Right")
		self.crosshairTop = self.crosshairFrame:WaitForChild("Top")
		self.origCrosshairScales = {} -- these will be used to size crosshair pieces when screen size changes
		self.origCrosshairScales[self.crosshairBottom] = Vector2.new(self.crosshairBottom.Size.X.Scale, self.crosshairBottom.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairLeft] = Vector2.new(self.crosshairLeft.Size.X.Scale, self.crosshairLeft.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairRight] = Vector2.new(self.crosshairRight.Size.X.Scale, self.crosshairRight.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairTop] = Vector2.new(self.crosshairTop.Size.X.Scale, self.crosshairTop.Size.Y.Scale)
		self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

		self.hitMarker = self.scalingElementsFolder:WaitForChild("HitMarker"):WaitForChild("HitMarkerImage")

		self.scopeFrame = self.gui:WaitForChild("Scope")
		local scopeImage = self.scopeFrame:WaitForChild("ScopeImage")

		self.smallTouchscreen = self.gui:WaitForChild("SmallTouchscreen")
		self.largeTouchscreen = self.gui:WaitForChild("LargeTouchscreen")

		self.smallAimButton = self.smallTouchscreen:WaitForChild("AimButton")
		self.smallAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.largeAimButton = self.largeTouchscreen:WaitForChild("AimButton")
		self.largeAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.smallFireButton = self.smallTouchscreen:WaitForChild("FireButton")
		self.smallFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.smallFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)
		self.largeFireButton = self.largeTouchscreen:WaitForChild("FireButton")
		self.largeFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.largeFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)

		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		self.gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
		self.gui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() self:onScreenSizeChanged() end)
		self:onScreenSizeChanged()

		WeaponData.OnClientEvent:Connect(function(cmd, otherPlayerPosition)
			if cmd == "HitByOtherPlayer" then
				self.DirectionalIndicatorGuiManager:ActivateDirectionalIndicator("DamageIndicator", otherPlayerPosition)
			end
		end)

		ContentProvider:PreloadAsync({
			self.crosshairBottom,
			self.crosshairLeft,
			self.crosshairRight,
			self.crosshairTop,
			scopeImage,
			self.smallAimButton,
			self.largeAimButton,
			self.smallFireButton,
			self.largeFireButton,
		})
	end)()

	return self
end

local function getJumpButton()
	if UserInputService.TouchEnabled then
		local touchGui = LocalPlayer.PlayerGui:WaitForChild("TouchGui")
		return touchGui.TouchControlFrame:FindFirstChild("JumpButton")
	end

	return nil
end

function WeaponsGui:onScreenSizeChanged()
	if self.smallTouchscreen and self.largeTouchscreen then
		if UserInputService.TouchEnabled then
			local isSmallScreen
			local jumpButton = getJumpButton()
			if jumpButton then
				isSmallScreen = jumpButton.Size.X.Offset <= 70
			else
				isSmallScreen = self.gui.AbsoluteSize.Y < 600
			end
			self.smallTouchscreen.Visible = isSmallScreen
			self.largeTouchscreen.Visible = not isSmallScreen
		else
			self.smallTouchscreen.Visible = false
			self.largeTouchscreen.Visible = false
		end
	end

	-- Scales all ui elements in scalingElementsFolder based on current screen size relative to self.referenceViewportSize
	local viewportSize = workspace.CurrentCamera.ViewportSize
	for _, child in pairs(self.scalingElementsFolder:GetChildren()) do
		self:updateScale(child, viewportSize)
	end

	self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

	-- Update crosshair sizes...they must use offset because crosshairFrame changes size frequently
	self.crosshairBottom.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairBottom].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairBottom].Y * self.crosshairNormalSize.Y)
	self.crosshairLeft.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairLeft].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairLeft].Y * self.crosshairNormalSize.Y)
	self.crosshairRight.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairRight].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairRight].Y * self.crosshairNormalSize.Y)
	self.crosshairTop.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairTop].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairTop].Y * self.crosshairNormalSize.Y)
end

-- This scales the scale amount non-linearly according to scaleWeight
function WeaponsGui:getWeightedScaleAmount(originalScaleAmount, newScreenDim, referenceScreenDim)
	return (1 - self.scaleWeight) * originalScaleAmount * referenceScreenDim / newScreenDim + self.scaleWeight * originalScaleAmount
end

function WeaponsGui:updateScale(guiObject, viewportSize)
	if guiObject:IsA("GuiObject") then
		local xScale = guiObject.Size.X.Scale
		local yScale = guiObject.Size.Y.Scale
		if xScale ~= 0 or yScale ~= 0 or self.originalScaleAmounts[guiObject] ~= nil then
			if self.originalScaleAmounts[guiObject] == nil then
				self.originalScaleAmounts[guiObject] = Vector2.new(xScale, yScale)
			end

			xScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].X, viewportSize.X, self.referenceViewportSize.X)
			yScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].Y, viewportSize.Y, self.referenceViewportSize.Y)
			guiObject.Size = UDim2.new(xScale, 0, yScale, 0)
		end
		return -- makes it so only the most outer container will be scaled
	end

	for _, child in ipairs(guiObject:GetChildren()) do
		self:updateScale(child, viewportSize)
	end
end

function WeaponsGui:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end

	self.enabled = enabled
	if self.enabled then
		self.connections.renderStepped = RunService.RenderStepped:Connect(function(dt) self:onRenderStepped(dt) end)
	else
		self:setZoomed(false)

		for _, v in pairs(self.connections) do
			v:Disconnect()
		end
		self.connections = {}
	end

	if self.gui then
		self.gui.Enabled = self.enabled
	end
end

function WeaponsGui:setCrosshairEnabled(crosshairEnabled)
	if self.crosshairEnabled == crosshairEnabled then
		return
	end

	self.crosshairEnabled = crosshairEnabled
	if self.crosshairFrame then
		self.crosshairFrame.Visible = self.crosshairEnabled
	end
	if self.hitMarker then
		self.hitMarker.ImageTransparency = 1
		self.hitMarker.Visible = self.crosshairEnabled
	end
end

function WeaponsGui:setScopeEnabled(scopeEnabled)
	if self.scopeEnabled == scopeEnabled then
		return
	end

	self.scopeEnabled = scopeEnabled
	if self.scopeFrame then
		self.scopeFrame.Visible = self.scopeEnabled
	end

	local jumpButton = getJumpButton()

	if self.scopeEnabled then
		self.smallFireButton.Visible = true
		self.largeFireButton.Visible = true

		if jumpButton then
			jumpButton.Visible = false
		end
	else
		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		if jumpButton then
			jumpButton.Visible = true
		end
	end
end

function WeaponsGui:setCrosshairWeaponScale(scale)
	if self.crosshairWeaponScale == scale then
		return
	end

	self.crosshairWeaponScale = scale
end

function WeaponsGui:setCrosshairScaleTarget(target, dampingRatio, frequency)
	if typeof(dampingRatio) == "number" then
		self.crosshairDampingRatio = dampingRatio
	end
	if typeof(frequency) == "number" then
		self.crosshairFrequency = frequency
	end
	if self.crosshairScaleTarget == target then
		return
	end

	self.crosshairScaleTarget = target
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:setCrosshairScale(scale)
	if self.crosshairScale == scale then
		return
	end

	self.crosshairScale = scale
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:OnHitOtherPlayer(damage, humanoidHit) -- show hit indicator, then fade
	self.hitMarker.ImageTransparency = 0
	local tweenInfo = TweenInfo.new(0.8)
	local goal = {}
	goal.ImageTransparency = 1
	local tween = TweenService:Create(self.hitMarker, tweenInfo, goal)
	tween:Play()

	DamageBillboardHandler:ShowDamageBillboard(damage, humanoidHit.Parent:FindFirstChild("Head"))
end

function WeaponsGui:onRenderStepped(dt)
	if not self.enabled then
		return
	end
	if not self.gui then
		return
	end

	if self.crosshairFrame and self.crosshairEnabled then
		local crosshairSize = self.crosshairNormalSize * self.crosshairScale * self.crosshairWeaponScale
		self.crosshairFrame.Size = UDim2.new(0, crosshairSize.X, 0, crosshairSize.Y)
	end
end

function WeaponsGui:setZoomed(zoomed)
	if zoomed == self.isZoomed then
		return
	end

	self.isZoomed = zoomed
	local normalImage = self.isZoomed and AIM_OFF_NORMAL or AIM_ON_NORMAL
	local pressedImage = self.isZoomed and AIM_OFF_PRESSED or AIM_ON_PRESSED

	if self.smallAimButton then
		self.smallAimButton.Image = normalImage
		self.smallAimButton.PressedImage = pressedImage
	end
	if self.largeAimButton then
		self.largeAimButton.Image = normalImage
		self.largeAimButton.PressedImage = pressedImage
	end

	if self.weaponsSystem.camera then
		self.weaponsSystem.camera:setForceZoomed(self.isZoomed)
	end
end

function WeaponsGui:onTouchAimButtonActivated()
	self:setZoomed(not self.isZoomed)
end

function WeaponsGui:onTouchFireButton(inputObj, inputState)
	local currentWeapon = self.weaponsSystem.currentWeapon
	if currentWeapon and currentWeapon.instance and currentWeapon.instance:IsA("Tool") then
		if inputObj.UserInputState == Enum.UserInputState.Begin then
			currentWeapon.instance:Activate()
			if self.smallFireButton then
				self.smallFireButton.Image = FIRE_PRESSED
			end
			if self.largeFireButton then
				self.largeFireButton.Image = FIRE_PRESSED
			end

			inputObj:GetPropertyChangedSignal("UserInputState"):Connect(function()
				if inputObj.UserInputState == Enum.UserInputState.End then
					currentWeapon.instance:Deactivate()
					if self.smallFireButton then
						self.smallFireButton.Image = FIRE_NORMAL
					end
					if self.largeFireButton then
						self.largeFireButton.Image = FIRE_NORMAL
					end
				end
			end)
		end
	end
end

return WeaponsGui
end))
ModuleScript156.Name = "ancestorHasTag"
ModuleScript156.Parent = Folder147
table.insert(cors,sandbox(ModuleScript156,function()
local CollectionService = game:GetService("CollectionService")

local function ancestorHasTag(instance, tag)
	local currentInstance = instance
	while currentInstance do
		if CollectionService:HasTag(currentInstance, tag) then
			return true
		else
			currentInstance = currentInstance.Parent
		end
	end

	return false
end

return ancestorHasTag
end))
ModuleScript157.Name = "BaseWeapon"
ModuleScript157.Parent = Folder147
table.insert(cors,sandbox(ModuleScript157,function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local AnimationsFolder = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Animations")

local localRandom = Random.new()

local BaseWeapon = {}
BaseWeapon.__index = BaseWeapon

BaseWeapon.CanAimDownSights = false
BaseWeapon.CanBeReloaded = false
BaseWeapon.CanBeFired = false
BaseWeapon.CanHit = false

function BaseWeapon.new(weaponsSystem, instance)
	assert(instance, "BaseWeapon.new() requires a valid Instance to be attached to.")

	local self = setmetatable({}, BaseWeapon)
	self.connections = {}
	self.descendants = {}
	self.descendantsRegistered = false
	self.optionalDescendantNames = {}
	self.weaponsSystem = weaponsSystem
	self.instance = instance
	self.animController = nil
	self.player = nil
	self.enabled = false
	self.equipped = false
	self.activated = false
	self.nextShotId = 1
	self.activeRenderStepName = nil
	self.curReloadSound = nil

	self.animTracks = {}
	self.sounds = {}
	self.configValues = {}
	self.trackedConfigurations = {}

	self.ammoInWeaponValue = nil

	self.reloading = false
	self.canReload = true

	self:registerDescendants()
	self.connections.descendantAdded = self.instance.DescendantAdded:Connect(function(descendant)
		self:onDescendantAdded(descendant)
	end)

	return self
end

function BaseWeapon:doInitialSetup()
	local selfClass = getmetatable(self)
	self.instanceIsTool = self.instance:IsA("Tool")

	-- Set up child added/removed
	self.connections.childAdded = self.instance.ChildAdded:Connect(function(child)
		self:onChildAdded(child)
	end)
	self.connections.childRemoved = self.instance.ChildRemoved:Connect(function(child)
		self:onChildRemoved(child)
	end)
	for _, child in pairs(self.instance:GetChildren()) do
		self:onChildAdded(child)
	end

	-- Initialize self.ammoInWeaponValue
	if selfClass.CanBeReloaded then
		if IsServer then
			self.ammoInWeaponValue = self.instance:FindFirstChild("CurrentAmmo")
			if not self.ammoInWeaponValue then
				self.ammoInWeaponValue = Instance.new("IntValue")
				self.ammoInWeaponValue.Name = "CurrentAmmo"
				self.ammoInWeaponValue.Value = 0
				self.ammoInWeaponValue.Parent = self.instance
			end
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		else
			self.ammoInWeaponValue = self.instance:WaitForChild("CurrentAmmo")
		end
	end

	self.connections.ancestryChanged = self.instance.AncestryChanged:Connect(function() self:onAncestryChanged() end)
	self:onAncestryChanged()

	-- Set up equipped/unequipped and activated/deactivated
	if self.instanceIsTool then
		self.connections.equipped = self.instance.Equipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(true)
				if self:getAmmoInWeapon() <= 0 then
					-- Have to wait a frame, otherwise the reload animation will not play
					coroutine.wrap(function()
						wait()
						self:reload()
					end)()
				end
			end
		end)
		self.connections.unequipped = self.instance.Unequipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(false)
				if self.reloading then
					self:cancelReload()
				end
			end
		end)
		if self.instance:IsDescendantOf(workspace) and self.player then
			self:setEquipped(true)
		end

		self.connections.activated = self.instance.Activated:Connect(function()
			self:setActivated(true)
		end)
		self.connections.deactivated = self.instance.Deactivated:Connect(function()
			self:setActivated(false)
		end)

		-- Weld handle to weapon primary part
		if IsServer then
			self.handle = self.instance:FindFirstChild("Handle")

			local model = self.instance:FindFirstChildOfClass("Model")
			local handleAttachment = model:FindFirstChild("HandleAttachment", true)

			if self.handle and handleAttachment then
				local handleOffset = model.PrimaryPart.CFrame:toObjectSpace(handleAttachment.WorldCFrame)

				local weld = Instance.new("Weld")
				weld.Name = "HandleWeld"
				weld.Part0 = self.handle
				weld.Part1 = model.PrimaryPart
				weld.C0 = CFrame.new()
				weld.C1 = handleOffset
				weld.Parent = self.handle

				self.handle.Anchored = false
				model.PrimaryPart.Anchored = false
			end
		end
	end
end

function BaseWeapon:registerDescendants()
	if not self.instance then
		error("No instance set yet!")
	end

	if self.descendantsRegistered then
		warn("Descendants already registered!")
		return
	end

	for _, descendant in ipairs(self.instance:GetDescendants()) do
		if self.descendants[descendant.Name] == nil then
			self.descendants[descendant.Name] = descendant
		else
			self.descendants[descendant.Name] = "Multiple"
		end
	end
	self.descendantsRegistered = true
end

function BaseWeapon:addOptionalDescendant(key, descendantName)
	if self.instance == nil then
		error("No instance set yet!")
	end

	if not self.descendantsRegistered then
		error("Descendants not registered!")
	end

	if self.descendants[descendantName] == "Multiple" then
		error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendantName.."\", so you cannot addOptionalDescendant with that descendant name.")
	end

	local found = self.descendants[descendantName]
	if found then
		self[key] = found
		return
	else
		self.optionalDescendantNames[descendantName] = key
	end
end

function BaseWeapon:onDescendantAdded(descendant)
	if self.descendants[descendant.Name] == nil then
		self.descendants[descendant.Name] = descendant
	else
		self.descendants[descendant.Name] = "Multiple"
	end

	local desiredKey = self.optionalDescendantNames[descendant.Name]
	if desiredKey then
		if self.descendants[descendant.Name] == "Multiple" then
			error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendant.Name.."\", so you cannot addOptionalDependency with that descendant name.")
		end
		self[desiredKey] = descendant
		self.optionalDescendantNames[descendant.Name] = nil
	end
end

function BaseWeapon:cleanupConnection(...)
	local args = { ... }
	for _, name in pairs(args) do
		if typeof(name) == "string" and self.connections[name] then
			self.connections[name]:Disconnect()
			self.connections[name] = nil
		end
	end
end

function BaseWeapon:onAncestryChanged()
	if self.instanceIsTool then
		local player = nil
		if self.instance:IsDescendantOf(Players) then
			local parentPlayer = self.instance.Parent.Parent
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		elseif self.instance:IsDescendantOf(workspace) then
			local parentPlayer = Players:GetPlayerFromCharacter(self.instance.Parent)
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		end

		self:setPlayer(player)
	end
end

function BaseWeapon:setPlayer(player)
	if self.player == player then
		return
	end

	self.player = player
end

function BaseWeapon:setEquipped(equipped)
	if self.equipped == equipped then
		return
	end

	self.equipped = equipped
	self:onEquippedChanged()

	if not self.equipped then
		self:stopAnimations()
	end
end

function BaseWeapon:onEquippedChanged()
	if self.activeRenderStepName then
		RunService:UnbindFromRenderStep(self.activeRenderStepName)
		self.activeRenderStepName = nil
	end
	self:cleanupConnection("localStepped")

	if not IsServer and self.weaponsSystem then
		self.weaponsSystem.setWeaponEquipped(self, self.equipped)
		if self.equipped then
			if self.player == Players.LocalPlayer then
				RunService:BindToRenderStep(self.instance:GetFullName(), Enum.RenderPriority.Input.Value, function(dt)
					self:onRenderStepped(dt)
				end)
				self.activeRenderStepName = self.instance:GetFullName()
			end
			self.connections.localStepped = RunService.Heartbeat:Connect(function(dt)
				self:onStepped(dt)
			end)
		end
	end

	if self.instanceIsTool then
		for _, part in pairs(self.instance:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = part ~= self.handle and not self.equipped
			end
		end
	end

	self:setActivated(false)
end

function BaseWeapon:setActivated(activated, fromNetwork)
	if not IsServer and fromNetwork and self.player == Players.LocalPlayer then
		return
	end

	if self.activated == activated then
		return
	end

	self.activated = activated
	if IsServer and not fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponActivated"):FireAllClients(self.player, self.instance, self.activated)
	end

	self:onActivatedChanged()
end

function BaseWeapon:onActivatedChanged()

end

function BaseWeapon:renderFire(fireInfo)

end

function BaseWeapon:simulateFire(fireInfo)

end

function BaseWeapon:isOwnerAlive()
	if self.instance:IsA("Tool") then
		local humanoid = self.instance.Parent:FindFirstChildOfClass("Humanoid")
		if humanoid then
			return humanoid:GetState() ~= Enum.HumanoidStateType.Dead
		end
	end

	return true
end

function BaseWeapon:fire(origin, dir, charge)
	if not self:isOwnerAlive() or self.reloading then
		return
	end

	if self:useAmmo(1) <= 0 then
		self:reload()
		return
	end

	local fireInfo = {}
	fireInfo.origin = origin
	fireInfo.dir = dir
	fireInfo.charge = math.clamp(charge or 1, 0, 1)
	fireInfo.id = self.nextShotId
	self.nextShotId = self.nextShotId + 1

	if not IsServer then
		self:onFired(self.player, fireInfo, false)
		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireServer(self.instance, fireInfo)
	else
		self:onFired(self.player, fireInfo, false)
	end
end

function BaseWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer then
		if firingPlayer == Players.LocalPlayer and fromNetwork then
			return
		end

		self:simulateFire(firingPlayer, fireInfo)
	else
		if self:useAmmo(1) <= 0 then
			return
		end

		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireAllClients(firingPlayer, self.instance, fireInfo)
	end
end

function BaseWeapon:getConfigValue(valueName, defaultValue)
	if self.configValues[valueName] ~= nil then
		return self.configValues[valueName]
	else
		return defaultValue
	end
end

function BaseWeapon:tryPlaySound(soundName, playbackSpeedRange)
	playbackSpeedRange = playbackSpeedRange or 0

	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	if not soundTemplate then
		return
	end

	local sound = soundTemplate:Clone()
	sound.PlaybackSpeed = sound.PlaybackSpeed + localRandom:NextNumber(-playbackSpeedRange * 0.5, playbackSpeedRange * 0.5)
	sound.Parent = soundTemplate.Parent
	sound:Play()
	coroutine.wrap(function()
		wait(sound.TimeLength / sound.PlaybackSpeed)
		sound:Destroy()
	end)()

	return sound
end

function BaseWeapon:getSound(soundName)
	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	return soundTemplate
end

function BaseWeapon:onDestroyed()

end

function BaseWeapon:onConfigValueAdded(valueObj)
	local valueName = valueObj.Name
	local newValue = valueObj.Value
	self.configValues[valueName] = newValue
	self:onConfigValueChanged(valueName, newValue, nil)

	self.connections["valueChanged:" .. valueName] = valueObj.Changed:Connect(function(changedValue)
		local oldValue = self.configValues[valueName]
		self.configValues[valueName] = changedValue

		self:onConfigValueChanged(valueName, changedValue, oldValue)
	end)
	self.connections["valueRenamed:" .. valueName] = valueObj:GetPropertyChangedSignal("Name"):Connect(function()
		self.configValues[valueName] = nil
		self:cleanupConnection("valueChanged:" .. valueName)
		self:cleanupConnection("valueRenamed:" .. valueName)
		self:onConfigValueAdded(valueObj)
	end)
end

function BaseWeapon:onConfigValueRemoved(valueObj)
	local valueName = valueObj.Name
	self.configValues[valueName] = nil

	self:cleanupConnection("valueChanged:" .. valueName)
	self:cleanupConnection("valueRenamed:" .. valueName)
end

-- This function is used to set configuration values from outside configuration objects/folders
function BaseWeapon:importConfiguration(config)
	if not config or not config:IsA("Configuration") then
		for _, child in pairs(config:GetChildren()) do
			if child:IsA("ValueBase") then
				local valueName = child.Name
				local newValue = child.Value
				local oldValue = self.configValues[valueName]
				self.configValues[valueName] = newValue
				self:onConfigValueChanged(valueName, newValue, oldValue)
			end
		end
	end
end

function BaseWeapon:setConfiguration(config)
	self:cleanupConnection("configChildAdded", "configChildRemoved")
	if not config or not config:IsA("Configuration") then
		return
	end

	for _, child in pairs(config:GetChildren()) do
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end
	self.connections.configChildAdded = config.ChildAdded:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end)
	self.connections.configChildRemoved = config.ChildRemoved:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueRemoved(child)
		end
	end)
end

function BaseWeapon:onChildAdded(child)
	if child:IsA("Configuration") then
		self:setConfiguration(child)
	end
end

function BaseWeapon:onChildRemoved(child)
	if child:IsA("Configuration") then
		self:setConfiguration(nil)
	end
end

function BaseWeapon:onConfigValueChanged(valueName, newValue, oldValue)

end

function BaseWeapon:onRenderStepped(dt)

end

function BaseWeapon:onStepped(dt)

end

function BaseWeapon:getAnimationController()
	if self.animController then
		if not self.instanceIsTool or (self.animController.Parent and self.animController.Parent:IsAncestorOf(self.instance)) then
			return self.animController
		end
	end

	self:setAnimationController(nil)

	if self.instanceIsTool then
		local humanoid = IsServer and self.instance.Parent:FindFirstChildOfClass("Humanoid") or self.instance.Parent:WaitForChild("Humanoid", math.huge)
		local animController = nil
		if not humanoid then
			animController = self.instance.Parent:FindFirstChildOfClass("AnimationController")
		end

		self:setAnimationController(humanoid or animController)
		return self.animController
	end
end

function BaseWeapon:setAnimationController(animController)
	if animController == self.animController then
		return
	end
	self:stopAnimations()
	self.animController = animController
end

function BaseWeapon:stopAnimations()
	for _, track in pairs(self.animTracks) do
		if track.IsPlaying then
			track:Stop()
		end
	end
	self.animTracks = {}
end

function BaseWeapon:getAnimTrack(key)
	local track = self.animTracks[key]
	if not track then
		local animController = self:getAnimationController()
		if not animController then
			warn("No animation controller when trying to play ", key)
			return nil
		end

		local animation = AnimationsFolder:FindFirstChild(key)
		if not animation then
			error(string.format("No such animation \"%s\" ", tostring(key)))
		end

		track = animController:LoadAnimation(animation)
		self.animTracks[key] = track
	end

	return track
end

function BaseWeapon:reload(player, fromNetwork)
	if
		not self.equipped or
		self.reloading or
		not self.canReload or
		self:getAmmoInWeapon() == self:getConfigValue("AmmoCapacity", 30)
	then
		return false
	end

	if not IsServer then
		if self.player ~= nil and self.player ~= Players.LocalPlayer then
			return
		end
		self.weaponsSystem.getRemoteEvent("WeaponReloadRequest"):FireServer(self.instance)
		self:onReloaded(self.player)
	else
		self:onReloaded(player, fromNetwork)
		self.weaponsSystem.getRemoteEvent("WeaponReloaded"):FireAllClients(player, self.instance)
	end
end

function BaseWeapon:onReloaded(player, fromNetwork)
	if fromNetwork and player == Players.LocalPlayer then -- make sure localplayer doesn't reload twice
		return
	end

	self.reloading = true
	self.canReload = false

	-- Play reload animation and sound
	if not IsServer then
		local reloadTrackKey = self:getConfigValue("ReloadAnimation", "RifleReload")
		if reloadTrackKey then
			self.reloadTrack = self:getAnimTrack(reloadTrackKey)
			if self.reloadTrack then
				self.reloadTrack:Play()
			end
		end

		self.curReloadSound = self:tryPlaySound("Reload", nil)
		if self.curReloadSound then
			self.curReloadSound.Ended:Connect(function()
				self.curReloadSound = nil
			end)
		end
	end

	local reloadTime = self:getConfigValue("ReloadTime", 2)
	local startTime = tick()

	if self.connections.reload ~= nil then -- this prevents an endless ammo bug
		return
	end
	self.connections.reload = RunService.Heartbeat:Connect(function()
		-- Stop trying to reload if the player unequipped this weapon or reloading was canceled some other way
		if not self.reloading then
			if self.connections.reload then
				self.connections.reload:Disconnect()
				self.connections.reload = nil
			end
		end

		-- Wait until gun finishes reloading
		if tick() < startTime + reloadTime then
			return
		end

		-- Add ammo to weapon
		if self.ammoInWeaponValue then
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		end

		if self.connections.reload then
			self.connections.reload:Disconnect()
			self.connections.reload = nil
		end

		self.reloading = false
		self.canReload = false
	end)
end

function BaseWeapon:cancelReload(player, fromNetwork)
	if not self.reloading then
		return
	end
	if fromNetwork and player == Players.LocalPlayer then
		return
	end

	if not IsServer and not fromNetwork and player == Players.LocalPlayer then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireServer(self.instance)
	elseif IsServer and fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireAllClients(player, self.instance)
	end

	self.reloading = false
	self.canReload = true

	if not IsServer and self.reloadTrack and self.reloadTrack.IsPlaying then
		warn("Stopping reloadTrack")
		self.reloadTrack:Stop()
	end
	if self.curReloadSound then
		self.curReloadSound:Stop()
		self.curReloadSound:Destroy()
		self.curReloadSound = nil
	end
end

function BaseWeapon:getAmmoInWeapon()
	if self.ammoInWeaponValue then
		return self.ammoInWeaponValue.Value
	end
	return 0
end

function BaseWeapon:useAmmo(amount)
	if self.ammoInWeaponValue then
		local ammoUsed = math.min(amount, self.ammoInWeaponValue.Value)
		self.ammoInWeaponValue.Value = self.ammoInWeaponValue.Value - ammoUsed
		self.canReload = true
		return ammoUsed
	else
		return 0
	end
end

function BaseWeapon:renderCharge()

end

return BaseWeapon

end))
ModuleScript158.Name = "WeaponsSystem"
ModuleScript158.Parent = Folder29
table.insert(cors,sandbox(ModuleScript158,function()
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

-- Dependencies
local WeaponData = script.Parent:WaitForChild("WeaponData")
local WeaponsSystemFolder = script.Parent
local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local ShoulderCamera = require(Libraries:WaitForChild("ShoulderCamera"))
local WeaponsGui = require(Libraries:WaitForChild("WeaponsGui"))
local SpringService = require(Libraries:WaitForChild("SpringService"))
local ancestorHasTag = require(Libraries:WaitForChild("ancestorHasTag"))
ShoulderCamera.SpringService = SpringService

local Configuration = WeaponsSystemFolder:WaitForChild("Configuration")
local ConfigurationValues = {
	SprintEnabled = Configuration:WaitForChild("SprintEnabled"),
	SlowZoomWalkEnabled = Configuration:WaitForChild("SlowZoomWalkEnabled"),
}

local WEAPON_TAG = "WeaponsSystemWeapon"
local WEAPON_TYPES_LOOKUP = {}

local REMOTE_EVENT_NAMES = {
	"WeaponFired",
	"WeaponHit",
	"WeaponReloadRequest",
	"WeaponReloaded",
	"WeaponReloadCanceled",
	"WeaponActivated"
}
local REMOTE_FUNCTION_NAMES = {}

--Set up WeaponTypes lookup table
do
	local function onNewWeaponType(weaponTypeModule)
		if not weaponTypeModule:IsA("ModuleScript") then
			return
		end
		local weaponTypeName = weaponTypeModule.Name
		xpcall(function()
			coroutine.wrap(function()
				local weaponType = require(weaponTypeModule)
				assert(typeof(weaponType) == "table", string.format("WeaponType \"%s\" did not return a valid table", weaponTypeModule:GetFullName()))
				WEAPON_TYPES_LOOKUP[weaponTypeName] = weaponType
			end)()
		end, function(errMsg)
			warn(string.format("Error while loading %s: %s", weaponTypeModule:GetFullName(), errMsg))
			warn(debug.traceback())
		end)
	end
	for _, child in pairs(WeaponTypes:GetChildren()) do
		onNewWeaponType(child)
	end
	WeaponTypes.ChildAdded:Connect(onNewWeaponType)
end

local WeaponsSystem = {}
WeaponsSystem.didSetup = false
WeaponsSystem.knownWeapons = {}
WeaponsSystem.connections = {}
WeaponsSystem.networkFolder = nil
WeaponsSystem.remoteEvents = {}
WeaponsSystem.remoteFunctions = {}
WeaponsSystem.currentWeapon = nil
WeaponsSystem.aimRayCallback = nil

WeaponsSystem.CurrentWeaponChanged = Instance.new("BindableEvent")

local NetworkingCallbacks = require(WeaponsSystemFolder:WaitForChild("NetworkingCallbacks"))
NetworkingCallbacks.WeaponsSystem = WeaponsSystem

local _damageCallback = nil
local _getTeamCallback = nil

function WeaponsSystem.setDamageCallback(cb)
	_damageCallback = cb
end

function WeaponsSystem.setGetTeamCallback(cb)
	_getTeamCallback = cb
end

function WeaponsSystem.setup()
	if WeaponsSystem.didSetup then
		warn("Warning: trying to run WeaponsSystem setup twice on the same module.")
		return
	end
	print(script.Parent:GetFullName(), "is now active.")

	WeaponsSystem.doingSetup = true

	--Setup network routing
	if IsServer then
		local networkFolder = Instance.new("Folder")
		networkFolder.Name = "Network"

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			local remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = remoteEventName
			remoteEvent.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteEventName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteEvent \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnServerEvent:Connect(function(...)
				callback(...)
			end)
			WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			local remoteFunc = Instance.new("RemoteEvent")
			remoteFunc.Name = remoteFuncName
			remoteFunc.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteFuncName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteFunction \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			remoteFunc.OnServerInvoke = function(...)
				return callback(...)
			end
			WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
		end

		networkFolder.Parent = WeaponsSystemFolder
		WeaponsSystem.networkFolder = networkFolder
	else
		WeaponsSystem.StarterGui = game:GetService("StarterGui")

		WeaponsSystem.camera = ShoulderCamera.new(WeaponsSystem)
		WeaponsSystem.gui = WeaponsGui.new(WeaponsSystem)

		if ConfigurationValues.SprintEnabled.Value then
			WeaponsSystem.camera:setSprintEnabled(ConfigurationValues.SprintEnabled.Value)
		end
		
		if ConfigurationValues.SlowZoomWalkEnabled.Value then
			WeaponsSystem.camera:setSlowZoomWalkEnabled(ConfigurationValues.SlowZoomWalkEnabled.Value)
		end

		local networkFolder = WeaponsSystemFolder:WaitForChild("Network", math.huge)

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			coroutine.wrap(function()
				local remoteEvent = networkFolder:WaitForChild(remoteEventName, math.huge)
				local callback = NetworkingCallbacks[remoteEventName]
				if callback then
					WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnClientEvent:Connect(function(...)
						callback(...)
					end)
				end
				WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
			end)()
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			coroutine.wrap(function()
				local remoteFunc = networkFolder:WaitForChild(remoteFuncName, math.huge)
				local callback = NetworkingCallbacks[remoteFuncName]
				if callback then
					remoteFunc.OnClientInvoke = function(...)
						return callback(...)
					end
				end
				WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
			end)()
		end

		Players.LocalPlayer.CharacterAdded:Connect(WeaponsSystem.onCharacterAdded)
		if Players.LocalPlayer.Character then
			WeaponsSystem.onCharacterAdded(Players.LocalPlayer.Character)
		end

		WeaponsSystem.networkFolder = networkFolder
		WeaponsSystem.camera:setEnabled(true)
	end

	--Setup weapon tools and listening
	WeaponsSystem.connections.weaponAdded = CollectionService:GetInstanceAddedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponAdded)
	WeaponsSystem.connections.weaponRemoved = CollectionService:GetInstanceRemovedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponRemoved)

	for _, instance in pairs(CollectionService:GetTagged(WEAPON_TAG)) do
		WeaponsSystem.onWeaponAdded(instance)
	end

	WeaponsSystem.doingSetup = false
	WeaponsSystem.didSetup = true
end

function WeaponsSystem.onCharacterAdded(character)
	-- Make it so players unequip weapons while seated, then reequip weapons when they become unseated
	local humanoid = character:WaitForChild("Humanoid")
	WeaponsSystem.connections.seated = humanoid.Seated:Connect(function(isSeated)
		if isSeated then
			WeaponsSystem.seatedWeapon = character:FindFirstChildOfClass("Tool")
			humanoid:UnequipTools()
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		else
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			humanoid:EquipTool(WeaponsSystem.seatedWeapon)
		end
	end)
end

function WeaponsSystem.shutdown()
	if not WeaponsSystem.didSetup then
		return
	end

	for _, weapon in pairs(WeaponsSystem.knownWeapons) do
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons = {}

	if IsServer and WeaponsSystem.networkFolder then
		WeaponsSystem.networkFolder:Destroy()
	end
	WeaponsSystem.networkFolder = nil
	WeaponsSystem.remoteEvents = {}
	WeaponsSystem.remoteFunctions = {}

	for _, connection in pairs(WeaponsSystem.connections) do
		if typeof(connection) == "RBXScriptConnection" then
			connection:Disconnect()
		end
	end
	WeaponsSystem.connections = {}
end

function WeaponsSystem.getWeaponTypeFromTags(instance)
	for _, tag in pairs(CollectionService:GetTags(instance)) do
		local weaponTypeFound = WEAPON_TYPES_LOOKUP[tag]
		if weaponTypeFound then
			return weaponTypeFound
		end
	end

	return nil
end

function WeaponsSystem.createWeaponForInstance(weaponInstance)
	coroutine.wrap(function()
		local weaponType = WeaponsSystem.getWeaponTypeFromTags(weaponInstance)
		if not weaponType then
			local weaponTypeObj = weaponInstance:WaitForChild("WeaponType")

			if weaponTypeObj and weaponTypeObj:IsA("StringValue") then
				local weaponTypeName = weaponTypeObj.Value
				local weaponTypeFound = WEAPON_TYPES_LOOKUP[weaponTypeName]
				if not weaponTypeFound then
					warn(string.format("Cannot find the weapon type \"%s\" for the instance %s!", weaponTypeName, weaponInstance:GetFullName()))
					return
				end

				weaponType = weaponTypeFound
			else
				warn("Could not find a WeaponType tag or StringValue for the instance ", weaponInstance:GetFullName())
				return
			end
		end

		-- Since we might have yielded while trying to get the WeaponType, we need to make sure not to continue
		-- making a new weapon if something else beat this iteration.
		if WeaponsSystem.getWeaponForInstance(weaponInstance) then
			warn("Already got ", weaponInstance:GetFullName())
			warn(debug.traceback())
			return
		end

		-- We should be pretty sure we got a valid weaponType by now
		assert(weaponType, "Got invalid weaponType")

		local weapon = weaponType.new(WeaponsSystem, weaponInstance)
		WeaponsSystem.knownWeapons[weaponInstance] = weapon
	end)()
end

function WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not typeof(weaponInstance) == "Instance" then
		warn("WeaponsSystem.getWeaponForInstance(weaponInstance): 'weaponInstance' was not an instance.")
		return nil
	end

	return WeaponsSystem.knownWeapons[weaponInstance]
end

-- and (IsServer or weaponInstance:IsDescendantOf(Players.LocalPlayer))

function WeaponsSystem.onWeaponAdded(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not weapon then
		WeaponsSystem.createWeaponForInstance(weaponInstance)
	end
end

function WeaponsSystem.onWeaponRemoved(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if weapon then
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons[weaponInstance] = nil
end

function WeaponsSystem.getRemoteEvent(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteEvent = WeaponsSystem.remoteEvents[name]
	if IsServer then
		if not remoteEvent then
			warn("No RemoteEvent named ", name)
			return nil
		end

		return remoteEvent
	else
		if not remoteEvent then
			remoteEvent = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteEvent
	end
end

function WeaponsSystem.getRemoteFunction(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteFunc = WeaponsSystem.remoteFunctions[name]
	if IsServer then
		if not remoteFunc then
			warn("No RemoteFunction named ", name)
			return nil
		end

		return remoteFunc
	else
		if not remoteFunc then
			remoteFunc = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteFunc
	end
end

function WeaponsSystem.setWeaponEquipped(weapon, equipped)
	assert(not IsServer, "WeaponsSystem.setWeaponEquipped should only be called on the client.")
	if not weapon then
		return
	end

	local lastWeapon = WeaponsSystem.currentWeapon
	local hasWeapon = false
	local weaponChanged = false

	if lastWeapon == weapon then
		if not equipped then
			WeaponsSystem.currentWeapon = nil
			hasWeapon = false
			weaponChanged = true
		else
			weaponChanged = false
		end
	else
		if equipped then
			WeaponsSystem.currentWeapon = weapon
			hasWeapon = true
			weaponChanged = true
		end
	end

	if WeaponsSystem.camera then
		WeaponsSystem.camera:resetZoomFactor()
		WeaponsSystem.camera:setHasScope(false)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.camera:setZoomFactor(WeaponsSystem.currentWeapon:getConfigValue("ZoomFactor", 1.1))
			WeaponsSystem.camera:setHasScope(WeaponsSystem.currentWeapon:getConfigValue("HasScope", false))
		end
	end

	if WeaponsSystem.gui then
		WeaponsSystem.gui:setEnabled(hasWeapon)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.gui:setCrosshairWeaponScale(WeaponsSystem.currentWeapon:getConfigValue("CrosshairScale", 1))
		else
			WeaponsSystem.gui:setCrosshairWeaponScale(1)
		end
	end

	if weaponChanged then
		WeaponsSystem.CurrentWeaponChanged:Fire(weapon.instance, lastWeapon and lastWeapon.instance)
	end
end

function WeaponsSystem.getHumanoid(part)
	while part and part ~= workspace do
		if part:IsA("Model") and part.PrimaryPart and part.PrimaryPart.Name == "HumanoidRootPart" then
			return part:FindFirstChildOfClass("Humanoid")
		end

		part = part.Parent
	end
end

function WeaponsSystem.getPlayerFromHumanoid(humanoid)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and humanoid:IsDescendantOf(player.Character) then
			return player
		end
	end
end

local function _defaultDamageCallback(system, target, amount, damageType, dealer, hitInfo, damageData)
	if target:IsA("Humanoid") then
		target:TakeDamage(amount)
	end
end

function WeaponsSystem.doDamage(target, amount, damageType, dealer, hitInfo, damageData)
	if not target or ancestorHasTag(target, "WeaponsSystemIgnore") then
		return
	end
	if IsServer then
		if target:IsA("Humanoid") and dealer:IsA("Player") and dealer.Character then
			local dealerHumanoid = dealer.Character:FindFirstChildOfClass("Humanoid")
			local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
			if dealerHumanoid and target ~= dealerHumanoid and targetPlayer then
				-- Trigger the damage indicator
				WeaponData:FireClient(targetPlayer, "HitByOtherPlayer", dealer.Character.HumanoidRootPart.CFrame.Position)
			end
		end

		-- NOTE:  damageData is a more or less free-form parameter that can be used for passing information from the code that is dealing damage about the cause.
		-- .The most obvious usage is extracting icons from the various weapon types (in which case a weapon instance would likely be passed in)
		-- ..The default weapons pass in that data
		local handler = _damageCallback or _defaultDamageCallback
		handler(WeaponsSystem, target, amount, damageType, dealer, hitInfo, damageData)
	end
end

local function _defaultGetTeamCallback(player)
	return 0
end

function WeaponsSystem.getTeam(player)
	local handler = _getTeamCallback or _defaultGetTeamCallback
	return handler(player)
end

function WeaponsSystem.playersOnDifferentTeams(player1, player2)
	if player1 == player2 or player1 == nil or player2 == nil then
		-- This allows players to damage themselves and NPC's
		return true
	end

	local player1Team = WeaponsSystem.getTeam(player1)
	local player2Team = WeaponsSystem.getTeam(player2)
	return player1Team == 0 or player1Team ~= player2Team
end

return WeaponsSystem

end))
Tool159.Name = "AR2"
Tool159.Parent = Folder0
Configuration160.Parent = Tool159
IntValue161.Name = "AmmoCapacity"
IntValue161.Parent = Configuration160
IntValue161.Value = 30
StringValue162.Name = "CasingEffect"
StringValue162.Parent = Configuration160
StringValue162.Value = "RifleCasing"
StringValue163.Name = "FireMode"
StringValue163.Parent = Configuration160
StringValue163.Value = "Automatic"
NumberValue164.Name = "GravityFactor"
NumberValue164.Parent = Configuration160
NumberValue164.Value = 0.5
NumberValue165.Name = "HitDamage"
NumberValue165.Parent = Configuration160
NumberValue165.Value = 14
NumberValue166.Name = "MuzzleFlashSize0"
NumberValue166.Parent = Configuration160
NumberValue166.Value = 1.1
NumberValue167.Name = "MuzzleFlashSize1"
NumberValue167.Parent = Configuration160
NumberValue167.Value = 1.4
NumberValue168.Name = "RecoilDecay"
NumberValue168.Parent = Configuration160
NumberValue168.Value = 0.81
NumberValue169.Name = "RecoilMax"
NumberValue169.Parent = Configuration160
NumberValue169.Value = 0.9
NumberValue170.Name = "RecoilMin"
NumberValue170.Parent = Configuration160
NumberValue170.Value = 0.7
NumberValue171.Name = "ShotCooldown"
NumberValue171.Parent = Configuration160
NumberValue171.Value = 0.125
StringValue172.Name = "ShotEffect"
StringValue172.Parent = Configuration160
StringValue172.Value = "Bullet"
NumberValue173.Name = "TotalRecoilMax"
NumberValue173.Parent = Configuration160
NumberValue173.Value = 1.1
NumberValue174.Name = "MaxSpread"
NumberValue174.Parent = Configuration160
NumberValue174.Value = 0.6
Part175.Name = "Handle"
Part175.Parent = Tool159
Part175.CFrame = CFrame.new(-4.08650398, 2.82889104, -11.5416098, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
Part175.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
Part175.Position = Vector3.new(-4.08650398, 2.82889104, -11.5416098)
Part175.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
Part175.Transparency = 1
Part175.Size = Vector3.new(0.5, 1, 3)
Part175.BottomSurface = Enum.SurfaceType.Smooth
Part175.CanCollide = false
Part175.TopSurface = Enum.SurfaceType.Smooth
Model176.Name = "AR"
Model176.Parent = Tool159
Model176.PrimaryPart = MeshPart177
MeshPart177.Name = "Rifle"
MeshPart177.Parent = Model176
MeshPart177.CFrame = CFrame.new(-4.21150398, 2.82733989, -11.5417404, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
MeshPart177.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
MeshPart177.Position = Vector3.new(-4.21150398, 2.82733989, -11.5417404)
MeshPart177.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
MeshPart177.Size = Vector3.new(0.194108516, 1.05410731, 4.72941303)
MeshPart177.Material = Enum.Material.Metal
MeshPart177.TextureID = "rbxassetid://3361234458"
Beam178.Name = "MuzzleFlash"
Beam178.Parent = MeshPart177
Beam178.Attachment0 = nil
Beam178.Attachment1 = nil
Beam178.Color = ColorSequence.new(Color3.new(0.839216, 0.670588, 0),Color3.new(1, 0.917647, 0.435294))
Beam178.Enabled = false
Beam178.LightEmission = 1
Beam178.Segments = 5
Beam178.Texture = "rbxassetid://872910628"
Beam178.TextureSpeed = 0
Beam178.Transparency = NumberSequence.new(0,0)
WeldConstraint179.Parent = MeshPart177
WeldConstraint179.Part0 = MeshPart177
WeldConstraint179.Part1 = MeshPart182
Sound180.Name = "Fired"
Sound180.Parent = MeshPart177
Sound180.SoundId = "rbxassetid://3806349898"
Sound181.Name = "Reload"
Sound181.Parent = MeshPart177
Sound181.SoundId = "rbxassetid://3821787597"
MeshPart182.Name = "Magazine"
MeshPart182.Parent = Model176
MeshPart182.CFrame = CFrame.new(-4.2770319, 2.48766422, -11.5252533, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
MeshPart182.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
MeshPart182.Position = Vector3.new(-4.2770319, 2.48766422, -11.5252533)
MeshPart182.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
MeshPart182.Color = Color3.new(0.290196, 0.278431, 0.286275)
MeshPart182.Size = Vector3.new(0.100694895, 1.03380096, 0.625120997)
MeshPart182.BrickColor = BrickColor.new("Dark taupe")
MeshPart182.Material = Enum.Material.Metal
MeshPart182.brickColor = BrickColor.new("Dark taupe")
MeshPart182.TextureID = "rbxassetid://3361234458"
MeshPart183.Name = "Bolt"
MeshPart183.Parent = Model176
MeshPart183.CFrame = CFrame.new(-4.18335915, 3.17553806, -11.6226263, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
MeshPart183.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
MeshPart183.Position = Vector3.new(-4.18335915, 3.17553806, -11.6226263)
MeshPart183.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
MeshPart183.Size = Vector3.new(0.22213085, 0.126657262, 0.561310232)
MeshPart183.Material = Enum.Material.Metal
StringValue184.Name = "WeaponType"
StringValue184.Parent = Tool159
StringValue184.Value = "BulletWeapon"
Folder185.Name = "WeaponsSystem"
Folder185.Parent = Tool159
IntValue186.Name = "Version"
IntValue186.Parent = Folder185
RemoteEvent187.Name = "WeaponData"
RemoteEvent187.Parent = Folder185
Folder188.Name = "Assets"
Folder188.Parent = Folder185
ScreenGui189.Name = "WeaponsSystemGui"
ScreenGui189.Parent = Folder188
ScreenGui189.AutoLocalize = false
ScreenGui189.Localize = false
ScreenGui189.ResetOnSpawn = false
ScreenGui189.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui189.DisplayOrder = 10000
Frame190.Name = "Scope"
Frame190.Parent = ScreenGui189
Frame190.Visible = false
Frame190.Size = UDim2.new(1, 0, 1, 0)
Frame190.BackgroundColor = BrickColor.new("Institutional white")
Frame190.BackgroundColor3 = Color3.new(1, 1, 1)
Frame190.BackgroundTransparency = 1
Frame190.ZIndex = 5
ImageLabel191.Name = "ScopeImage"
ImageLabel191.Parent = Frame190
ImageLabel191.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel191.Size = UDim2.new(1, 0, 0.949999988, 0)
ImageLabel191.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel191.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel191.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel191.BackgroundTransparency = 1
ImageLabel191.ZIndex = 2
ImageLabel191.Image = "rbxassetid://1598134910"
UIAspectRatioConstraint192.Parent = ImageLabel191
Frame193.Name = "LeftBlack"
Frame193.Parent = ImageLabel191
Frame193.Position = UDim2.new(0, 0, 0.5, 0)
Frame193.Size = UDim2.new(1, 0, 1, 0)
Frame193.AnchorPoint = Vector2.new(1, 0.5)
Frame193.BackgroundColor = BrickColor.new("Really black")
Frame193.BackgroundColor3 = Color3.new(0, 0, 0)
Frame193.BorderSizePixel = 0
Frame194.Name = "RightBlack"
Frame194.Parent = ImageLabel191
Frame194.Position = UDim2.new(1, 0, 0.5, 0)
Frame194.Size = UDim2.new(1, 0, 1, 0)
Frame194.AnchorPoint = Vector2.new(0, 0.5)
Frame194.BackgroundColor = BrickColor.new("Really black")
Frame194.BackgroundColor3 = Color3.new(0, 0, 0)
Frame194.BorderSizePixel = 0
Frame195.Name = "BottomBlack"
Frame195.Parent = ImageLabel191
Frame195.Position = UDim2.new(0.5, 0, 1, 0)
Frame195.Size = UDim2.new(5, 0, 1, 0)
Frame195.AnchorPoint = Vector2.new(0.5, 0)
Frame195.BackgroundColor = BrickColor.new("Really black")
Frame195.BackgroundColor3 = Color3.new(0, 0, 0)
Frame195.BorderSizePixel = 0
Frame196.Name = "TopBlack"
Frame196.Parent = ImageLabel191
Frame196.Position = UDim2.new(0.5, 0, 0, 0)
Frame196.Size = UDim2.new(5, 0, 1, 0)
Frame196.AnchorPoint = Vector2.new(0.5, 1)
Frame196.BackgroundColor = BrickColor.new("Really black")
Frame196.BackgroundColor3 = Color3.new(0, 0, 0)
Frame196.BorderSizePixel = 0
Frame197.Name = "SmallTouchscreen"
Frame197.Parent = ScreenGui189
Frame197.Visible = false
Frame197.Size = UDim2.new(1, 0, 1, 0)
Frame197.BackgroundColor = BrickColor.new("Institutional white")
Frame197.BackgroundColor3 = Color3.new(1, 1, 1)
Frame197.BackgroundTransparency = 1
Frame197.ZIndex = 10
ImageButton198.Name = "FireButton"
ImageButton198.Parent = Frame197
ImageButton198.Position = UDim2.new(1, -95, 1, -90)
ImageButton198.Size = UDim2.new(0, 72, 0, 72)
ImageButton198.Active = false
ImageButton198.BackgroundColor = BrickColor.new("Institutional white")
ImageButton198.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton198.BackgroundTransparency = 1
ImageButton198.ZIndex = 10
ImageButton198.Image = "rbxassetid://2804818047"
ImageButton199.Name = "AimButton"
ImageButton199.Parent = Frame197
ImageButton199.Position = UDim2.new(1, -25, 1, -148)
ImageButton199.Size = UDim2.new(0, 44, 0, 44)
ImageButton199.AnchorPoint = Vector2.new(1, 0)
ImageButton199.BackgroundColor = BrickColor.new("Institutional white")
ImageButton199.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton199.BackgroundTransparency = 1
ImageButton199.ZIndex = 10
ImageButton199.Image = "rbxassetid://2804583948"
Frame200.Name = "LargeTouchscreen"
Frame200.Parent = ScreenGui189
Frame200.Visible = false
Frame200.Size = UDim2.new(1, 0, 1, 0)
Frame200.BackgroundColor = BrickColor.new("Institutional white")
Frame200.BackgroundColor3 = Color3.new(1, 1, 1)
Frame200.BackgroundTransparency = 1
Frame200.ZIndex = 10
ImageButton201.Name = "FireButton"
ImageButton201.Parent = Frame200
ImageButton201.Position = UDim2.new(1, -170, 1, -210)
ImageButton201.Size = UDim2.new(0, 120, 0, 120)
ImageButton201.Active = false
ImageButton201.BackgroundColor = BrickColor.new("Institutional white")
ImageButton201.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton201.BackgroundTransparency = 1
ImageButton201.ZIndex = 10
ImageButton201.Image = "rbxassetid://2804818047"
ImageButton202.Name = "AimButton"
ImageButton202.Parent = Frame200
ImageButton202.Position = UDim2.new(1, -50, 1, -296)
ImageButton202.Size = UDim2.new(0, 88, 0, 88)
ImageButton202.AnchorPoint = Vector2.new(1, 0)
ImageButton202.BackgroundColor = BrickColor.new("Institutional white")
ImageButton202.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton202.BackgroundTransparency = 1
ImageButton202.ZIndex = 10
ImageButton202.Image = "rbxassetid://2804583948"
Folder203.Name = "ScalingElements"
Folder203.Parent = ScreenGui189
Frame204.Name = "Crosshair"
Frame204.Parent = Folder203
Frame204.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame204.Size = UDim2.new(0.0480000004, 0, 0.0480000004, 0)
Frame204.AnchorPoint = Vector2.new(0.5, 0.5)
Frame204.BackgroundColor = BrickColor.new("Institutional white")
Frame204.BackgroundColor3 = Color3.new(1, 1, 1)
Frame204.BackgroundTransparency = 1
ImageLabel205.Name = "Top"
ImageLabel205.Parent = Frame204
ImageLabel205.Position = UDim2.new(0.5, 0, 0, 0)
ImageLabel205.Size = UDim2.new(0.416700006, 0, 0.416999996, 0)
ImageLabel205.AnchorPoint = Vector2.new(0.5, 0)
ImageLabel205.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel205.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel205.BackgroundTransparency = 1
ImageLabel205.Image = "rbxassetid://2755681329"
ImageLabel206.Name = "Bottom"
ImageLabel206.Parent = Frame204
ImageLabel206.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel206.Rotation = 180
ImageLabel206.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel206.AnchorPoint = Vector2.new(0.5, 1)
ImageLabel206.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel206.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel206.BackgroundTransparency = 1
ImageLabel206.Image = "rbxassetid://2755681329"
ImageLabel207.Name = "Left"
ImageLabel207.Parent = Frame204
ImageLabel207.Position = UDim2.new(0, 0, 0.5, 0)
ImageLabel207.Rotation = 270
ImageLabel207.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel207.AnchorPoint = Vector2.new(0, 0.5)
ImageLabel207.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel207.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel207.BackgroundTransparency = 1
ImageLabel207.Image = "rbxassetid://2755681329"
ImageLabel208.Name = "Right"
ImageLabel208.Parent = Frame204
ImageLabel208.Position = UDim2.new(1, 0, 0.5, 0)
ImageLabel208.Rotation = 90
ImageLabel208.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel208.AnchorPoint = Vector2.new(1, 0.5)
ImageLabel208.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel208.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel208.BackgroundTransparency = 1
ImageLabel208.Image = "rbxassetid://2755681329"
UIAspectRatioConstraint209.Parent = Frame204
Frame210.Name = "HitMarker"
Frame210.Parent = Folder203
Frame210.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame210.Size = UDim2.new(0.0480000004, 0, 0.0480000004, 0)
Frame210.AnchorPoint = Vector2.new(0.5, 0.5)
Frame210.BackgroundColor = BrickColor.new("Institutional white")
Frame210.BackgroundColor3 = Color3.new(1, 1, 1)
Frame210.BackgroundTransparency = 1
UIAspectRatioConstraint211.Parent = Frame210
ImageLabel212.Name = "HitMarkerImage"
ImageLabel212.Parent = Frame210
ImageLabel212.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel212.Rotation = 180
ImageLabel212.Size = UDim2.new(1, 0, 1, 0)
ImageLabel212.AnchorPoint = Vector2.new(0.5, 1)
ImageLabel212.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel212.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel212.BackgroundTransparency = 1
ImageLabel212.Image = "rbxassetid://285779644"
ImageLabel212.ImageTransparency = 1
Folder213.Name = "DirectionalIndicators"
Folder213.Parent = Folder203
Frame214.Name = "DamageIndicator"
Frame214.Parent = Folder213
Frame214.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame214.Rotation = 180
Frame214.Size = UDim2.new(0.180000007, 0, 0.360000014, 0)
Frame214.AnchorPoint = Vector2.new(0.5, 0.5)
Frame214.BackgroundColor = BrickColor.new("Institutional white")
Frame214.BackgroundColor3 = Color3.new(1, 1, 1)
Frame214.BackgroundTransparency = 1
ImageLabel215.Name = "DamageIndicator"
ImageLabel215.Parent = Frame214
ImageLabel215.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel215.Rotation = 90
ImageLabel215.Size = UDim2.new(1, 0, 0.5, 0)
ImageLabel215.AnchorPoint = Vector2.new(0.5, 0.620000005)
ImageLabel215.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel215.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel215.BackgroundTransparency = 1
ImageLabel215.Image = "rbxassetid://3498623805"
ImageLabel215.ImageColor3 = Color3.new(0.898039, 0, 0)
ImageLabel215.ImageTransparency = 1
ImageLabel215.ScaleType = Enum.ScaleType.Slice
UIAspectRatioConstraint216.Parent = ImageLabel215
UIAspectRatioConstraint216.AspectRatio = 0.27200001478195
Configuration217.Parent = Frame214
StringValue218.Name = "Name"
StringValue218.Parent = Configuration217
StringValue218.Value = "DamageIndicator"
NumberValue219.Name = "TimeBeforeFade"
NumberValue219.Parent = Configuration217
NumberValue219.Value = 1.5
NumberValue220.Name = "FadeTime"
NumberValue220.Parent = Configuration217
NumberValue220.Value = 1
NumberValue221.Name = "TransparencyBeforeFade"
NumberValue221.Parent = Configuration217
NumberValue221.Value = 0.25
NumberValue222.Name = "DistanceLevelFromCenter"
NumberValue222.Parent = Configuration217
NumberValue222.Value = 6
NumberValue223.Name = "WidthLevel"
NumberValue223.Parent = Configuration217
NumberValue223.Value = 6
UIAspectRatioConstraint224.Parent = Frame214
Folder225.Name = "Animations"
Folder225.Parent = Folder188
Animation226.Name = "RifleAim"
Animation226.Parent = Folder225
Animation226.AnimationId = "rbxassetid://3972164452"
Animation227.Name = "RifleAimDownSights"
Animation227.Parent = Folder225
Animation227.AnimationId = "rbxassetid://3972157449"
Animation228.Name = "RifleReload"
Animation228.Parent = Folder225
Animation228.AnimationId = "rbxassetid://3972131105"
Folder229.Name = "Effects"
Folder229.Parent = Folder188
Folder230.Name = "Shots"
Folder230.Parent = Folder229
Part231.Name = "Bullet"
Part231.Parent = Folder230
Part231.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part231.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part231.Transparency = 1
Part231.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part231.Anchored = true
Part231.BottomSurface = Enum.SurfaceType.Smooth
Part231.CanCollide = false
Part231.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter232.Name = "TrailParticles"
ParticleEmitter232.Parent = mas
ParticleEmitter232.Speed = NumberRange.new(0, 2)
ParticleEmitter232.Rotation = NumberRange.new(-180, 180)
ParticleEmitter232.Color = ColorSequence.new(Color3.new(0.423529, 0.329412, 0),Color3.new(0.760784, 0.607843, 0))
ParticleEmitter232.Enabled = false
ParticleEmitter232.Texture = "rbxassetid://3852340006"
ParticleEmitter232.Transparency = NumberSequence.new(0,0.087499976158142,0.41249996423721,1)
ParticleEmitter232.Size = NumberSequence.new(0.070000000298023,0.070000000298023)
ParticleEmitter232.Lifetime = NumberRange.new(0.25, 0.5)
ParticleEmitter232.Rate = 100
ParticleEmitter232.RotSpeed = NumberRange.new(-50, 50)
ParticleEmitter232.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter232.VelocityInheritance = 0.30000001192093
ParticleEmitter232.VelocitySpread = 30
Beam233.Name = "Beam0"
Beam233.Parent = Part231
Beam233.Attachment0 = nil
Beam233.Attachment1 = nil
Beam233.Enabled = false
Beam233.FaceCamera = true
Beam233.Segments = 50
Beam233.Texture = "rbxassetid://3867967806"
Beam233.TextureSpeed = 0
Beam233.Transparency = NumberSequence.new(1,0,0,1)
Beam233.Width0 = 0.10000000149012
Beam233.Width1 = 0.25
Beam234.Name = "Beam1"
Beam234.Parent = Part231
Beam234.Attachment0 = nil
Beam234.Attachment1 = nil
Beam234.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam234.Enabled = false
Beam234.FaceCamera = true
Beam234.LightEmission = 1
Beam234.Segments = 50
Beam234.Texture = "rbxassetid://1287002748"
Beam234.TextureSpeed = 0
Beam234.Transparency = NumberSequence.new(1,1)
Beam234.Width0 = 0.10000000149012
Beam234.Width1 = 0.10000000149012
ParticleEmitter235.Name = "HitParticles"
ParticleEmitter235.Parent = mas
ParticleEmitter235.Speed = NumberRange.new(0, 10)
ParticleEmitter235.Rotation = NumberRange.new(-180, 180)
ParticleEmitter235.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter235.LightEmission = 0.10000000149012
ParticleEmitter235.LightInfluence = 1
ParticleEmitter235.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter235.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter235.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter235.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter235.Drag = 0.5
ParticleEmitter235.EmissionDirection = Enum.NormalId.Front
ParticleEmitter235.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter235.Rate = 0
ParticleEmitter235.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter235.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter235.VelocityInheritance = -0.0010000000474975
ParticleEmitter235.VelocitySpread = 30
Sound236.Name = "HitSound"
Sound236.Parent = mas
Sound236.SoundId = "rbxassetid://1489924400"
Sound236.Volume = 0
Part237.Name = "Grenade"
Part237.Parent = Folder230
Part237.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part237.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part237.Transparency = 1
Part237.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part237.Anchored = true
Part237.BottomSurface = Enum.SurfaceType.Smooth
Part237.CanCollide = false
Part237.TopSurface = Enum.SurfaceType.Smooth
Beam238.Name = "Beam0"
Beam238.Parent = Part237
Beam238.Attachment0 = nil
Beam238.Attachment1 = nil
Beam238.Color = ColorSequence.new(Color3.new(1, 0.796078, 0.270588),Color3.new(1, 0.798884, 0.280833),Color3.new(1, 0.964706, 0.886275))
Beam238.Enabled = false
Beam238.FaceCamera = true
Beam238.LightEmission = 1
Beam238.Segments = 50
Beam238.Texture = "rbxassetid://2463944225"
Beam238.TextureSpeed = 0
Beam238.Transparency = NumberSequence.new(1,0.90710383653641,0,1)
Beam238.Width0 = 0.10000000149012
Beam238.Width1 = 0.25
Beam239.Name = "Beam1"
Beam239.Parent = Part237
Beam239.Attachment0 = nil
Beam239.Attachment1 = nil
Beam239.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam239.Enabled = false
Beam239.FaceCamera = true
Beam239.LightEmission = 1
Beam239.Segments = 50
Beam239.Texture = "rbxassetid://1287002748"
Beam239.TextureSpeed = 0
Beam239.Transparency = NumberSequence.new(1,0.95081967115402,0.76502734422684,0.43169403076172,0,1)
Beam239.Width0 = 0.10000000149012
Beam239.Width1 = 0.10000000149012
Sound240.Name = "HitSound"
Sound240.Parent = mas
Sound240.SoundId = "rbxassetid://3963013256"
Sound240.Volume = 5
SpecialMesh241.Parent = Part237
SpecialMesh241.MeshId = "http://www.roblox.com/asset/?id=232379763"
SpecialMesh241.Scale = Vector3.new(1.5, 1.5, 1.5)
SpecialMesh241.TextureId = "http://www.roblox.com/asset/?id=232379808"
SpecialMesh241.MeshType = Enum.MeshType.FileMesh
Sound242.Name = "Flying"
Sound242.Parent = Part237
Sound242.Looped = true
Sound242.EmitterSize = 5
Sound242.MinDistance = 5
Sound242.SoundId = "rbxassetid://3963014042"
Part243.Name = "Arrow"
Part243.Parent = Folder230
Part243.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part243.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part243.Transparency = 1
Part243.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part243.Anchored = true
Part243.BottomSurface = Enum.SurfaceType.Smooth
Part243.CanCollide = false
Part243.TopSurface = Enum.SurfaceType.Smooth
Beam244.Name = "Beam0"
Beam244.Parent = Part243
Beam244.Attachment0 = nil
Beam244.Attachment1 = nil
Beam244.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.964706, 0.886275))
Beam244.Enabled = false
Beam244.FaceCamera = true
Beam244.LightEmission = 1
Beam244.Segments = 50
Beam244.Texture = "rbxassetid://2463944225"
Beam244.TextureLength = 0.5
Beam244.TextureSpeed = 0
Beam244.Transparency = NumberSequence.new(1,0.74863386154175,1,0.4426229596138,1,0.25136613845825,1,0.14754098653793,0.85792350769043,0,1,0,1,0,1)
Beam244.Width0 = 0.25
Beam244.Width1 = 0.25
Beam245.Name = "Beam1"
Beam245.Parent = Part243
Beam245.Attachment0 = nil
Beam245.Attachment1 = nil
Beam245.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(0.862745, 0.862745, 0.862745))
Beam245.Enabled = false
Beam245.FaceCamera = true
Beam245.LightEmission = 1
Beam245.Segments = 50
Beam245.Texture = "rbxassetid://1287002748"
Beam245.TextureSpeed = 0
Beam245.Transparency = NumberSequence.new(1,0.75409835577011,0.55191254615784,0.43169403076172,0.43169403076172,0.28415304422379,1)
Beam245.Width0 = 0.25
Beam245.Width1 = 0.25
ParticleEmitter246.Name = "HitParticles"
ParticleEmitter246.Parent = mas
ParticleEmitter246.Speed = NumberRange.new(0, 10)
ParticleEmitter246.Rotation = NumberRange.new(-180, 180)
ParticleEmitter246.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter246.LightEmission = 0.10000000149012
ParticleEmitter246.LightInfluence = 1
ParticleEmitter246.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter246.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter246.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter246.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter246.Drag = 0.5
ParticleEmitter246.EmissionDirection = Enum.NormalId.Front
ParticleEmitter246.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter246.Rate = 0
ParticleEmitter246.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter246.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter246.VelocityInheritance = -0.0010000000474975
ParticleEmitter246.VelocitySpread = 30
Sound247.Name = "HitSound"
Sound247.Parent = mas
Sound247.SoundId = "rbxassetid://3963012401"
Sound247.Volume = 0.25
SpecialMesh248.Parent = Part243
SpecialMesh248.MeshId = "rbxassetid://2493118549"
SpecialMesh248.Offset = Vector3.new(0, 0, -0.899999976)
SpecialMesh248.Scale = Vector3.new(0.43178001, 0.43178001, 0.43178001)
SpecialMesh248.TextureId = "rbxassetid://2493025364"
SpecialMesh248.MeshType = Enum.MeshType.FileMesh
Part249.Name = "Rocket"
Part249.Parent = Folder230
Part249.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part249.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part249.Transparency = 1
Part249.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part249.Anchored = true
Part249.BottomSurface = Enum.SurfaceType.Smooth
Part249.CanCollide = false
Part249.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter250.Name = "LeadingParticles"
ParticleEmitter250.Parent = mas
ParticleEmitter250.Speed = NumberRange.new(-5, -5)
ParticleEmitter250.Rotation = NumberRange.new(-180, 180)
ParticleEmitter250.Color = ColorSequence.new(Color3.new(1, 0.470588, 0.117647),Color3.new(1, 0.352941, 0.156863),Color3.new(0.815686, 0.490196, 0))
ParticleEmitter250.Enabled = false
ParticleEmitter250.LightEmission = 1
ParticleEmitter250.Texture = "rbxasset://textures/particles/fire_main.dds"
ParticleEmitter250.Transparency = NumberSequence.new(1,0.07407408952713,0,0,0.098765432834625,0.25308638811111,1)
ParticleEmitter250.Size = NumberSequence.new(0.3125,0.34722208976746,0.72916686534882,1.5625,2.8819441795349)
ParticleEmitter250.Drag = 5
ParticleEmitter250.EmissionDirection = Enum.NormalId.Left
ParticleEmitter250.Lifetime = NumberRange.new(0.10000000149012, 0.25)
ParticleEmitter250.Rate = 500
ParticleEmitter250.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter250.SpreadAngle = Vector2.new(10, 10)
ParticleEmitter250.VelocityInheritance = -0.10000000149012
ParticleEmitter250.VelocitySpread = 10
Beam251.Name = "Beam0"
Beam251.Parent = Part249
Beam251.Attachment0 = nil
Beam251.Attachment1 = nil
Beam251.Color = ColorSequence.new(Color3.new(1, 0.796078, 0.270588),Color3.new(1, 0.798884, 0.280833),Color3.new(1, 0.964706, 0.886275))
Beam251.Enabled = false
Beam251.FaceCamera = true
Beam251.LightEmission = 1
Beam251.Segments = 50
Beam251.Texture = "rbxassetid://2463944225"
Beam251.TextureSpeed = 0
Beam251.Transparency = NumberSequence.new(1,0.90710383653641,0,1)
Beam251.Width0 = 0.10000000149012
Beam251.Width1 = 0.25
Beam252.Name = "Beam1"
Beam252.Parent = Part249
Beam252.Attachment0 = nil
Beam252.Attachment1 = nil
Beam252.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam252.Enabled = false
Beam252.FaceCamera = true
Beam252.LightEmission = 1
Beam252.Segments = 50
Beam252.Texture = "rbxassetid://1287002748"
Beam252.TextureSpeed = 0
Beam252.Transparency = NumberSequence.new(1,0.95081967115402,0.76502734422684,0.43169403076172,0,1)
Beam252.Width0 = 0.10000000149012
Beam252.Width1 = 0.10000000149012
ParticleEmitter253.Name = "HitParticles"
ParticleEmitter253.Parent = mas
ParticleEmitter253.Speed = NumberRange.new(0, 10)
ParticleEmitter253.Rotation = NumberRange.new(-180, 180)
ParticleEmitter253.Color = ColorSequence.new(Color3.new(1, 0.988235, 0.929412),Color3.new(0.97466, 0.925769, 0.797998),Color3.new(1, 0.803922, 0.0941176),Color3.new(1, 0.705882, 0.109804),Color3.new(0.196078, 0.133333, 0.0117647))
ParticleEmitter253.LightEmission = 1
ParticleEmitter253.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter253.Transparency = NumberSequence.new(1,0,0.76543211936951,0.9753086566925,0.98765432834625,1)
ParticleEmitter253.Size = NumberSequence.new(0,2.9166669845581,2.361111164093,5.5208339691162,8.125)
ParticleEmitter253.Drag = 10
ParticleEmitter253.EmissionDirection = Enum.NormalId.Front
ParticleEmitter253.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter253.Rate = 0
ParticleEmitter253.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter253.SpreadAngle = Vector2.new(15, 15)
ParticleEmitter253.VelocitySpread = 15
Sound254.Name = "HitSound"
Sound254.Parent = mas
Sound254.SoundId = "rbxassetid://3963015379"
Sound254.Volume = 5
SpecialMesh255.Parent = Part249
SpecialMesh255.MeshId = "rbxassetid://94690081"
SpecialMesh255.Offset = Vector3.new(0, 0, -2)
SpecialMesh255.Scale = Vector3.new(2, 2, 2)
SpecialMesh255.TextureId = "rbxassetid://94689966"
SpecialMesh255.MeshType = Enum.MeshType.FileMesh
Sound256.Name = "Flying"
Sound256.Parent = Part249
Sound256.Looped = true
Sound256.EmitterSize = 5
Sound256.MinDistance = 5
Sound256.SoundId = "rbxassetid://3963016451"
Sound256.Volume = 2
Part257.Name = "Railgun"
Part257.Parent = Folder230
Part257.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part257.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part257.Transparency = 1
Part257.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part257.Anchored = true
Part257.BottomSurface = Enum.SurfaceType.Smooth
Part257.CanCollide = false
Part257.TopSurface = Enum.SurfaceType.Smooth
Beam258.Name = "Beam0"
Beam258.Parent = Part257
Beam258.Attachment0 = nil
Beam258.Attachment1 = nil
Beam258.Color = ColorSequence.new(Color3.new(1, 0.921569, 0.560784),Color3.new(1, 0.921569, 0.560784))
Beam258.Enabled = false
Beam258.FaceCamera = true
Beam258.LightEmission = 1
Beam258.Segments = 50
Beam258.Texture = "rbxassetid://1286995910"
Beam258.TextureSpeed = 0
Beam258.Transparency = NumberSequence.new(1,0,0,1)
Beam258.Width0 = 0.10000000149012
Beam258.Width1 = 0.25
Beam259.Name = "Beam1"
Beam259.Parent = Part257
Beam259.Attachment0 = nil
Beam259.Attachment1 = nil
Beam259.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam259.Enabled = false
Beam259.FaceCamera = true
Beam259.LightEmission = 1
Beam259.Segments = 50
Beam259.Texture = "rbxassetid://1287002748"
Beam259.TextureSpeed = 0
Beam259.Transparency = NumberSequence.new(1,0,0,1)
Beam259.Width0 = 0.10000000149012
Beam259.Width1 = 0.10000000149012
Sound260.Name = "HitSound"
Sound260.Parent = mas
Sound260.Pitch = 0.25
Sound260.PlaybackSpeed = 0.25
Sound260.SoundId = "rbxassetid://1489924400"
Sound260.Volume = 2
ParticleEmitter261.Name = "HitParticles"
ParticleEmitter261.Parent = mas
ParticleEmitter261.Speed = NumberRange.new(0, 2)
ParticleEmitter261.Rotation = NumberRange.new(-180, 180)
ParticleEmitter261.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.976659, 0.943567),Color3.new(1, 0.690196, 0.25098),Color3.new(1, 0.588235, 0.172549),Color3.new(0.4, 0.0352941, 0.0352941),Color3.new(0.14902, 0.121569, 0.121569),Color3.new(0.14902, 0.14902, 0.14902))
ParticleEmitter261.Enabled = false
ParticleEmitter261.LightEmission = 1
ParticleEmitter261.Texture = "rbxassetid://552389687"
ParticleEmitter261.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter261.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter261.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter261.Drag = 0.5
ParticleEmitter261.EmissionDirection = Enum.NormalId.Front
ParticleEmitter261.Lifetime = NumberRange.new(0.10000000149012, 1)
ParticleEmitter261.Rate = 0
ParticleEmitter261.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter261.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter261.VelocityInheritance = -0.0010000000474975
ParticleEmitter261.VelocitySpread = 30
ParticleEmitter262.Name = "MuzzleParticles"
ParticleEmitter262.Parent = Part257
ParticleEmitter262.Speed = NumberRange.new(5, 25)
ParticleEmitter262.Rotation = NumberRange.new(-180, 180)
ParticleEmitter262.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.580392, 0.580392),Color3.new(0.188235, 0.0352941, 0.0352941))
ParticleEmitter262.Enabled = false
ParticleEmitter262.LightEmission = 0.5
ParticleEmitter262.LightInfluence = 0.5
ParticleEmitter262.Texture = "rbxassetid://552389687"
ParticleEmitter262.Transparency = NumberSequence.new(1,0.83950614929199,0.90123456716537,0.70370370149612,0.80246913433075,0.67283952236176,0.93209874629974,0.56172835826874,0.8950617313385,0.6851851940155,0.92592591047287,1)
ParticleEmitter262.Size = NumberSequence.new(0,0.83333313465118,3.1944441795349,0.625,0.72916686534882,0,0.41666686534882,0)
ParticleEmitter262.Drag = 8
ParticleEmitter262.EmissionDirection = Enum.NormalId.Front
ParticleEmitter262.Lifetime = NumberRange.new(0.5, 1)
ParticleEmitter262.Rate = 0
ParticleEmitter262.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter262.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter262.VelocitySpread = 30
Part263.Name = "Plasma"
Part263.Parent = Folder230
Part263.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part263.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part263.Transparency = 1
Part263.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part263.Anchored = true
Part263.BottomSurface = Enum.SurfaceType.Smooth
Part263.CanCollide = false
Part263.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter264.Name = "LeadingParticles"
ParticleEmitter264.Parent = mas
ParticleEmitter264.Speed = NumberRange.new(5, 10)
ParticleEmitter264.Rotation = NumberRange.new(-180, 180)
ParticleEmitter264.Color = ColorSequence.new(Color3.new(0.498039, 0.917647, 1),Color3.new(1, 1, 1))
ParticleEmitter264.Enabled = false
ParticleEmitter264.LightEmission = 1
ParticleEmitter264.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter264.Transparency = NumberSequence.new(1,0,0,0.74074077606201,0.95679014921188,1)
ParticleEmitter264.Size = NumberSequence.new(0.3125,0.59027791023254,1.3194441795349,0.41666686534882,0.20833313465118,0)
ParticleEmitter264.Drag = 0.5
ParticleEmitter264.Lifetime = NumberRange.new(0.10000000149012, 0.25)
ParticleEmitter264.LockedToPart = true
ParticleEmitter264.Rate = 100
ParticleEmitter264.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter264.SpreadAngle = Vector2.new(180, 180)
ParticleEmitter264.VelocitySpread = 180
Beam265.Name = "Beam0"
Beam265.Parent = Part263
Beam265.Attachment0 = nil
Beam265.Attachment1 = nil
Beam265.Color = ColorSequence.new(Color3.new(0.498039, 0.917647, 1),Color3.new(0.498039, 0.917647, 1))
Beam265.Enabled = false
Beam265.FaceCamera = true
Beam265.LightEmission = 1
Beam265.Segments = 50
Beam265.Texture = "rbxassetid://2463944225"
Beam265.TextureSpeed = 0
Beam265.Transparency = NumberSequence.new(1,0,0,1)
Beam265.Width0 = 0.10000000149012
Beam265.Width1 = 0.25
Beam266.Name = "Beam1"
Beam266.Parent = Part263
Beam266.Attachment0 = nil
Beam266.Attachment1 = nil
Beam266.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam266.Enabled = false
Beam266.FaceCamera = true
Beam266.LightEmission = 1
Beam266.Segments = 50
Beam266.Texture = "rbxassetid://1287002748"
Beam266.TextureSpeed = 0
Beam266.Transparency = NumberSequence.new(1,0,0,1)
Beam266.Width0 = 0.10000000149012
Beam266.Width1 = 0.10000000149012
ParticleEmitter267.Name = "HitParticles"
ParticleEmitter267.Parent = mas
ParticleEmitter267.Speed = NumberRange.new(0, 10)
ParticleEmitter267.Rotation = NumberRange.new(-180, 180)
ParticleEmitter267.Color = ColorSequence.new(Color3.new(0.607843, 0.937255, 1),Color3.new(0, 0.392157, 0.470588))
ParticleEmitter267.LightEmission = 1
ParticleEmitter267.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter267.Transparency = NumberSequence.new(1,0,0.76543211936951,0.9753086566925,0.98765432834625,1)
ParticleEmitter267.Size = NumberSequence.new(0,1.25,0.97222208976746,2.1180553436279,3.5069441795349)
ParticleEmitter267.Drag = 10
ParticleEmitter267.EmissionDirection = Enum.NormalId.Front
ParticleEmitter267.Lifetime = NumberRange.new(0.5, 2)
ParticleEmitter267.Rate = 0
ParticleEmitter267.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter267.SpreadAngle = Vector2.new(15, 15)
ParticleEmitter267.VelocitySpread = 15
Sound268.Name = "HitSound"
Sound268.Parent = mas
Sound268.Pitch = 2
Sound268.PlaybackSpeed = 2
Sound268.SoundId = "rbxassetid://878000314"
Sound268.Volume = 0.25
Part269.Name = "CannonBall"
Part269.Parent = Folder230
Part269.CFrame = CFrame.new(-6.13895988, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part269.Position = Vector3.new(-6.13895988, 3.05302191, -11.435256)
Part269.Color = Color3.new(0.160784, 0.164706, 0.188235)
Part269.Transparency = 1
Part269.Size = Vector3.new(2, 2, 2)
Part269.BottomSurface = Enum.SurfaceType.Smooth
Part269.BrickColor = BrickColor.new("Black")
Part269.CustomPhysicalProperties = 13, 0.800000012, 0.0500000007, 10, 100
Part269.Material = Enum.Material.Metal
Part269.TopSurface = Enum.SurfaceType.Smooth
Part269.brickColor = BrickColor.new("Black")
Part269.Shape = Enum.PartType.Ball
Beam270.Name = "Beam0"
Beam270.Parent = Part269
Beam270.Attachment0 = nil
Beam270.Attachment1 = nil
Beam270.Color = ColorSequence.new(Color3.new(0.639216, 0.639216, 0.639216),Color3.new(0.34902, 0.34902, 0.34902))
Beam270.Enabled = false
Beam270.FaceCamera = true
Beam270.LightEmission = 1
Beam270.LightInfluence = 1
Beam270.Segments = 50
Beam270.Texture = "rbxassetid://2463944225"
Beam270.TextureSpeed = 0
Beam270.Transparency = NumberSequence.new(1,0,0,1)
Beam270.Width0 = 0.10000000149012
Beam270.Width1 = 2
Beam271.Name = "Beam1"
Beam271.Parent = Part269
Beam271.Attachment0 = nil
Beam271.Attachment1 = nil
Beam271.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam271.Enabled = false
Beam271.FaceCamera = true
Beam271.LightEmission = 1
Beam271.Segments = 50
Beam271.Texture = "rbxassetid://2463944225"
Beam271.TextureSpeed = 0
Beam271.Transparency = NumberSequence.new(1,0,0,1)
Beam271.Width0 = 0.10000000149012
Beam271.Width1 = 3
Sound272.Name = "HitSound"
Sound272.Parent = mas
Sound272.SoundId = "rbxassetid://1489924400"
Sound272.Volume = 0.25
ParticleEmitter273.Name = "HitParticles"
ParticleEmitter273.Parent = mas
ParticleEmitter273.Speed = NumberRange.new(0, 10)
ParticleEmitter273.Rotation = NumberRange.new(-180, 180)
ParticleEmitter273.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter273.Enabled = false
ParticleEmitter273.LightEmission = 0.10000000149012
ParticleEmitter273.LightInfluence = 1
ParticleEmitter273.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter273.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter273.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter273.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter273.Drag = 0.5
ParticleEmitter273.EmissionDirection = Enum.NormalId.Front
ParticleEmitter273.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter273.Rate = 0
ParticleEmitter273.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter273.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter273.VelocityInheritance = -0.0010000000474975
ParticleEmitter273.VelocitySpread = 30
Folder274.Name = "HitMarks"
Folder274.Parent = Folder229
Part275.Name = "BulletHole"
Part275.Parent = Folder274
Part275.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part275.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part275.Transparency = 1
Part275.Size = Vector3.new(0.5, 0.5, 0.0500000007)
Part275.BottomSurface = Enum.SurfaceType.Smooth
Part275.CanCollide = false
Part275.TopSurface = Enum.SurfaceType.Smooth
BillboardGui276.Name = "ImpactBillboard"
BillboardGui276.Parent = Part275
BillboardGui276.LightInfluence = 1
BillboardGui276.Size = UDim2.new(5, 0, 5, 0)
BillboardGui276.ResetOnSpawn = false
BillboardGui276.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
BillboardGui276.Adornee = Part275
BillboardGui276.ExtentsOffset = Vector3.new(0, 0, 0.25)
ImageLabel277.Name = "Impact"
ImageLabel277.Parent = BillboardGui276
ImageLabel277.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel277.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel277.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel277.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel277.BackgroundTransparency = 1
ImageLabel277.BorderSizePixel = 0
ImageLabel277.Image = "rbxassetid://3918596245"
ImageLabel277.ImageTransparency = 1
Decal278.Name = "BulletHole"
Decal278.Parent = Part275
Decal278.Texture = "http://www.roblox.com/asset/?id=2078626"
Decal278.Transparency = 1
Decal278.Face = Enum.NormalId.Back
Decal278.Color3 = Color3.new(1, 0.831373, 0.435294)
Part279.Name = "Pellet"
Part279.Parent = Folder274
Part279.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part279.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part279.Transparency = 1
Part279.Size = Vector3.new(0.200000003, 0.200000003, 0.0500000007)
Part279.BottomSurface = Enum.SurfaceType.Smooth
Part279.CanCollide = false
Part279.TopSurface = Enum.SurfaceType.Smooth
Decal280.Name = "BulletHole"
Decal280.Parent = Part279
Decal280.Texture = "http://www.roblox.com/asset/?id=2078626"
Decal280.Transparency = 1
Decal280.Face = Enum.NormalId.Back
Decal280.Color3 = Color3.new(1, 0.831373, 0.435294)
Part281.Name = "Arrow"
Part281.Parent = Folder274
Part281.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part281.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
Part281.Transparency = 1
Part281.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part281.BottomSurface = Enum.SurfaceType.Smooth
Part281.CanCollide = false
Part281.TopSurface = Enum.SurfaceType.Smooth
SpecialMesh282.Parent = Part281
SpecialMesh282.MeshId = "rbxassetid://2493118549"
SpecialMesh282.Offset = Vector3.new(0, 0, 0.75)
SpecialMesh282.Scale = Vector3.new(0.43178001, 0.43178001, 0.43178001)
SpecialMesh282.TextureId = "rbxassetid://2493025364"
SpecialMesh282.MeshType = Enum.MeshType.FileMesh
Part283.Name = "Scorch"
Part283.Parent = Folder274
Part283.CFrame = CFrame.new(-5.2789588, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part283.Position = Vector3.new(-5.2789588, 3.05302191, -11.435256)
Part283.Transparency = 1
Part283.Size = Vector3.new(2, 2, 0.0500000007)
Part283.BottomSurface = Enum.SurfaceType.Smooth
Part283.CanCollide = false
Part283.TopSurface = Enum.SurfaceType.Smooth
Decal284.Name = "ScorchMark"
Decal284.Parent = Part283
Decal284.Texture = "rbxassetid://53875997"
Decal284.Transparency = 1
Decal284.Face = Enum.NormalId.Back
Decal285.Name = "Glow"
Decal285.Parent = Part283
Decal285.Texture = "http://www.roblox.com/asset/?id=246689799"
Decal285.Transparency = 1
Decal285.Face = Enum.NormalId.Back
Decal285.Color3 = Color3.new(1, 0.258824, 0.113725)
Part286.Name = "Explosion"
Part286.Parent = Folder274
Part286.CFrame = CFrame.new(-5.2789588, 3.05302191, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part286.Position = Vector3.new(-5.2789588, 3.05302191, -11.435256)
Part286.Transparency = 1
Part286.Size = Vector3.new(2.5, 2.5, 0.0500000007)
Part286.BottomSurface = Enum.SurfaceType.Smooth
Part286.CanCollide = false
Part286.TopSurface = Enum.SurfaceType.Smooth
Decal287.Name = "ScorchMark"
Decal287.Parent = Part286
Decal287.Texture = "rbxassetid://53875997"
Decal287.Transparency = 1
Decal287.Face = Enum.NormalId.Back
Decal288.Name = "Glow"
Decal288.Parent = Part286
Decal288.Texture = "http://www.roblox.com/asset/?id=246689799"
Decal288.Transparency = 1
Decal288.Face = Enum.NormalId.Back
Decal288.Color3 = Color3.new(1, 0.258824, 0.113725)
Folder289.Name = "Casings"
Folder289.Parent = Folder229
MeshPart290.Name = "RifleCasing"
MeshPart290.Parent = Folder289
MeshPart290.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 0, 1, -0, -1, 0, 0, 0, 0, 1)
MeshPart290.Orientation = Vector3.new(0, 0, -90)
MeshPart290.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
MeshPart290.Rotation = Vector3.new(0, 0, -90)
MeshPart290.Color = Color3.new(1, 0.690196, 0)
MeshPart290.Transparency = 1
MeshPart290.Size = Vector3.new(0.105999999, 0.330000013, 0.105999999)
MeshPart290.BrickColor = BrickColor.new("Deep orange")
MeshPart290.Material = Enum.Material.Metal
MeshPart290.brickColor = BrickColor.new("Deep orange")
MeshPart290.TextureID = "rbxassetid://2794275376"
Sound291.Name = "CasingHitSound"
Sound291.Parent = MeshPart290
Sound291.EmitterSize = 1
Sound291.MinDistance = 1
Sound291.SoundId = "rbxassetid://3909012115"
Sound291.Volume = 1
MeshPart292.Name = "PistolCasing"
MeshPart292.Parent = Folder289
MeshPart292.CFrame = CFrame.new(-6.52995777, 3.05302191, -11.435256, 0, 1, -0, -1, 0, 0, 0, 0, 1)
MeshPart292.Orientation = Vector3.new(0, 0, -90)
MeshPart292.Position = Vector3.new(-6.52995777, 3.05302191, -11.435256)
MeshPart292.Rotation = Vector3.new(0, 0, -90)
MeshPart292.Color = Color3.new(1, 0.690196, 0)
MeshPart292.Transparency = 1
MeshPart292.Size = Vector3.new(0.0829999968, 0.107000001, 0.0829999968)
MeshPart292.BrickColor = BrickColor.new("Deep orange")
MeshPart292.Material = Enum.Material.Metal
MeshPart292.brickColor = BrickColor.new("Deep orange")
MeshPart292.TextureID = "rbxassetid://2794275376"
Sound293.Name = "CasingHitSound"
Sound293.Parent = MeshPart292
Sound293.EmitterSize = 1
Sound293.MinDistance = 1
Sound293.SoundId = "rbxassetid://3909012115"
Sound293.Volume = 1
LocalScript294.Name = "ClientWeaponsScript"
LocalScript294.Parent = Folder185
table.insert(cors,sandbox(LocalScript294,function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local playerChildAddedConnection
local replicatedStorageChildAddedConnection
local clientWeaponsScript
local weaponsSystemFolder

local function setupWeaponsSystem()
	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
end

local function onReplicatedStorageChildAdded(child)
	if child.Name == "WeaponsSystem" then
		setupWeaponsSystem()
		replicatedStorageChildAddedConnection:Disconnect()
	end
end

local function onPlayerChildAdded(child)
	if child.Name == "PlayerScripts" then
		clientWeaponsScript.Parent = child
		playerChildAddedConnection:Disconnect()
	end
end

if script.Parent.Name ~= "PlayerScripts" then
	clientWeaponsScript = script:Clone()
	local PlayerScripts = script.Parent.Parent:FindFirstChild("PlayerScripts")
	
	if PlayerScripts ~= nil then
		clientWeaponsScript.Parent = PlayerScripts
	else
		playerChildAddedConnection = script.Parent.Parent.ChildAdded:Connect(onPlayerChildAdded)
	end
else
	weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
	if weaponsSystemFolder ~= nil then
		setupWeaponsSystem()
	else
		replicatedStorageChildAddedConnection = ReplicatedStorage.ChildAdded:Connect(onReplicatedStorageChildAdded)
	end
end
end))
ModuleScript295.Name = "NetworkingCallbacks"
ModuleScript295.Parent = Folder185
table.insert(cors,sandbox(ModuleScript295,function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()
local LocalPlayer = (not IsServer) and Players.LocalPlayer or nil

local NetworkingCallbacks = {}
NetworkingCallbacks.WeaponsSystem = nil

function NetworkingCallbacks.WeaponFired(player, instance, fireInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weaponType.CanBeFired and weapon.player == player then
			weapon:onFired(player, fireInfo, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadRequest(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded then
			weapon:reload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloaded(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= nil and player ~= LocalPlayer then
			weapon:onReloaded(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadCanceled(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= LocalPlayer then
			weapon:cancelReload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponHit(player, instance, hitInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanHit then
			if IsServer then
				weapon:onHit(hitInfo)
			end
		end
	end
end

function NetworkingCallbacks.WeaponActivated(player, instance, activated)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weapon.player == player then
			weapon:setActivated(activated, true)
		end
	end
end

return NetworkingCallbacks

end))
Folder296.Name = "WeaponTypes"
Folder296.Parent = Folder185
ModuleScript297.Name = "BowWeapon"
ModuleScript297.Parent = Folder296
table.insert(cors,sandbox(ModuleScript297,function()
local RunService = game:GetService("RunService")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent

local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local BulletWeapon = require(WeaponTypes:WaitForChild("BulletWeapon"))

local BowWeapon = {}
BowWeapon.__index = BowWeapon
setmetatable(BowWeapon, BulletWeapon)

BowWeapon.CanAimDownSights = true
BowWeapon.CanBeFired = true
BowWeapon.CanBeReloaded = true
BowWeapon.CanHit = true

function BowWeapon.new(weaponsSystem, instance)
	local self = BulletWeapon.new(weaponsSystem, instance)
	setmetatable(self, BowWeapon)

	self.hasArrow = true

	self.arrowPart = self.instance:FindFirstChild("Arrow", true)
	self.armsPart = self.instance:FindFirstChild("Arms", true)
	if self.armsPart then
		self.armsMesh = self.armsPart:FindFirstChildOfClass("SpecialMesh")

		self.tightOffsetValue = self.armsPart:FindFirstChild("TightOffset")
		self.tightScaleValue = self.armsPart:FindFirstChild("TightScale")

		self.looseOffsetValue = self.armsPart:FindFirstChild("LooseOffset")
		self.looseScaleValue = self.armsPart:FindFirstChild("LooseScale")

		self.leftLooseAttach = self.armsPart:FindFirstChild("LeftLoose")
		self.rightLooseAttach = self.armsPart:FindFirstChild("RightLoose")

		self.leftTightAttach = self.armsPart:FindFirstChild("LeftTight")
		self.rightTightAttach = self.armsPart:FindFirstChild("RightTight")

		self.leftString0 = self.armsPart:FindFirstChild("LeftString0")
		self.rightString0 = self.armsPart:FindFirstChild("RightString0")
	end

	self.string1 = self.instance:FindFirstChild("String1", true)
	self.stringLooseAttach = self.instance:FindFirstChild("StringLoose", true)
	self.stringTightAttach = self.instance:FindFirstChild("StringTight", true)

	self:setHasArrow(false)

	return self
end

function BowWeapon:renderCharge()
	if self.armsMesh and self.looseOffsetValue and self.looseScaleValue and self.tightOffsetValue and self.tightScaleValue then
		local looseOffset, tightOffset = self.looseOffsetValue.Value, self.tightOffsetValue.Value
		local looseScale, tightScale = self.looseScaleValue.Value, self.tightScaleValue.Value

		self.armsMesh.Offset = looseOffset:Lerp(tightOffset, self.charge)
		self.armsMesh.Scale = looseScale:Lerp(tightScale, self.charge)
	end

	if self.leftString0 and self.leftLooseAttach and self.leftTightAttach then
		self.leftString0.CFrame = self.leftLooseAttach.CFrame:lerp(self.leftTightAttach.CFrame, self.charge)
	end
	if self.rightString0 and self.rightLooseAttach and self.rightTightAttach then
		self.rightString0.CFrame = self.rightLooseAttach.CFrame:lerp(self.rightTightAttach.CFrame, self.charge)
	end

	if self.string1 and self.stringLooseAttach and self.stringTightAttach then
		self.string1.CFrame = self.stringLooseAttach.CFrame:lerp(self.stringTightAttach.CFrame, self.charge)
	end
end

function BowWeapon:handleCharging(dt)
	if self.hasArrow then return end
	BulletWeapon.handleCharging(self, dt)

	if self.charge >= 1 then
		self:setHasArrow(true)
	end
end

function BowWeapon:onActivatedChanged()
	if not IsServer then
		if not self.activated then
			if self.didFire then
				self.didFire = false
			end
		end
	end
	BulletWeapon.onActivatedChanged(self)
end

function BowWeapon:isCharged()
	return self.hasArrow and self.charge >= 1
end

function BowWeapon:doLocalFire()
	BulletWeapon.doLocalFire(self)
	self:setHasArrow(false)
	self.didFire = true
end

function BowWeapon:setHasArrow(hasArrow)
	if self.hasArrow == hasArrow then
		return
	end

	self.hasArrow = hasArrow
	if self.arrowPart then
		self.arrowPart.Transparency = self.hasArrow and 0 or 1
	end
end

return BowWeapon
end))
ModuleScript298.Name = "BulletWeapon"
ModuleScript298.Parent = Folder296
table.insert(cors,sandbox(ModuleScript298,function()
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local ContextActionService = game:GetService("ContextActionService")
local CollectionService = game:GetService("CollectionService")
local ContentProvider = game:GetService("ContentProvider")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local BaseWeapon = require(Libraries:WaitForChild("BaseWeapon"))
local Parabola = require(Libraries:WaitForChild("Parabola"))
local Roblox = require(Libraries:WaitForChild("Roblox"))

local Effects = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Effects")
local ShotsFolder = Effects:WaitForChild("Shots")
local HitMarksFolder = Effects:WaitForChild("HitMarks")
local CasingsFolder = Effects:WaitForChild("Casings")

local NO_BULLET_DECALS = false
local NO_BULLET_CASINGS = false

--The ignore list will fill up over time. This is how many seconds it will go before
--being refreshed in order to keep it from filling up with instances that aren't in
--the datamodel anymore.
local IGNORE_LIST_LIFETIME = 5

local MAX_BULLET_TIME = 10

local localRandom = Random.new()
local localPlayer = not IsServer and Players.LocalPlayer

local BulletWeapon = {}
BulletWeapon.__index = BulletWeapon
setmetatable(BulletWeapon, BaseWeapon)

BulletWeapon.CanAimDownSights = true
BulletWeapon.CanBeFired = true
BulletWeapon.CanBeReloaded = true
BulletWeapon.CanHit = true

function BulletWeapon.new(weaponsSystem, instance)
	local self = BaseWeapon.new(weaponsSystem, instance)
	setmetatable(self, BulletWeapon)

	self.usesCharging = false
	self.charge = 0
	self.chargeSoundPitchMin = 0.5
	self.chargeSoundPitchMax = 1

	self.triggerDisconnected = false
	self.startupFinished = false -- TODO: make startup time use a configuration value
	self.burstFiring = false
	self.burstIdx = 0
	self.nextFireTime = 0

	self.recoilIntensity = 0
	self.aimPoint = Vector3.new()

	self:addOptionalDescendant("tipAttach", "TipAttachment")

	self:addOptionalDescendant("boltMotor", "BoltMotor")
	self:addOptionalDescendant("boltMotorStart", "BoltMotorStart")
	self:addOptionalDescendant("boltMotorTarget", "BoltMotorTarget")

	self:addOptionalDescendant("chargeGlowPart", "ChargeGlow")
	self:addOptionalDescendant("chargeCompleteParticles", "ChargeCompleteParticles")
	self:addOptionalDescendant("dischargeCompleteParticles", "DischargeCompleteParticles")

	self:addOptionalDescendant("muzzleFlash0", "MuzzleFlash0")
	self:addOptionalDescendant("muzzleFlash1", "MuzzleFlash1")
	self:addOptionalDescendant("muzzleFlashBeam", "MuzzleFlash")

	self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))

	self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
	self:addOptionalDescendant("casingEjectPoint", "CasingEjectPoint")

	self.ignoreList = {}
	self.ignoreListRefreshTime = 0

	self:addOptionalDescendant("handAttach", "LeftHandAttachment")
	self.handAlignPos = nil
	self.handAlignRot = nil

	self.chargingParticles = {}
	self.instance.DescendantAdded:Connect(function(descendant)
		if descendant.Name == "ChargingParticles" and descendant:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, descendant)
		end
	end)
	for _, v in pairs(self.instance:GetDescendants()) do
		if v.Name == "ChargingParticles" and v:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, v)
		end
	end

	self:doInitialSetup()

	return self
end

function BulletWeapon:onEquippedChanged()
	BaseWeapon.onEquippedChanged(self)

	if not IsServer then
		if self.weaponsSystem.camera then
			if self.equipped then
				self.startupFinished = false
			end
		end

		if self.equipped then
			ContextActionService:BindAction("ReloadWeapon", function(...) self:onReloadAction(...) end, false, Enum.KeyCode.R, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindAction("ReloadWeapon")

			-- Stop charging/discharging sounds
			local chargingSound = self:getSound("Charging")
			local dischargingSound = self:getSound("Discharging")
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
		end

		self.triggerDisconnected = false
	end
end

function BulletWeapon:onReloadAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin and not self.reloading then
		self:reload()
	end
end

function BulletWeapon:animateBoltAction(isOpen)
	if not self.boltMotor or not self.boltMotorStart or not self.boltMotorTarget then
		return
	end

	if isOpen then
		self:tryPlaySound("BoltOpenSound")
	else
		self:tryPlaySound("BoltCloseSound")
	end

	local actionMoveTime = isOpen and self:getConfigValue("ActionOpenTime", 0.025) or self:getConfigValue("ActionCloseTime", 0.075)
	local targetCFrame = isOpen and self.boltMotorTarget.CFrame or self.boltMotorStart.CFrame

	local boltTween = TweenService:Create(self.boltMotor, TweenInfo.new(actionMoveTime, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { C0 = targetCFrame })
	boltTween:Play()
	boltTween.Completed:Wait()
end

function BulletWeapon:getRandomSeedForId(id)
	return id
end

-- This function is only called on clients
function BulletWeapon:simulateFire(firingPlayer, fireInfo)
	BaseWeapon.simulateFire(self, fireInfo)

	-- Play "Fired" sound
	if self.lastFireSound then
		self.lastFireSound:Stop()
	end
	self.lastFireSound = self:tryPlaySound("Fired", self:getConfigValue("FiredPlaybackSpeedRange", 0.1))

	-- Simulate each projectile/bullet fired from current weapon
	local numProjectiles = self:getConfigValue("NumProjectiles", 1)
	local randomGenerator = Random.new(self:getRandomSeedForId(fireInfo.id))
	for i = 1, numProjectiles do
		self:simulateProjectile(firingPlayer, fireInfo, i, randomGenerator)
	end

	-- Animate the bolt if the current gun has one
	local actionOpenTime = self:getConfigValue("ActionOpenTime", 0.025)
	if self.boltMotor then
		coroutine.wrap(function()
			self:animateBoltAction(true)
			wait(actionOpenTime)
			self:animateBoltAction(false)
		end)()
	end

	-- Eject bullet casings and play "CasingHitSound" (child of casing) sound if applicable for current weapon
	if not NO_BULLET_CASINGS and self.casingTemplate and self.casingEjectPoint then
		local casing = self.casingTemplate:Clone()
		casing.Anchored = false
		casing.Archivable = false
		casing.CFrame = self.casingEjectPoint.WorldCFrame
		casing.Velocity = self.casingEjectPoint.Parent.Velocity + (self.casingEjectPoint.WorldAxis * localRandom:NextNumber(self:getConfigValue("CasingEjectSpeedMin", 15), self:getConfigValue("CasingEjectSpeedMax", 18)))
		casing.Parent = workspace.CurrentCamera
		CollectionService:AddTag(casing, "WeaponsSystemIgnore")

		local casingHitSound = casing:FindFirstChild("CasingHitSound")
		if casingHitSound then
			local touchedConn = nil
			touchedConn = casing.Touched:Connect(function(hitPart)
				if not hitPart:IsDescendantOf(self.instance) then
					casingHitSound:Play()
					touchedConn:Disconnect()
					touchedConn = nil
				end
			end)
		end

		Debris:AddItem(casing, 2)
	end

	if self.player == Players.LocalPlayer then
		coroutine.wrap(function()
			-- Wait for "RecoilDelayTime" before adding recoil
			local startTime = tick()
			local recoilDelayTime = self:getConfigValue("RecoilDelayTime", 0.07)
			while tick() < startTime + recoilDelayTime do
				RunService.RenderStepped:Wait()
			end
			RunService.RenderStepped:Wait()

			-- Add recoil to camera
			local recoilMin, recoilMax = self:getConfigValue("RecoilMin", 0.05), self:getConfigValue("RecoilMax", 0.5)
			local intensityToAdd = randomGenerator:NextNumber(recoilMin, recoilMax)
			local xIntensity = math.sin(tick() * 2) * intensityToAdd * math.rad(0.05)
			local yIntensity = intensityToAdd * 0.025
			self.weaponsSystem.camera:addRecoil(Vector2.new(xIntensity, yIntensity))

			if not (self.weaponsSystem.camera:isZoomed() and self:getConfigValue("HasScope", false)) then
				self.recoilIntensity = math.clamp(self.recoilIntensity * 1 + (intensityToAdd / 10), 0.005, 1)
			end

			-- Make crosshair reflect recoil/spread amount
			local weaponsGui = self.weaponsSystem.gui
			if weaponsGui then
				weaponsGui:setCrosshairScale(1 + intensityToAdd)
			end
		end)()
	end
end

function BulletWeapon:getIgnoreList(includeLocalPlayer)
	local now = tick()
	local ignoreList = self.ignoreList
	if not ignoreList or now - self.ignoreListRefreshTime > IGNORE_LIST_LIFETIME then
		ignoreList = {
			self.instanceIsTool and self.instance.Parent or self.instance,
			workspace.CurrentCamera
		}
		if not RunService:IsServer() then
			if includeLocalPlayer and Players.LocalPlayer and Players.LocalPlayer.Character then
				table.insert(ignoreList, Players.LocalPlayer.Character)
			end
		end
		self.ignoreList = ignoreList
	end
	return ignoreList
end

-- This function is only called on clients
function BulletWeapon:simulateProjectile(firingPlayer, fireInfo, projectileIdx, randomGenerator)
	local localPlayerInitiatedShot = self.player == Players.LocalPlayer

	-- Retrieve config values
	local bulletSpeed = self:getConfigValue("BulletSpeed", 1000)
	local maxDistance = self:getConfigValue("MaxDistance", 2000)
	local trailLength = self:getConfigValue("TrailLength", nil)
	local trailLengthFactor = self:getConfigValue("TrailLengthFactor", 1)
	local showEntireTrailUntilHit = self:getConfigValue("ShowEntireTrailUntilHit", false)
	local gravityFactor = self:getConfigValue("GravityFactor", 0)
	local minSpread = self:getConfigValue("MinSpread", 0)
	local maxSpread = self:getConfigValue("MaxSpread", 0)
	local shouldMovePart = self:getConfigValue("ShouldMovePart", false)
	local explodeOnImpact = self:getConfigValue("ExplodeOnImpact", false)
	local blastRadius = self:getConfigValue("BlastRadius", 8)

	-- Cheat the origin of the shot back if gun tip in wall/object
	if self.tipAttach ~= nil then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local tipDir = tipCFrame.LookVector
		local amountToCheatBack = math.abs((self.instance:FindFirstChild("Handle").Position - tipPos):Dot(tipDir)) + 1
		local gunRay = Ray.new(tipPos - tipDir.Unit * amountToCheatBack, tipDir.Unit * amountToCheatBack)
		local hitPart, hitPoint = Roblox.penetrateCast(gunRay, self:getIgnoreList(localPlayerInitiatedShot))
		if hitPart and math.abs((tipPos - hitPoint).Magnitude) > 0 then
			fireInfo.origin = hitPoint - tipDir.Unit * 0.1
			fireInfo.dir = tipDir.Unit
		end
	end

	local origin, dir = fireInfo.origin, fireInfo.dir

	dir = Roblox.applySpread(dir, randomGenerator, math.rad(minSpread), math.rad(maxSpread))

	-- Initialize variables for visuals/particle effects
	local bulletEffect = self.bulletEffectTemplate:Clone()
	bulletEffect.CFrame = CFrame.new(origin, origin + dir)
	bulletEffect.Parent = workspace.CurrentCamera
	CollectionService:AddTag(bulletEffect, "WeaponsSystemIgnore")

	local leadingParticles = bulletEffect:FindFirstChild("LeadingParticles", true)
	local attachment0 = bulletEffect:FindFirstChild("Attachment0")
	local trailParticles = nil
	if attachment0 then
		trailParticles = attachment0:FindFirstChild("TrailParticles")
	end

	local hitAttach = bulletEffect:FindFirstChild("HitEffect")
	local hitParticles = bulletEffect:FindFirstChild("HitParticles", true)
	local numHitParticles = self:getConfigValue("NumHitParticles", 3)
	local hitSound = bulletEffect:FindFirstChild("HitSound", true)
	local flyingSound = bulletEffect:FindFirstChild("Flying", true)

	local muzzleFlashTime = self:getConfigValue("MuzzleFlashTime", 0.03)
	local muzzleFlashShown = false

	local beamThickness0 = self:getConfigValue("BeamWidth0", 1.5)
	local beamThickness1 = self:getConfigValue("BeamWidth1", 1.8)
	local beamFadeTime = self:getConfigValue("BeamFadeTime", nil)

	-- Enable beam trails for projectile
	local beam0 = bulletEffect:FindFirstChild("Beam0")
	if beam0 then
		beam0.Enabled = true
	end
	local beam1 = bulletEffect:FindFirstChild("Beam1")
	if beam1 then
		beam1.Enabled = true
	end

	-- Emit muzzle particles
	local muzzleParticles = bulletEffect:FindFirstChild("MuzzleParticles", true)
	local numMuzzleParticles = self:getConfigValue("NumMuzzleParticles", 50)
	if muzzleParticles then
		muzzleParticles.Parent.CFrame = CFrame.new(origin, origin + dir)
		local numSteps = 5
		for _ = 1, numSteps do
			muzzleParticles.Parent.Velocity = Vector3.new(localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10))
			muzzleParticles:Emit(numMuzzleParticles / numSteps)
		end
	end

	-- Show muzzle flash
	if self.tipAttach and self.muzzleFlash0 and self.muzzleFlash1 and self.muzzleFlashBeam and projectileIdx == 1 then
		local minFlashRotation, maxFlashRotation = self:getConfigValue("MuzzleFlashRotation0", -math.pi), self:getConfigValue("MuzzleFlashRotation1", math.pi)
		local minFlashSize, maxFlashSize = self:getConfigValue("MuzzleFlashSize0", 1), self:getConfigValue("MuzzleFlashSize1", 1)
		local flashRotation = localRandom:NextNumber(minFlashRotation, maxFlashRotation)
		local flashSize = localRandom:NextNumber(minFlashSize, maxFlashSize)
		local baseCFrame = self.tipAttach.CFrame * CFrame.Angles(0, 0, flashRotation)
		self.muzzleFlash0.CFrame = baseCFrame * CFrame.new(flashSize * -0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)
		self.muzzleFlash1.CFrame = baseCFrame * CFrame.new(flashSize * 0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)

		self.muzzleFlashBeam.Enabled = true
		self.muzzleFlashBeam.Width0 = flashSize
		self.muzzleFlashBeam.Width1 = flashSize
		muzzleFlashShown = true
	end

	-- Play projectile flying sound
	if flyingSound then
		flyingSound:Play()
	end

	-- Enable trail particles
	if trailParticles then
		trailParticles.Enabled = true
	end

	-- Set up parabola for projectile path
	local parabola = Parabola.new()
	parabola:setPhysicsLaunch(origin, dir * bulletSpeed, nil, 35 * -gravityFactor)
	-- More samples for higher gravity since path will be more curved but raycasts can only be straight lines
	if gravityFactor > 0.66 then
		parabola:setNumSamples(3)
	elseif gravityFactor > 0.33 then
		parabola:setNumSamples(2)
	else
		parabola:setNumSamples(1)
	end

	-- Set up/initialize variables used in steppedCallback
	local stepConn = nil
	local pTravelDistance = 0 -- projected travel distance so far if projectile never stops
	local startTime = tick()
	local didHit = false
	local stoppedMotion = false
	local stoppedMotionAt = 0
	local timeSinceStart = 0
	local flyingVisualEffectsFinished = false -- true if all particle effects shown while projectile is flying are done
	local visualEffectsFinishTime = math.huge
	local visualEffectsLingerTime = 0 -- max time any visual effect needs to finish
	if beamFadeTime then
		visualEffectsLingerTime = beamFadeTime
	end
	local hitInfo = {
		sid = fireInfo.id,
		pid = projectileIdx,
		maxDist = maxDistance,
		part = nil,
		p = nil,
		n = nil,
		m = Enum.Material.Air,
		d = 1e9,
	}

	local steppedCallback = function(dt)
		local now = tick()
		timeSinceStart = now - startTime

		local travelDist = bulletSpeed * dt -- distance projectile has travelled since last frame
		trailLength = trailLength or travelDist * trailLengthFactor

		-- Note: the next three variables are all in terms of distance from starting point (which should be tip of current weapon)
		local projBack = pTravelDistance - trailLength -- furthest back part of projectile (including the trail effect, so will be the start of the trail effect if any)
		local projFront = pTravelDistance -- most forward part of projectile
		local maxDist = hitInfo.maxDist or 0 -- before it collides, this is the max distance the projectile can travel. After it collides, this is the hit point

		-- This will make trailing beams render from tip of gun to wherever projectile is until projectile is destroyed
		if showEntireTrailUntilHit then
			projBack = 0
		end

		-- Validate projBack and projFront
		projBack = math.clamp(projBack, 0, maxDist)
		projFront = math.clamp(projFront, 0, maxDist)

		if not didHit then
			-- Check if bullet hit since last frame
			local castProjBack, castProjFront = projFront, projFront + travelDist
			parabola:setDomain(castProjBack, castProjFront)
			local hitPart, hitPoint, hitNormal, hitMaterial, hitT = parabola:findPart(self.ignoreList)

			if hitPart then
				didHit = true
				projFront = castProjBack + hitT * (castProjFront - castProjBack) -- set projFront to point along projectile arc where an object was hit
				parabola:setDomain(projBack, projFront) -- update parabola domain to match new projFront

				-- Update hitInfo
				hitInfo.part = hitPart
				hitInfo.p = hitPoint
				hitInfo.n = hitNormal
				hitInfo.m = hitMaterial
				hitInfo.d = (hitPoint - origin).Magnitude
				hitInfo.t = hitT
				hitInfo.maxDist = projFront -- since the projectile hit, maxDist is now the hitPoint instead of maxDistance

				-- Register hit on clients
				self:onHit(hitInfo)

				-- Notify the server that this projectile hit something from client that initiated the shot
				-- Show hit indicators on gui of client that shot projectile
				if localPlayerInitiatedShot then
					local hitInfoClone = {}
					for hitInfoKey, value in pairs(hitInfo) do
						hitInfoClone[hitInfoKey] = value
					end
					self.weaponsSystem.getRemoteEvent("WeaponHit"):FireServer(self.instance, hitInfoClone)
				end


				-- Deal with all effects that start/stop/change on hit

				-- Disable trail particles
				if trailParticles then
					trailParticles.Enabled = false
				end

				-- Stop bullet flying sound
				if flyingSound and flyingSound.IsPlaying then
					flyingSound:Stop()
				end

				-- Hide the actual projectile model
				if bulletEffect then
					bulletEffect.Transparency = 1
				end

				-- Stop emitting leading particles
				if leadingParticles then
					leadingParticles.Rate = 0
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, leadingParticles.Lifetime.Max)
				end

				-- Show the explosion on clients for explosive projectiles
				if explodeOnImpact then
					local explosion = Instance.new("Explosion")
					explosion.Position = hitPoint + (hitNormal * 0.5)
					explosion.BlastRadius = blastRadius
					explosion.BlastPressure = 0 -- no blast pressure because the real explosion happens on server
					explosion.ExplosionType = Enum.ExplosionType.NoCraters
					explosion.DestroyJointRadiusPercent = 0
					explosion.Visible = true
					if localPlayerInitiatedShot then
						-- Trigger hit indicators on client that initiated the shot if the explosion hit another player/humanoid
						explosion.Hit:Connect(function(explodedPart, hitDist)
							local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
							if humanoid and
							   explodedPart.Name == "UpperTorso" and
							   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
							   self.weaponsSystem.gui and
							   explodedPart.Parent ~= self.player.Character and
							   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
							then
								self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), humanoid)
							end
						end)
					end
					explosion.Parent = workspace
				end

				-- Make sure hitAttach is in correct position before showing hit effects
				if hitAttach and beam0 and beam0.Attachment1 then
					parabola:renderToBeam(beam0)
					hitAttach.CFrame = beam0.Attachment1.CFrame * CFrame.Angles(0, math.rad(90), 0)
				end

				-- Show hit particle effect
				local hitPartColor = hitPart and hitPart.Color or Color3.fromRGB(255, 255, 255)
				if hitPart and hitPart:IsA("Terrain") then
					hitPartColor = workspace.Terrain:GetMaterialColor(hitMaterial or Enum.Material.Sand)
				end
				if hitInfo.h and hitInfo.h:IsA("Humanoid") and hitParticles and numHitParticles > 0 and hitPart then
					-- Show particle effect for hitting a player/humanoid
					hitParticles.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				elseif (not hitInfo.h or not hitInfo.h:IsA("Humanoid")) and hitParticles and numHitParticles > 0 then
					-- Show particle effect for hitting anything else
					if hitPart and self:getConfigValue("HitParticlesUsePartColor", true) then
						local existingSeq = hitParticles.Color
						local newKeypoints = {}

						for i, keypoint in pairs(existingSeq.Keypoints) do
							local newColor = keypoint.Value
							if newColor == Color3.fromRGB(255, 0, 255) then
								newColor = hitPartColor
							end
							newKeypoints[i] = ColorSequenceKeypoint.new(keypoint.Time, newColor)
						end

						hitParticles.Color = ColorSequence.new(newKeypoints)
					end

					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				end

				-- Play hit sound
				if hitSound then
					hitSound:Play()
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitSound.TimeLength)
				end

				-- Manage/show decals, billboards, and models (such as an arrow) that appear where the projectile hit (only if the hit object was not a humanoid/player)
				local hitPointObjectSpace = hitPart.CFrame:pointToObjectSpace(hitPoint)
				local hitNormalObjectSpace = hitPart.CFrame:vectorToObjectSpace(hitNormal)
				if not NO_BULLET_DECALS and
				   hitPart and
				   not hitPart.Parent or not hitPart.Parent:FindFirstChildOfClass("Humanoid") and
				   hitPointObjectSpace and
				   hitNormalObjectSpace and
				   self.hitMarkTemplate
				then
					-- Clone hitMark (this contains all the decals/billboards/models to show on the hit surface)
					local hitMark = self.hitMarkTemplate:Clone()
					hitMark.Parent = hitPart
					CollectionService:AddTag(hitMark, "WeaponsSystemIgnore")

					-- Move/align hitMark to the hit surface
					local incomingVec = parabola:sampleVelocity(1).Unit
					if self:getConfigValue("AlignHitMarkToNormal", true) then
						-- Make hitMark face straight out from surface where projectile hit (good for decals)
						local forward = hitNormalObjectSpace
						local up = incomingVec
						local right = -forward:Cross(up).Unit
						up = forward:Cross(right)
						local orientationCFrame = CFrame.fromMatrix(hitPointObjectSpace + hitNormalObjectSpace * 0.05, right, up, -forward)
						hitMark.CFrame = hitPart.CFrame:toWorldSpace(orientationCFrame)
					else
						-- Make hitmark appear stuck in the hit surface from the direction the projectile came from (good for things like arrows)
						hitMark.CFrame = hitPart.CFrame * CFrame.new(hitPointObjectSpace, hitPointObjectSpace + hitPart.CFrame:vectorToObjectSpace(incomingVec))
					end

					-- Weld hitMark to the hitPart
					local weld = Instance.new("WeldConstraint")
					weld.Part0 = hitMark
					weld.Part1 = hitPart
					weld.Parent = hitMark

					-- Fade glow decal over time
					local glowDecal = hitMark:FindFirstChild("Glow")
					if glowDecal then
						coroutine.wrap(function()
							local heartbeat = RunService.Heartbeat
							for i = 0, 1, 1/60 do
								heartbeat:Wait()
								glowDecal.Transparency = (i ^ 2)
							end
						end)()
					end

					-- Set bullethole decal color and fade over time
					local bulletHole = hitMark:FindFirstChild("BulletHole")
					if bulletHole then
						bulletHole.Color3 = hitPartColor
						TweenService:Create(
							bulletHole,
							TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 4),
							{ Transparency = 1 }
						):Play()
					end

					-- Fade impact billboard's size and transparency over time
					local impactBillboard = hitMark:FindFirstChild("ImpactBillboard")
					if impactBillboard then
						local impact = impactBillboard:FindFirstChild("Impact")
						local impactTween = TweenService:Create(
							impact,
							TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
							{ Size = UDim2.new(1, 0, 1, 0) }
						)
						impactTween.Completed:Connect(function()
							TweenService:Create(
								impact,
								TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
								{ Size = UDim2.new(0.5, 0, 0.5, 0), ImageTransparency = 1 }
							):Play()
						end)
						impactTween:Play()
					end

					-- Destroy hitMark in 5 seconds
					Debris:AddItem(hitMark, 5)
				end

				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Will enter this if-statement if projectile hit something or maxDistance has been reached
		if projFront >= maxDist then
			if not stoppedMotion then
				stoppedMotion = true
				stoppedMotionAt = now
			end

			-- Stop particle effects if projectile didn't hit anything and projBack has reached the end
			if projBack >= maxDist and not flyingVisualEffectsFinished then
				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Update parabola domain
		parabola:setDomain(projBack, projFront)

		-- Continue updating pTravelDistance until projBack has reached maxDist (this helps with some visual effects)
		if projBack < maxDist then
			pTravelDistance = math.max(0, timeSinceStart * bulletSpeed)
		end


		-- Update visual effects each frame

		-- Update CFrame/velocity of projectile if the projectile uses a model (such as rocket or grenade)
		if shouldMovePart then
			local bulletPos = parabola:samplePoint(1)
			local bulletVelocity = parabola:sampleVelocity(1)
			bulletEffect.CFrame = CFrame.new(bulletPos, bulletPos + bulletVelocity)
			bulletEffect.Velocity = bulletVelocity.Unit * bulletSpeed
		end

		-- Update thickness and render trailing beams
		local thickness0 = beamThickness0
		local thickness1 = beamThickness1
		if beamFadeTime then
			-- Fade out trail beams if projectile is no longer moving (hit something or reached max distance)
			local timeSinceEnd = stoppedMotion and (now - stoppedMotionAt) or 0
			local fadeAlpha = math.clamp(timeSinceEnd / beamFadeTime, 0, 1)
			thickness0 = thickness0 * (1 - fadeAlpha)
			thickness1 = thickness1 * (1 - fadeAlpha)
		end
		if beam0 then
			beam0.Width0 = thickness0
			beam0.Width1 = thickness1
			parabola:renderToBeam(beam0)
		end
		if beam1 then
			beam1.Width0 = thickness0
			beam1.Width1 = thickness1
			parabola:renderToBeam(beam1)
		end

		-- Disable muzzle flash after muzzleFlashTime seconds have passed
		if muzzleFlashShown and timeSinceStart > muzzleFlashTime and self.muzzleFlashBeam then
			self.muzzleFlashBeam.Enabled = false
			muzzleFlashShown = false
		end

		-- Destroy projectile and attached visual effects when visual effects are done showing or max bullet time has been reached
		local timeSinceParticleEffectsFinished = now - visualEffectsFinishTime
		if (flyingVisualEffectsFinished and timeSinceParticleEffectsFinished > 0) or timeSinceStart > MAX_BULLET_TIME then
			if bulletEffect then
				bulletEffect:Destroy()
				bulletEffect = nil
			end

			stepConn:Disconnect()
		end
	end

	stepConn = RunService.Heartbeat:Connect(steppedCallback)

	-- Get rid of charge on chargeable weapons
	if not IsServer and self.usesCharging then
		self.charge = math.clamp(self.charge - self:getConfigValue("FireDischarge", 1), 0, 1)
	end
end

function BulletWeapon:calculateDamage(travelDistance)
	local zeroDamageDistance = self:getConfigValue("ZeroDamageDistance", 10000)
	local fullDamageDistance = self:getConfigValue("FullDamageDistance", 1000)
	local distRange = zeroDamageDistance - fullDamageDistance
	local falloff = math.clamp(1 - (math.max(0, travelDistance - fullDamageDistance) / math.max(1, distRange)), 0, 1)
	return math.max(self:getConfigValue("HitDamage", 10) * falloff, 0)
end

function BulletWeapon:applyDamage(hitInfo)
	local damage = self:calculateDamage(hitInfo.d)

	if damage <= 0 then
		return
	end

	self.weaponsSystem.doDamage(hitInfo.h, damage, nil, self.player)
end

function BulletWeapon:onHit(hitInfo)
	local hitPoint = hitInfo.p
	local hitNormal = hitInfo.n
	local hitPart = hitInfo.part

	if hitPart and hitPart.Parent then
		local humanoid = self.weaponsSystem.getHumanoid(hitPart)
		hitInfo.h = humanoid or hitPart

		if IsServer and
		   (not hitInfo.h:IsA("Humanoid") or
		   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player))
		then
			self:applyDamage(hitInfo)
		elseif hitInfo.h:IsA("Humanoid") and
			hitInfo.h:GetState() ~= Enum.HumanoidStateType.Dead and
			self.weaponsSystem.gui and
			self.player == Players.LocalPlayer and
			self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player)
		then
			-- Show hit indicators on gui of client that shot projectile if players are not on same team
			self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), hitInfo.h)
		end
	end

	-- Create invisible explosion on server that deals damage to anything caught in the explosion
	if IsServer and self:getConfigValue("ExplodeOnImpact", false) then
		local blastRadius = self:getConfigValue("BlastRadius", 8)
		local blastPressure = self:getConfigValue("BlastPressure", 10000)
		local blastDamage = self:getConfigValue("BlastDamage", 100)

		local explosion = Instance.new("Explosion")
		explosion.Position = hitPoint + (hitNormal * 0.5)
		explosion.BlastRadius = blastRadius
		explosion.BlastPressure = blastPressure
		explosion.ExplosionType = Enum.ExplosionType.NoCraters
		explosion.DestroyJointRadiusPercent = 0
		explosion.Visible = false

		explosion.Hit:Connect(function(explodedPart, hitDist)
			local damageMultiplier = (1 - math.clamp((hitDist / blastRadius), 0, 1))
			local damageToDeal = blastDamage * damageMultiplier

			local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
			if humanoid then
				if explodedPart.Name == "UpperTorso" and
				   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
				   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
				then
					-- Do damage to players/humanoids
					self.weaponsSystem.doDamage(humanoid, damageToDeal, nil, self.player)
				end
			elseif not CollectionService:HasTag(explodedPart, "WeaponsSystemIgnore") then
				-- Do damage to a part (sends damage to breaking system)
				self.weaponsSystem.doDamage(explodedPart, damageToDeal, nil, self.player)
			end
		end)

		explosion.Parent = workspace
	end
end

function BulletWeapon:fire(origin, dir, charge)
	if not self:isCharged() then
		return
	end

	BaseWeapon.fire(self, origin, dir, charge)
end

function BulletWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer and firingPlayer == Players.LocalPlayer and fromNetwork then
		return
	end

	local cooldownTime = self:getConfigValue("ShotCooldown", 0.1)
	local fireMode = self:getConfigValue("FireMode", "Semiautomatic")
	local isSemiAuto = fireMode == "Semiautomatic"
	local isBurst = fireMode == "Burst"

	if isBurst and not self.burstFiring then
		self.burstIdx = 0
		self.burstFiring = true
	elseif isSemiAuto then
		self.triggerDisconnected = true
	end

	-- Calculate cooldown time for burst firing
	if self.burstFiring then
		self.burstIdx = self.burstIdx + 1
		if self.burstIdx >= self:getConfigValue("NumBurstShots", 3) then
			self.burstFiring = false
			self.triggerDisconnected = true
		else
			cooldownTime = self:getConfigValue("BurstShotCooldown", nil) or cooldownTime
		end
	end

	self.nextFireTime = tick() + cooldownTime

	BaseWeapon.onFired(self, firingPlayer, fireInfo, fromNetwork)
end

function BulletWeapon:onConfigValueChanged(valueName, newValue, oldValue)
	BaseWeapon.onConfigValueChanged(self, valueName, newValue, oldValue)
	if valueName == "ShotEffect" then
		self.bulletEffectTemplate = ShotsFolder:FindFirstChild(self:getConfigValue("ShotEffect", "Bullet"))
		if self.bulletEffectTemplate then
			local config = self.bulletEffectTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end

			local beam0 = self.bulletEffectTemplate:FindFirstChild("Beam0")
			if beam0 then
				coroutine.wrap(function()
					ContentProvider:PreloadAsync({ beam0 })
				end)()
			end
		end
	elseif valueName == "HitMarkEffect" then
		self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))
		if self.hitMarkTemplate then
			local config = self.hitMarkTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "CasingEffect" then
		self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
		if self.casingTemplate then
			local config = self.casingTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "ChargeRate" then
		self.usesCharging = newValue ~= nil
	end
end

function BulletWeapon:onActivatedChanged()
	BaseWeapon.onActivatedChanged(self)

	if not IsServer then
		-- Reload if no ammo left in clip
		if self.equipped and self:getAmmoInWeapon() <= 0 then
			self:reload()
			return
		end

		-- Fire weapon
		if self.activated and self.player == localPlayer and self:canFire() and tick() > self.nextFireTime then
			self:doLocalFire()
		end

		-- Reenable trigger after activated changes to false
		if not self.activated and self.triggerDisconnected and not self.burstFiring then
			self.triggerDisconnected = false
		end
	end
end

function BulletWeapon:onRenderStepped(dt)
	BaseWeapon.onRenderStepped(self, dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	local tipCFrame = self.tipAttach.WorldCFrame

	if self.player == Players.LocalPlayer then
		-- Retrieve aim point from camera and update player's aim animation
		local aimTrack = self:getAnimTrack(self:getConfigValue("AimTrack", "RifleAim"))
		local aimZoomTrack = self:getAnimTrack(self:getConfigValue("AimZoomTrack", "RifleAimDownSights"))
		if aimTrack then
			local aimDir = tipCFrame.LookVector

			local gunLookRay = Ray.new(tipCFrame.p, aimDir * 500)

			local _, gunHitPoint = Roblox.penetrateCast(gunLookRay, self.ignoreList)

			if self.weaponsSystem.aimRayCallback then
				local _, hitPoint = Roblox.penetrateCast(self.weaponsSystem.aimRayCallback(), self.ignoreList)
				self.aimPoint = hitPoint
			else
				self.aimPoint = gunHitPoint
			end

			if not aimTrack.IsPlaying and not self.reloading then
				aimTrack:Play(0.15)
				coroutine.wrap(function() -- prevent player from firing until gun is fully out
					wait(self:getConfigValue("StartupTime", 0.2))
					self.startupFinished = true
				end)()
			end

			if aimZoomTrack and not self.reloading then
				if not aimZoomTrack.IsPlaying then
					aimZoomTrack:Play(0.15)
				end
				aimZoomTrack:AdjustSpeed(0.001)
				if self.weaponsSystem.camera:isZoomed() then
					if aimTrack.WeightTarget ~= 0 then
						aimZoomTrack:AdjustWeight(1)
						aimTrack:AdjustWeight(0)
					end
				elseif aimTrack.WeightTarget ~= 1 then
					aimZoomTrack:AdjustWeight(0)
					aimTrack:AdjustWeight(1)
				end
			end

			local MIN_ANGLE = -80
			local MAX_ANGLE = 80
			local aimYAngle = math.deg(self.recoilIntensity)
			if self.weaponsSystem.camera.enabled then
				-- Gets pitch and recoil from camera to figure out how high/low to aim the gun
				aimYAngle = math.deg(self.weaponsSystem.camera:getRelativePitch() + self.weaponsSystem.camera.currentRecoil.Y + self.recoilIntensity)
			end
			local aimTimePos = 2 * ((aimYAngle - MIN_ANGLE) / (MAX_ANGLE - MIN_ANGLE))

			aimTrack:AdjustSpeed(0.001)
			aimTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)

			if aimZoomTrack then
				aimZoomTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)
			end

			-- Update recoil (decay over time)
			local recoilDecay = self:getConfigValue("RecoilDecay", 0.825)
			self.recoilIntensity = math.clamp(self.recoilIntensity * recoilDecay, 0, math.huge)
		else
			warn("no aimTrack")
		end
	end
end

function BulletWeapon:setChargingParticles(charge)
	local ratePerCharge = self:getConfigValue("ChargingParticlesRatePerCharge", 20)
	local rate = ratePerCharge * charge
	for _, v in pairs(self.chargingParticles) do
		v.Rate = rate
	end
end

function BulletWeapon:onStepped(dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	BaseWeapon.onStepped(self, dt)

	local now = tick()

	local chargingSound = self:getSound("Charging")
	local dischargingSound = self:getSound("Discharging")

	if self.usesCharging then
		-- Update charge amount
		local chargeBefore = self.charge
		self:handleCharging(dt)
		local chargeDelta = self.charge - chargeBefore

		-- Update charge particles
		if chargeDelta > 0 then
			self:setChargingParticles(self.charge)
		else
			self:setChargingParticles(0)
		end

		-- Play charging sounds
		if chargingSound then
			if chargingSound.Looped then
				if chargeDelta < 0 then
					chargingSound:Stop()
				else
					if not chargingSound.Playing and self.charge < 1 and chargeDelta > 0 then
						chargingSound:Play()
					end
					chargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta > 0 and self.charge <= 1 and not chargingSound.Playing then
					chargingSound.TimePosition = chargingSound.TimeLength * self.charge
					chargingSound:Play()
				elseif chargeDelta <= 0 and chargingSound.Playing then
					chargingSound:Stop()
				end
			end
		end
		if dischargingSound then
			if dischargingSound.Looped then
				if chargeDelta > 0 then
					dischargingSound:Stop()
				else
					if not dischargingSound.Playing and self.charge > 0 then
						dischargingSound:Play()
					end
					dischargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta < 0 and self.charge >= 0 and not dischargingSound.Playing then
					dischargingSound.TimePosition = dischargingSound.TimeLength * self.charge
					dischargingSound:Play()
				elseif chargeDelta >= 0 and dischargingSound.Playing then
					dischargingSound:Stop()
				end
			end
		end

		-- Play charge/discharge completed sounds and particle effects
		if chargeBefore < 1 and self.charge >= 1 then
			local chargeCompleteSound = self:getSound("ChargeComplete")
			if chargeCompleteSound then
				chargeCompleteSound:Play()
			end
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if self.chargeCompleteParticles then
				self.chargeCompleteParticles:Emit(self:getConfigValue("NumChargeCompleteParticles", 25))
			end
		end
		if chargeBefore > 0 and self.charge <= 0 then
			local dischargeCompleteSound = self:getSound("DischargeComplete")
			if dischargeCompleteSound then
				dischargeCompleteSound:Play()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
			if self.dischargeCompleteParticles then
				self.dischargeCompleteParticles:Emit(self:getConfigValue("NumDischargeCompleteParticles", 25))
			end
		end

		self:renderCharge()
	else
		if chargingSound then
			chargingSound:Stop()
		end
		if dischargingSound then
			dischargingSound:Stop()
		end
	end

	if self.usesCharging and self.chargeGlowPart then
		self.chargeGlowPart.Transparency = 1 - self.charge
	end

	-- Fire weapon if it is fully charged
	if self:canFire() and now > self.nextFireTime then
		self:doLocalFire()
	end
end

function BulletWeapon:handleCharging(dt)
	local chargeDelta
	local shouldCharge = self.activated or self.burstFiring or self:getConfigValue("ChargePassively", false)
	if self.reloading or self.triggerDisconnected then
		shouldCharge = false
	end

	if shouldCharge then
		chargeDelta = self:getConfigValue("ChargeRate", 0) * dt
	else
		chargeDelta = self:getConfigValue("DischargeRate", 0) * -dt
	end

	self.charge = math.clamp(self.charge + chargeDelta, 0, 1)
end

function BulletWeapon:isCharged()
	return not self.usesCharging or self.charge >= 1
end

function BulletWeapon:canFire()
	return self.player == Players.LocalPlayer and (self.burstFiring or self.activated) and not self.triggerDisconnected and not self.reloading and self:isCharged() and self.startupFinished
end

function BulletWeapon:doLocalFire()
	if self.tipAttach then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local aimDir = (self.aimPoint - tipPos).Unit

		self:fire(tipPos, aimDir, self.charge)
	end
end

return BulletWeapon

end))
Script299.Name = "ServerWeaponsScript"
Script299.Parent = Folder185
table.insert(cors,sandbox(Script299,function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local curWeaponsSystemFolder = script.Parent
local weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
local weaponsSystemInitialized = false

local function initializeWeaponsSystemAssets()
	if not weaponsSystemInitialized then
		-- Enable/make visible all necessary assets
		local effectsFolder = weaponsSystemFolder.Assets.Effects
		local partNonZeroTransparencyValues = {
			["BulletHole"] = 1, ["Explosion"] = 1, ["Pellet"] = 1, ["Scorch"] = 1,
			["Bullet"] = 1, ["Plasma"] = 1, ["Railgun"] = 1,
		}
		local decalNonZeroTransparencyValues = { ["ScorchMark"] = 0.25 }
		local particleEmittersToDisable = { ["Smoke"] = true }
		local imageLabelNonZeroTransparencyValues = { ["Impact"] = 0.25 }
		for _, descendant in pairs(effectsFolder:GetDescendants()) do
			if descendant:IsA("BasePart") then
				if partNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = partNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("Decal") then
				descendant.Transparency = 0
				if decalNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = decalNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("ParticleEmitter") then
				descendant.Enabled = true
				if particleEmittersToDisable[descendant.Name] ~= nil then
					descendant.Enabled = false
				else
					descendant.Enabled = true
				end
			elseif descendant:IsA("ImageLabel") then
				if imageLabelNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.ImageTransparency = imageLabelNonZeroTransparencyValues[descendant.Name]
				else
					descendant.ImageTransparency = 0
				end
			end
		end
		
		weaponsSystemInitialized = true
	end
end

if weaponsSystemFolder == nil then
	weaponsSystemFolder = curWeaponsSystemFolder:Clone()
	initializeWeaponsSystemAssets()
	weaponsSystemFolder.Parent = ReplicatedStorage
end

if ServerScriptService:FindFirstChild("ServerWeaponsScript") == nil then
	script.Parent = ServerScriptService
	initializeWeaponsSystemAssets()

	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
	
	local function setupClientWeaponsScript(player)
		local clientWeaponsScript = player.PlayerGui:FindFirstChild("ClientWeaponsScript")
		if clientWeaponsScript == nil then
			clientWeaponsScript = weaponsSystemFolder.ClientWeaponsScript:Clone()
			clientWeaponsScript.Parent = player.PlayerGui
		end
	end
	
	Players.PlayerAdded:Connect(function(player)
		setupClientWeaponsScript(player)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		setupClientWeaponsScript(player)
	end
end

if curWeaponsSystemFolder.Name == "WeaponsSystem" then
	curWeaponsSystemFolder:Destroy()
end
end))
Folder300.Name = "Configuration"
Folder300.Parent = Folder185
BoolValue301.Name = "SprintEnabled"
BoolValue301.Parent = Folder300
BoolValue301.Value = true
BoolValue302.Name = "SlowZoomWalkEnabled"
BoolValue302.Parent = Folder300
BoolValue302.Value = true
Folder303.Name = "Libraries"
Folder303.Parent = Folder185
ModuleScript304.Name = "DamageBillboardHandler"
ModuleScript304.Parent = Folder303
table.insert(cors,sandbox(ModuleScript304,function()
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

if RunService:IsServer() then return {} end

local localPlayer = Players.LocalPlayer
while not localPlayer do
	Players.PlayerAdded:Wait()
	localPlayer = Players.LocalPlayer
end

local adorneeToBillboardGui = {}

local DamageBillboardHandler = {}

function DamageBillboardHandler:CreateBillboardForAdornee(adornee)
	local billboard = adorneeToBillboardGui[adornee]
	if billboard then
		return billboard
	end

	billboard = Instance.new("BillboardGui")
	billboard.Name = "DamageBillboardGui"
	billboard.Adornee = adornee
	billboard.AlwaysOnTop = true
	billboard.ExtentsOffsetWorldSpace = Vector3.new(0,18,0)
	billboard.Size = UDim2.new(0.42,20,15,0)
	billboard.ResetOnSpawn = false
	billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	billboard.Parent = localPlayer.PlayerGui
	adorneeToBillboardGui[adornee] = billboard

	local ancestorCon
	ancestorCon = adornee.AncestryChanged:connect(function(child, parent)
		if parent == nil then
			ancestorCon:disconnect()
			ancestorCon = nil

			local adorneeBillboard = adorneeToBillboardGui[adornee]
			adorneeBillboard:Destroy()
			adorneeToBillboardGui[adornee] = nil
		end
	end)

	return billboard
end

function DamageBillboardHandler:ShowDamageBillboard(damageAmount, adornee)
	damageAmount = math.ceil(damageAmount)

	local billboard = self:CreateBillboardForAdornee(adornee)

	local randomXPos = math.random(-10,10)/30

	local damageNumber = Instance.new("TextLabel")
	damageNumber.AnchorPoint = Vector2.new(0.5, 1)
	damageNumber.BackgroundTransparency = 1
	damageNumber.BorderSizePixel = 0
	damageNumber.Position = UDim2.fromScale(0.5 + randomXPos,1)
	damageNumber.Size = UDim2.fromScale(0,0.25)
	damageNumber.Font = Enum.Font.GothamBlack
	damageNumber.Text = tostring(damageAmount)
	damageNumber.TextColor3 = Color3.new(0.7,0.7,0.7)
	damageNumber.TextScaled = true
	damageNumber.TextStrokeTransparency = 0
	damageNumber.TextTransparency = 0
	damageNumber.TextXAlignment = Enum.TextXAlignment.Center
	damageNumber.TextYAlignment = Enum.TextYAlignment.Bottom
	damageNumber.Parent = billboard

	local appearTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Elastic,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0) --delayTime
	local appearTween = TweenService:Create(
		damageNumber,
		appearTweenInfo, {
			Size = UDim2.fromScale(1, damageNumber.Size.Y.Scale),
			TextColor3 = Color3.new(1,1,1)
		}
	)

	local upTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Linear,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0.2) --delayTime
	local upTween = TweenService:Create(
		damageNumber,
		upTweenInfo, {
			Position = UDim2.fromScale(damageNumber.Position.X.Scale, 0.25),
			TextTransparency = 1,
			TextStrokeTransparency = 4,
			Rotation = math.random(-5,5)
		}
	)

	local completedCon
	completedCon = upTween.Completed:connect(function()
		completedCon:disconnect()
		completedCon = nil
		damageNumber:Destroy()
	end)

	appearTween:Play()
	upTween:Play()
end

return DamageBillboardHandler
end))
ModuleScript305.Name = "DirectionalIndicatorGuiManager"
ModuleScript305.Parent = Folder303
table.insert(cors,sandbox(ModuleScript305,function()
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local DirectionalIndicatorGuiManager = {}
DirectionalIndicatorGuiManager.__index = DirectionalIndicatorGuiManager

local function GetConfigValue(config, propertyName, default)
	if config then
		local property = config:FindFirstChild(propertyName)
		if property then
			return property.Value
		end
	end
	return default
end

function DirectionalIndicatorGuiManager.new(weaponsGui)
	local self = setmetatable({}, DirectionalIndicatorGuiManager)
	self.weaponsGui = weaponsGui
	self.connections = {}
	self.enabled = false

	-- Note DI is an abbreviation for DirectionalIndicator
	self.DIFolder = self.weaponsGui.scalingElementsFolder:WaitForChild("DirectionalIndicators")
	self.DIInfo = {}

	for _, DIFrame in ipairs(self.DIFolder:GetChildren()) do
		if DIFrame:IsA("Frame") and DIFrame:FindFirstChildOfClass("ImageLabel") then
			local config = DIFrame:FindFirstChildOfClass("Configuration")
			local name = GetConfigValue(config, "Name", DIFrame.Name)
			self.DIInfo[name] = self:GetDIInfoFromFrame(DIFrame)

			DIFrame.Visible = true
			self.DIInfo[name].image.ImageTransparency = 1
		end
	end

	return self
end

function DirectionalIndicatorGuiManager:GetDIInfoFromFrame(frame)
	local diInfo = {}
	diInfo.frame = frame
	diInfo.image = frame:FindFirstChildOfClass("ImageLabel")
	diInfo.config = frame:FindFirstChildOfClass("Configuration")
	diInfo.active = false
	diInfo.dieOnFade = false -- will only be true for copies of original DIs
	return diInfo
end

function DirectionalIndicatorGuiManager:ActivateDirectionalIndicator(DIName, otherPosition)
	-- Use original DI, or make a copy if it's already active
	local diInfo = self.DIInfo[DIName]
	if not diInfo then
		warn("Warning: invalid name given to ActivateDirectionalIndicator")
		return
	end

	if diInfo.active then
		local newFrame = diInfo.frame:Clone()
		newFrame.Parent = diInfo.frame.Parent
		diInfo = self:GetDIInfoFromFrame(newFrame)
		diInfo.dieOnFade = true
	end
	diInfo.active = true

	-- Update distance from center
	local distanceLevel = GetConfigValue(diInfo.config, "DistanceLevelFromCenter", 6)
	local widthLevel = GetConfigValue(diInfo.config, "WidthLevel", distanceLevel)
	local levelMultiplier = 0.03
	self.weaponsGui.originalScaleAmounts[diInfo.frame] = Vector2.new(widthLevel * levelMultiplier, distanceLevel * levelMultiplier * 2)
	self.weaponsGui:updateScale(diInfo.frame, workspace.CurrentCamera.ViewportSize)

	-- Set initial indicator rotation and transparency
	diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
	diInfo.image.ImageTransparency = GetConfigValue(diInfo.config, "TransparencyBeforeFade", 0)

	-- Update rotation of indicator as player rotates
	coroutine.wrap(function()
		while diInfo.image.ImageTransparency < 1 do
			diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
			RunService.RenderStepped:Wait()
		end

		diInfo.active = false
		if diInfo.dieOnFade then
			diInfo.frame:Destroy()
			diInfo = nil
		end
	end)()

	-- Show indicator for a bit, then fade out
	coroutine.wrap(function()
		wait(GetConfigValue(diInfo.config, "TimeBeforeFade", 1))
		local tweenInfo = TweenInfo.new(GetConfigValue(diInfo.config, "FadeTime", 1))
		local goal = {}
		goal.ImageTransparency = 1
		local tween = TweenService:Create(diInfo.image, tweenInfo, goal)
		tween:Play()
	end)()
end

function DirectionalIndicatorGuiManager:CalculateDIRotation(otherPosition)
	local camera = self.weaponsGui.weaponsSystem.camera
	local localPlayerOffsetPositionXZ = Vector3.new(camera.currentCamera.Focus.X, 0, camera.currentCamera.Focus.Z)
	local otherPlayerPositionXZ = Vector3.new(otherPosition.X, 0, otherPosition.Z)
	local toOtherPlayer = (localPlayerOffsetPositionXZ - otherPlayerPositionXZ).Unit
	local forward = (Vector3.new(camera.currentCFrame.LookVector.X, 0, camera.currentCFrame.LookVector.Z)).Unit
	if toOtherPlayer == Vector3.new() then
		toOtherPlayer = forward
	end
	local dotProduct = forward:Dot(toOtherPlayer)
	local crossProduct = forward:Cross(toOtherPlayer)
	local acosAngle = math.deg(math.acos(dotProduct))
	local asinAngle = math.deg(math.asin(crossProduct.Y))
	if asinAngle >= 0 then
		acosAngle = 360 - acosAngle
	end
	return acosAngle
end

return DirectionalIndicatorGuiManager
end))
ModuleScript306.Name = "Parabola"
ModuleScript306.Parent = Folder303
table.insert(cors,sandbox(ModuleScript306,function()
local RunService = game:GetService("RunService")

local MIN_HORZ_SPEED = 0.01 --The minimum X and Z velocity for a physical-launch parabola to be considered vertical, helps avoid numerical instability
local DEFAULT_NUM_SAMPLES = RunService:IsServer() and 32 or 32
local DEFAULT_NORMAL = Vector3.new(0, 1, 0)
local ROT_OFFSET = {
	[0] = CFrame.Angles(0, math.rad(90), 0) * CFrame.Angles(math.rad(90), 0, 0),
	[1] = CFrame.Angles(0, math.rad(-90), 0) * CFrame.Angles(math.rad(90), 0, 0)
}
local UP_VECTOR = Vector3.new(0, 1, 0)
local ONE_THIRD, TWO_THIRDS = 1/3, 2/3

local Parabola = {}
Parabola.__index = Parabola

function Parabola.new(a, b, c, x0, x1)
	local self = setmetatable({}, Parabola)

	self.referenceFrame = CFrame.new()

	self.a = a or 1
	self.b = b or 1
	self.c = c or 0

	self.x0 = x0 or 0
	self.x1 = x1 or 10

	self.velocity = Vector2.new()
	self.gravity = 0

	self.numSamples = DEFAULT_NUM_SAMPLES

	return self
end

function Parabola:setPhysicsLaunch(startPoint, velocity, endpointY, gravity)
	gravity = gravity or -workspace.Gravity

	local flatVelocity = velocity * Vector3.new(1, 0, 1)
	if flatVelocity.Magnitude > MIN_HORZ_SPEED then
		self.referenceFrame = CFrame.new(startPoint, startPoint + flatVelocity)
	else
		self.referenceFrame = CFrame.new(startPoint)
	end
	local relativeVelocity = self.referenceFrame:vectorToObjectSpace(velocity)
	local xVelocity, yVelocity = math.max(MIN_HORZ_SPEED, -relativeVelocity.Z), relativeVelocity.Y
	self.a = (0.5 * gravity) * (1 / (xVelocity ^ 2))
	self.b = yVelocity / xVelocity
	self.c = 0

	self.velocity = Vector2.new(xVelocity, yVelocity)
	self.gravity = gravity

	if math.abs(gravity) > 1e-3 then
		self.x0 = 0

		if endpointY and startPoint.Y - endpointY > 0 then
			--y = ax^2 + bx + c
			--0 = ax^2 + bx - y
			--x = (-b +- sqrt(b^2 - 4ac)) / 2a

			local a, b, c = self.a, self.b, startPoint.Y - endpointY
			local det = math.sqrt(b^2 - 4 * a * c)
			local s1, s2 = (-b + det) / (2 * a), (-b - det) / (2 * a)

			self.x1 = math.max(s1, s2)
		else
			self.x1 = math.abs(2 * xVelocity * yVelocity) / math.abs(gravity)
		end
	else
		self.x0 = 0
		self.x1 = 100
	end
end

function Parabola:setNumSamples(numSamples)
	self.numSamples = numSamples
end

function Parabola:setDomain(x0, x1)
	self.x0 = x0
	self.x1 = x1
end

function Parabola:samplePoint(t)
	local a, b, c = self.a, self.b, self.c
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (a * x * x) + (b * x) + c
	return self.referenceFrame:pointToWorldSpace(Vector3.new(0, y, -x))
end

function Parabola:sampleSlope(t)
	local a, b = self.a, self.b
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (2 * a * x) + b
	return y
end

function Parabola:sampleVelocity(t)
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local xVelocity = self.velocity.X
	local xT = x / xVelocity
	local yVelocity = self.velocity.Y + (self.gravity * xT)
	return self.referenceFrame:vectorToWorldSpace(Vector3.new(0, yVelocity, -xVelocity))
end

function Parabola:_penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, UP_VECTOR, Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Parabola:_findPart(funcName, list)
	list = list or {}

	local numSamples = self.numSamples
	local hitPart, hitPoint, hitNormal, hitMaterial, hitT = nil, self.referenceFrame.p, DEFAULT_NORMAL, Enum.Material.Air, 0

	local func = funcName ~= "penetrateCast" and workspace[funcName] or Parabola._penetrateCast

	for i = 1, numSamples do
		local t0 = (i - 1) / numSamples
		local t1 = i / numSamples

		local p0 = self:samplePoint(t0)
		local p1 = self:samplePoint(t1)
		local ray = Ray.new(p0, p1 - p0)

		hitPart, hitPoint, hitNormal, hitMaterial = func(workspace, ray, list)
		if hitPart then
			local hitX = -self.referenceFrame:pointToObjectSpace(hitPoint).Z

			hitT = ((hitX - self.x0) / (self.x1 - self.x0))
			break
		end
	end
	if not hitPart then
		hitT = 1
	end
	return hitPart, hitPoint, hitNormal, hitMaterial, hitT
end

function Parabola:findPart(ignoreList)
	return self:_findPart("penetrateCast", ignoreList)
end
function Parabola:findPartWithWhitelist(whitelist)
	return self:_findPart("FindPartOnRayWithWhitelist", whitelist)
end

function Parabola:findSpheresHit(sphereTable, radius)

end

function Parabola:_setBeamControlPoint(beam, attachment, idx, pos, refFrame)
	local attachmentPos = attachment.WorldPosition
	local vecFromAttachment = pos - attachmentPos
	local curveSize = vecFromAttachment.Magnitude

	attachment.CFrame = refFrame:toObjectSpace(CFrame.new(attachmentPos, pos) * ROT_OFFSET[idx])
	if idx == 0 then
		beam.CurveSize0 = curveSize
	else
		beam.CurveSize1 = curveSize
	end
end

function Parabola:renderToBeam(beam)
	local att0, att1 = beam.Attachment0, beam.Attachment1
	--assert(att0 and att1 and att0.Parent and att0.Parent:IsA("BasePart") and att1.Parent and att1.Parent:IsA("BasePart"), "Beam must have valid attachments that are in a BasePart")

	if not att0.Parent or not att1.Parent then
		return
	end

	local root0, root1 = att0.Parent.CFrame, att1.Parent.CFrame

	local referenceFrame = self.referenceFrame

	local x0, x1 = self.x0, self.x1
	local domain = x1 - x0
	local halfDomain = domain * 0.5
	local p0 = self:samplePoint(0)
	local p1 = self:samplePoint(1)
	local a, b, c = self.a, self.b, self.c
	local x = x0 + (0 * (x1 - x0))
	local cY = ((a * x * x) + (b * x) + c) + self:sampleSlope(0) * halfDomain
	c = referenceFrame:pointToWorldSpace(Vector3.new(0, cY, -(x0 + x1) / 2))
	local c0 = TWO_THIRDS * c + ONE_THIRD * p0
	local c1 = TWO_THIRDS * c + ONE_THIRD * p1

	att0.Position = root0:pointToObjectSpace(p0)
	att1.Position = root1:pointToObjectSpace(p1)

	self:_setBeamControlPoint(beam, att0, 0, c0, root0)
	self:_setBeamControlPoint(beam, att1, 1, c1, root1)
end

return Parabola

end))
ModuleScript307.Name = "Ragdoll"
ModuleScript307.Parent = Folder303
table.insert(cors,sandbox(ModuleScript307,function()
local RunService = game:GetService("RunService")

local JOINT_INFO = {
	LeftShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(45))
	},
	LeftElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	LeftWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},
	RightShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(-45))
	},
	RightElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	RightWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},

	Waist = {
		Limits = { Lower = -45, Upper = 30 }
	},
	Neck = {
		Limits = { Cone = 20, Twist = 20 }
	},

	LeftHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(35)),
	},
	LeftKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	LeftAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	},
	RightHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(-35))
	},
	RightKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	RightAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	}
}

local GROUPS = {
	UpperBody = {
		"Waist",
		"Neck",
		"LeftShoulder",
		"RightShoulder",
		"LeftElbow",
		"RightElbow",
		"LeftWrist",
		"RightWrist"
	},
	LowerBody = {
		"LeftHip",
		"RightHip",
		"LeftKnee",
		"RightKnee",
		"LeftAnkle",
		"RightAnkle"
	},
	LeftArm = {
		"LeftShoulder",
		"LeftElbow",
		"LeftWrist",
	},
	RightArm = {
		"RightShoulder",
		"RightElbow",
		"RightWrist"
	},
	LeftLeg = {
		"LeftHip",
		"LeftKnee",
		"LeftAnkle"
	},
	RightLeg = {
		"RightHip",
		"RightKnee",
		"RightAnkle"
	},
}

local Ragdoll = {}
Ragdoll.__index = Ragdoll

function Ragdoll.new(character)
	local self = setmetatable({}, Ragdoll)
	self.character = character
	self.humanoid = character:WaitForChild("Humanoid")

	self.joints = {}
	for jointName, info in pairs(JOINT_INFO) do
		self.joints[jointName] = self:setupJoint(jointName, info)
	end

	return self
end

function Ragdoll:setupJoint(jointName, info)
	if self.joints[jointName] then
		return self.joints[jointName]
	end

	local constraintName = jointName .. "Constraint"
	local rigAttachmentName = jointName .. "RigAttachment"
	local existingConstraint = self.character:FindFirstChild(constraintName, true)
	local existingMotor = self.character:FindFirstChild(jointName, true)
	if not existingMotor then
		return nil
	end

	if existingConstraint or RunService:IsClient() then
		existingConstraint = self.character:WaitForChild(constraintName)
		return {
			constraint = existingConstraint,
			motor = existingMotor,
			ragdolled = existingMotor.Part1 ~= nil
		}
	else
		local constraintType = "HingeConstraint"
		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraintType = "BallSocketConstraint"
		end

		local constraint = Instance.new(constraintType)
		constraint.Name = constraintName
		constraint.Enabled = false
		constraint.Attachment0 = existingMotor.Part0:FindFirstChild(rigAttachmentName)
		constraint.Attachment1 = existingMotor.Part1:FindFirstChild(rigAttachmentName)
		constraint.LimitsEnabled = info.Limits ~= nil

		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraint.UpperAngle = info.Limits.Cone
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = -info.Limits.Twist
			constraint.TwistUpperAngle = info.Limits.Twist
		elseif info.Limits and info.Limits.Lower and info.Limits.Upper then
			constraint.LowerAngle = info.Limits.Lower
			constraint.UpperAngle = info.Limits.Upper
		end

		constraint.Parent = existingMotor.Parent

		return {
			constraint = constraint,
			motor = existingMotor,
			ragdolled = false
		}
	end
end

function Ragdoll:setJointRagdolled(jointName, ragdolled)
	local joint = self.joints[jointName]
	if not joint then return end

	joint.constraint.Enabled = ragdolled
	if joint.motor and joint.motor:IsA("Motor6D") then
		if ragdolled then
			joint.motor.Part1 = nil
		else
			joint.motor.Part1 = joint.motor.Parent
		end
	end
end

function Ragdoll:setGroupRagdolled(groupName, ragdolled)
	local groupJoints = GROUPS[groupName]
	assert(groupJoints, string.format("%s is not a valid ragdoll group", tostring(groupName)))

	for _, jointName in pairs(groupJoints) do
		self:setJointRagdolled(jointName, ragdolled)
	end
end

function Ragdoll:setRagdolled(ragdolled, whitelist)
	for jointName in pairs(self.joints) do
		if not whitelist or whitelist[jointName] then
			self:setJointRagdolled(jointName, ragdolled)
		end
	end
end

function Ragdoll:destroy()
	self:setRagdolled(false)
	for _, joint in pairs(self.joints) do
		if joint.constraint then
			joint.constraint:Destroy()
		end
	end
	self.joints = {}
end

return Ragdoll

end))
ModuleScript308.Name = "Roblox"
ModuleScript308.Parent = Folder303
table.insert(cors,sandbox(ModuleScript308,function()
local TweenService 		= game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local RunService 		= game:GetService("RunService")
local UserInputService	= game:GetService("UserInputService")

local Roblox = {}

Roblox.Random = Random.new()
Roblox.zeroVector2 = Vector2.new()
Roblox.zeroVector3 = Vector3.new()
Roblox.identityCFrame = CFrame.new()
Roblox.upVector2 = Vector2.new(0, 1)
Roblox.upVector3 = Vector3.new(0, 1, 0)

local guidCharsText = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+./"
local guidChars = {}
for i = 1, #guidCharsText do
	guidChars[i] = guidCharsText:sub(i, i)
end
local guidRandom = Random.new()

function Roblox.newGuid()
	local guid = ""
	for _ = 1, 10 do
		local char = guidRandom:NextInteger(1,#guidChars)
		guid = guid .. guidChars[char]
	end
	return guid
end

function Roblox.isPlaySolo()
	return RunService:IsClient() and RunService:IsServer() and RunService:IsStudio()
end

function Roblox.waitForDescendant(instance, descendantName, timeout)
	timeout = timeout or 60
	local found = instance:FindFirstChild(descendantName, true)
	if found then
		return found
	end

	if timeout < 1e6 and timeout > 0 then
		coroutine.wrap(function()
			wait(timeout)
			if not found then
				warn("Roblox.waitForDescendant(%s, %s) is taking too long")
			end
		end)()
	end

	while not found do
		local newDescendant = instance.DescendantAdded:Wait()
		if newDescendant.Name == descendantName then
			found = newDescendant
			return newDescendant
		end
	end
end

function Roblox.create(className)
	return function(props)
		local instance = Instance.new(className)
		for key, val in pairs(props) do
			if key ~= "Parent" then
				instance[key] = val
			end
		end
		instance.Parent = props.Parent
		return instance
	end
end

function Roblox.weldModel(model)
	local rootPart = model.PrimaryPart
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and part ~= rootPart then
			local weld = Instance.new("WeldConstraint")
			weld.Part0 = rootPart
			weld.Part1 = part
			weld.Parent = part
		end
	end
end

function Roblox.setNetworkOwner(model, owner)
	if not model then warn("Cannot setNetworkOwner on nil model") return end
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and not part.Anchored then
			part:SetNetworkOwner(owner)
		end
	end
end

function Roblox.createMotor6D(root, child)
	local motor = Instance.new("Motor6D")
	motor.Part0 = root
	motor.Part1 = child

	motor.C0 = root.CFrame:toObjectSpace(child.CFrame)
	motor.C1 = CFrame.new()

	motor.Parent = root
	return motor
end

function Roblox.getTotalMass(part)
	local allConnected = part:GetConnectedParts(true)
	local total = 0
	for _, v in pairs(allConnected) do
		total = total + v:GetMass()
	end
	return total
end

function Roblox.waitForTween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
	tween.Completed:wait()
end

function Roblox.tween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
end

function Roblox.fadeAway(gui, duration, level)
	duration = duration or 0.5
	level = level or 0

	local tweenInfo = TweenInfo.new(duration)
	local tweenProps = { BackgroundTransparency = 1 }

	if gui:IsA("TextButton") or gui:IsA("TextLabel") or gui:IsA("TextBox") then
		tweenProps.TextTransparency = 1
		tweenProps.TextStrokeTransparency = 1
	elseif gui:IsA("ImageLabel") or gui:IsA("ImageButton") then
		tweenProps.ImageTransparency = 1
	else
		return
	end

	for _, v in pairs(gui:GetChildren()) do
		Roblox.fadeAway(v, duration, level + 1)
	end


	if level == 0 then
		coroutine.wrap(function()
			Roblox.waitForTween(gui, tweenInfo, tweenProps)
			gui:Destroy()
		end)()
	else
		Roblox.tween(gui, tweenInfo, tweenProps)
	end
end

function Roblox.setModelAnchored(model, anchored)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = anchored
		end
	end
end

function Roblox.setModelLocalVisible(model, visible)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.LocalTransparencyModifier = visible and 0 or 1
		elseif part:IsA("SurfaceGui") then
			part.Enabled = visible
		elseif part:IsA("Decal") then
			part.Transparency = visible and 0 or 1
		end
	end
end

function Roblox.forAllTagged(tagName, enterFunc, exitFunc)
	for _, obj in pairs(CollectionService:GetTagged(tagName)) do
		if enterFunc then
			enterFunc(obj, tagName)
		end
	end
	if enterFunc then
		CollectionService:GetInstanceAddedSignal(tagName):Connect(function(obj) enterFunc(obj, tagName) end)
	end
	if exitFunc then
		CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(obj) exitFunc(obj, tagName) end)
	end
end

function Roblox.getHumanoidFromCharacterPart(part)
	local currentNode = part
	while currentNode do
		local humanoid = currentNode:FindFirstChildOfClass("Humanoid")
		if humanoid then return humanoid end
		currentNode = currentNode.Parent
	end
	return nil
end

local addEsEndings = {
	s = true,
	sh = true,
	ch = true,
	x = true,
	z = true
}
local vowels = {
	a = true,
	e = true,
	i = true,
	o = true,
	u = true
}
function Roblox.formatPlural(num, name, wordOnly)
	if num ~= 1 then
		local lastTwo = name:sub(-2):lower()
		local lastOne = name:sub(-1):lower()

		local suffix = "s"
		if addEsEndings[lastTwo] or addEsEndings[lastOne] then
			suffix = "es"
		elseif lastOne == "o" and #lastTwo == 2 then
			local secondToLast = lastTwo:sub(1, 1)
			if not vowels[secondToLast] then
				suffix = "es"
			end
		end
		name = name .. suffix
	end
	if not wordOnly then
		return ("%s %s"):format(Roblox.formatInteger(num), name)
	else
		return name
	end
end

function Roblox.formatNumberTight(number)
	local order = math.log10(number)
	if order >= 3 and order < 6 then
		return ("%.1fK"):format(number / (10^3))
	end
	if order >= 6 and order < 9 then
		return ("%.1fM"):format(number / (10^6))
	end
	if order >= 9 then
		return ("%.1fB"):format(number / (10^9))
	end

	return tostring(math.floor(number + 0.5))
end

function Roblox.formatInteger(amount)
	amount = math.floor(amount + 0.5)
	local formatted = amount
	local numMatches
	repeat
		formatted, numMatches = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
	until numMatches == 0
	return formatted
end

function Roblox.round(val, decimal)
	if decimal then
		return math.floor((val * 10 ^ decimal) + 0.5) / (10 ^ decimal)
	else
		return math.floor(val + 0.5)
	end
end

function Roblox.formatNumber(number)
	local result, integral, fractional

	integral, fractional = math.modf(number)
	result = Roblox.formatInteger(integral)

	if fractional ~= 0 then
		result = result .. "." .. string.sub(tostring(math.abs(fractional)),3)
	end
	if number < 0 then
		result = "-" .. result
	end

	return result
end

function Roblox.isPointInsidePart(point, part)
	local localPos = part.CFrame:pointToObjectSpace(point)
	return math.abs(localPos.X) <= part.Size.X * 0.5 and math.abs(localPos.Y) <= part.Size.Y * 0.5 and math.abs(localPos.Z) <= part.Size.Z * 0.5
end

function Roblox.rayPlaneIntersect(ray, pointOnPlane, planeNormal)
	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function Roblox.debugPrint(t, level)
	level = level or 0
	local tabs = string.rep("\t", level)
	if typeof(t) == "table" then
		for key, val in pairs(t) do
			print(tabs, key, "=", val)
			if typeof(val) == "table" then
				Roblox.debugPrint(val, level + 1)
			end
		end
	end
end

local function findInstanceImpl(root, path, getChildFunc)
	local currentInstance = root

	while true do
		local nextChildName
		local nextSeparator = path:find("%.")
		if not nextSeparator then
			nextChildName = path
		else
			nextChildName = path:sub(1, nextSeparator - 1)
			path = path:sub(nextSeparator + 1)
		end

		local child = getChildFunc(currentInstance, nextChildName)
		if child then
			currentInstance = child
		else
			return nil
		end
	end
end

local function findFirstChildImpl(parent, childName)
	return parent:FindFirstChild(childName)
end
local function waitForChildImpl(parent, childName)
	return parent:WaitForChild(childName)
end

function Roblox.findInstance(root, path)
	return findInstanceImpl(root, path, findFirstChildImpl)
end

function Roblox.waitForInstance(root, path)
	return findInstanceImpl(root, path, waitForChildImpl)
end

function Roblox.penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and (not hitPart.CanCollide or CollectionService:HasTag(hitPart, "DroppedItemPart") or CollectionService:HasTag(hitPart, "Hidden")) and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Roblox.posInGuiObject(pos, guiObject)
	local guiMin = guiObject.AbsolutePosition
	local guiMax = guiMin + guiObject.AbsoluteSize
	return pos.X >= guiMin.X and pos.X <= guiMax.X and pos.Y >= guiMin.Y and pos.Y <= guiMax.Y
end

function Roblox.getUTCTime()
	local dateInfo = os.date("!*t")
	return string.format("%04d-%02d-%02d %02d:%02d:%02d", dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.min, dateInfo.sec)
end

function Roblox.getUTCTimestamp()
	return os.time(os.date("!*t"))
end

local DURATION_TOKENS = {
	{ "years",   "y",  31536000 },
	{ "months",  "mo", 2592000 },
	{ "weeks",   "w",  604800 },
	{ "days",    "d",  86400 },
	{ "hours",   "h",  3600 },
	{ "minutes", "m",  60 },
	{ "seconds", "s",  1 },
}
function Roblox.parseDurationInSeconds(inputStr)
	local tokensFound = {}
	local totalDurationSeconds = 0
	for _, tokenInfo in pairs(DURATION_TOKENS) do
		local numFound = string.match(inputStr, "(%d+)" .. tokenInfo[2])
		if numFound then
			local num = tonumber(numFound) or 0
			if num > 0 then
				table.insert(tokensFound, string.format("%d %s", num, tokenInfo[1]))
			end
			totalDurationSeconds = totalDurationSeconds + (num * tokenInfo[3])
		end
	end

	local outputStr = table.concat(tokensFound, ", ")
	return totalDurationSeconds, outputStr
end

local random = Random.new()
function Roblox.chooseWeighted(choiceTable)
    local sum = 0
    for _, weight in pairs(choiceTable) do
        sum = sum + weight
    end

    local roll = random:NextNumber(0, 1)
    local choiceSum = 0
    for choiceName, weight in pairs(choiceTable) do
        local chance = weight / sum
        if roll >= choiceSum and roll < choiceSum + chance then
            return choiceName
        else
            choiceSum = choiceSum + chance
        end
    end

    return nil
end

function Roblox.hasMatchingTag(instance, tagPattern)
	for _, tagName in pairs(CollectionService:GetTags(instance)) do
		if tagName:match(tagPattern) ~= nil then
			return true
		end
	end
	return false
end

local highlightTweens = setmetatable({}, { __mode = 'k' })
function Roblox.showHighlight(instance, show)
	local highlightInstance = instance:FindFirstChild("Highlight")
	if not highlightInstance or not highlightInstance:IsA("ImageLabel") then
		return
	end

	local existingTween = highlightTweens[instance]
	if existingTween then
		if show then
			return
		else
			existingTween:Cancel()
			highlightTweens[instance] = nil
			highlightInstance.ImageTransparency = 1
		end
	else
		if not show then
			return
		else
			coroutine.wrap(function()
				highlightInstance.ImageTransparency = 1
				local newTween = TweenService:Create(highlightInstance, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, true), { ImageTransparency = 0 })
				highlightTweens[instance] = newTween
				while highlightTweens[instance] == newTween do
					newTween:Play()
					newTween.Completed:Wait()
				end
			end)()
		end
	end
end

function Roblox.getClickVerb(capitalize)
	local verb = "Click"
	if UserInputService.TouchEnabled then
		verb = "Tap"
	end

	if not capitalize then
		verb = verb:lower()
	end
	return verb
end

function Roblox.computeLaunchAngle(relativePoint, launchVelocity)
	local dx, dy = -relativePoint.Z, relativePoint.Y

	local g = workspace.Gravity
	local invRoot = (launchVelocity ^ 4) - (g * ((g * dx * dx) + (2 * dy * launchVelocity * launchVelocity)))
	if invRoot <= 0 then
		return math.pi / 4
	end

	local root = math.sqrt(invRoot)
	local angle1 = math.atan(((launchVelocity * launchVelocity) + root) / (g * dx))
	local angle2 = math.atan(((launchVelocity * launchVelocity) - root) / (g * dx))

	local chosenAngle = math.min(angle1, angle2)

	return chosenAngle
end

function Roblox.getClosestPointOnLine(line0, line1, point, doClamp)
	local lineVec = line1 - line0
	local pointFromLine0 = point - line0

	local dotProduct = lineVec:Dot(pointFromLine0)
	local t = dotProduct / (lineVec.Magnitude ^ 2)
	if doClamp ~= false then
		t = math.clamp(t, 0, 1)
	end
	local pointOnLine = line0:Lerp(line1, t)
	return pointOnLine, t, (point - pointOnLine).Magnitude
end

function Roblox.getClosestPointOnLines(referencePoint, lines)
	local closestPoint, closestDist, closestLine, closestT = nil, math.huge, nil, 0
	for i = 1, #lines do
		local lineA, lineB = lines[i][1], lines[i][2]

		local point, t, dist = Roblox.getClosestPointOnLine(lineA, lineB, referencePoint)
		if dist < closestDist then
			closestPoint = point
			closestDist = dist
			closestLine = i
			closestT = t
		end
	end

	return closestPoint, closestDist, closestLine, closestT
end

function Roblox.getPointInFrontOnLines(referencePoint, forwardOffset, lines)
	local closestPoint, _, closestLine, closestT = Roblox.getClosestPointOnLines(referencePoint, lines)
	if closestPoint then
		local pointOffset = closestPoint
		local offsetBudget = forwardOffset

		if closestLine == 1 and closestT == 0 then
			local beforeDist = (lines[1][1] - Roblox.getClosestPointOnLine(lines[1][1], lines[1][2], referencePoint, false)).Magnitude
			offsetBudget = offsetBudget - beforeDist
		end

		local lineDir = Vector3.new(0, 0, 0)
		while offsetBudget > 0 and closestLine <= #lines do
			local lineA, lineB = lines[closestLine][1], lines[closestLine][2]
			local lineVec = lineB - lineA
			local lineLength = lineVec.Magnitude
			local pointDistAlongLine = (pointOffset - lineA).Magnitude
			local distLeftOnLine = lineLength - pointDistAlongLine
			lineDir = lineVec.Unit

			if offsetBudget > distLeftOnLine then
				offsetBudget = offsetBudget - distLeftOnLine
				pointOffset = lineB
				closestLine = closestLine + 1
			else
				break
			end
		end
		pointOffset = pointOffset + lineDir * offsetBudget

		return pointOffset
	end
	return closestPoint
end

function Roblox.applySpread(unspreadDir, randomGenerator, minSpread, maxSpread)
	local spreadRotation = randomGenerator:NextNumber(-math.pi, math.pi)
	local spreadOffset = randomGenerator:NextNumber(minSpread, maxSpread)
	local spreadTransform = CFrame.fromAxisAngle(Vector3.new(math.cos(spreadRotation), math.sin(spreadRotation), 0), spreadOffset)
	local unspreadCFrame = CFrame.new(Vector3.new(), unspreadDir)
	return (unspreadCFrame * spreadTransform).LookVector
end

return Roblox

end))
ModuleScript309.Name = "ShoulderCamera"
ModuleScript309.Parent = Folder303
table.insert(cors,sandbox(ModuleScript309,function()
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local UserGameSettings = UserSettings():GetService("UserGameSettings")

local LocalPlayer = Players.LocalPlayer
if RunService:IsClient() then
	while not LocalPlayer do
		Players.PlayerAdded:Wait()
		LocalPlayer = Players.LocalPlayer
	end
end
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

local CAMERA_RENDERSTEP_NAME = "ShoulderCameraUpdate"
local ZOOM_ACTION_NAME = "ShoulderCameraZoom"
local SPRINT_ACTION_NAME = "ShoulderCameraSprint"
local CONTROLLABLE_HUMANOID_STATES = {
	[Enum.HumanoidStateType.Running] = true,
	[Enum.HumanoidStateType.RunningNoPhysics] = true,
	[Enum.HumanoidStateType.Freefall] = true,
	[Enum.HumanoidStateType.Jumping] = true,
	[Enum.HumanoidStateType.Swimming] = false,
	[Enum.HumanoidStateType.Landed] = true
}

-- Gamepad thumbstick utilities
local k = 0.5
local lowerK = 0.9
local function SCurveTransform(t)
	t = math.clamp(t, -1,1)
	if t >= 0 then
		return (k*t) / (k - t + 1)
	end
	return -((lowerK*-t) / (lowerK + t + 1))
end

local DEADZONE = 0.25
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
end

local function fromSCurveSpace(t)
	return t/2 + 0.5
end

-- Applies a nonlinear transform to the thumbstick position to serve as the acceleration for camera rotation.
-- See https://www.desmos.com/calculator/xw2ytjpzco for a visual reference.
local function gamepadLinearToCurve(thumbstickPosition)
	return Vector2.new(
		math.clamp(math.sign(thumbstickPosition.X) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.X)))), -1, 1),
		math.clamp(math.sign(thumbstickPosition.Y) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.Y)))), -1, 1))
end


-- Remove back accessories since they frequently block the camera
local function isBackAccessory(instance)
	if instance and instance:IsA("Accessory") then
		local handle = instance:WaitForChild("Handle", 5)
		if handle and handle:IsA("Part") then
			local bodyBackAttachment = handle:WaitForChild("BodyBackAttachment", 5)
			if bodyBackAttachment and bodyBackAttachment:IsA("Attachment") then
				return true
			end

			local waistBackAttachment = handle:WaitForChild("WaistBackAttachment", 5)
			if waistBackAttachment and waistBackAttachment:IsA("Attachment") then
				return true
			end
		end
	end

	return false
end

local function removeBackAccessoriesFromCharacter(character)
	for _, child in ipairs(character:GetChildren()) do
		coroutine.wrap(function()
			if isBackAccessory(child) then
				child:Destroy()
			end
		end)()
	end
end

local descendantAddedConnection = nil
local function onCharacterAdded(character)
	removeBackAccessoriesFromCharacter(character)
	descendantAddedConnection = character.DescendantAdded:Connect(function(descendant)
		coroutine.wrap(function()
			if isBackAccessory(descendant) then
				descendant:Destroy()
			end
		end)()
	end)
end

local function onCharacterRemoving(character)
	if descendantAddedConnection then
		descendantAddedConnection:Disconnect()
		descendantAddedConnection = nil
	end
end

-- Set up the Local Player
if RunService:IsClient() then
	if LocalPlayer.Character then
		onCharacterAdded(LocalPlayer.Character)
	end
	LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
	LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)
end


local ShoulderCamera = {}
ShoulderCamera.__index = ShoulderCamera
ShoulderCamera.SpringService = nil

function ShoulderCamera.new(weaponsSystem)
	local self = setmetatable({}, ShoulderCamera)
	self.weaponsSystem = weaponsSystem

	-- Configuration parameters (constants)
	self.fieldOfView = 70
	self.minPitch = math.rad(-75) -- min degrees camera can angle down
	self.maxPitch = math.rad(75) -- max degrees camera can cangle up
	self.normalOffset = Vector3.new(2.25, 2.25, 10.5) -- this is the camera's offset from the player
	self.zoomedOffsetDistance = 8 -- number of studs to zoom in from default offset when zooming
	self.normalCrosshairScale = 1
	self.zoomedCrosshairScale = 0.75
	self.defaultZoomFactor = 1
	self.canZoom = true
	self.zoomInputs = { Enum.UserInputType.MouseButton2, Enum.KeyCode.ButtonL2 }
	self.sprintInputs = { Enum.KeyCode.LeftShift }
	self.mouseRadsPerPixel = Vector2.new(1 / 480, 1 / 480)
	self.zoomedMouseRadsPerPixel = Vector2.new(1 / 1200, 1 / 1200)
	self.touchSensitivity = Vector2.new(1 / 100, 1 / 100)
	self.zoomedTouchSensitivity = Vector2.new(1 / 200, 1 / 200)
	self.touchDelayTime = 0.25 -- max time for a touch to count as a tap (to shoot the weapon instead of control camera),
	                           -- also the amount of time players have to start a second touch after releasing the first time to trigger automatic fire
	self.recoilDecay = 2 -- higher number means faster recoil decay rate
	self.rotateCharacterWithCamera = true
	self.gamepadSensitivityModifier = Vector2.new(0.85, 0.65)
	-- Walk speeds
	self.zoomWalkSpeed = 8
	self.normalWalkSpeed = 16
	self.sprintingWalkSpeed = 24

	-- Current state
	self.enabled = false
	self.yaw = 0
	self.pitch = 0
	self.currentCFrame = CFrame.new()
	self.currentOffset = self.normalOffset
	self.currentRecoil = Vector2.new(0, 0)
	self.currentMouseRadsPerPixel = self.mouseRadsPerPixel
	self.currentTouchSensitivity = self.touchSensitivity
	self.mouseLocked = true
	self.touchPanAccumulator = Vector2.new(0, 0) -- used for touch devices, represents amount the player has dragged their finger since starting a touch
	self.currentTool = nil
	self.sprintingInputActivated = false
	self.desiredWalkSpeed = self.normalWalkSpeed
	self.sprintEnabled = false -- true means player will move faster while doing sprint inputs
	self.slowZoomWalkEnabled = false -- true means player will move slower while doing zoom inputs
	self.desiredFieldOfView = self.fieldOfView
	-- Zoom variables
	self.zoomedFromInput = false -- true if player has performed input to zoom
	self.forcedZoomed = false -- ignores zoomedFromInput and canZoom
	self.zoomState = false -- true if player is currently zoomed in
	self.zoomAlpha = 0
	self.hasScope = false
	self.hideToolWhileZoomed = false
	self.currentZoomFactor = self.defaultZoomFactor
	self.zoomedFOV = self.fieldOfView
	-- Gamepad variables
	self.gamepadPan = Vector2.new(0, 0) -- essentially the amount the gamepad has moved from resting position
	self.movementPan = Vector2.new(0, 0) -- this is for movement (gamepadPan is for camera)
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.lastThumbstickTime = nil
	self.currentGamepadSpeed = 0
	self.lastGamepadVelocity = Vector2.new(0, 0)

	-- Occlusion
	self.lastOcclusionDistance = 0
	self.lastOcclusionReachedTime = 0 -- marks the last time camera was at the true occlusion distance
	self.defaultTimeUntilZoomOut = 0
	self.timeUntilZoomOut = self.defaultTimeUntilZoomOut -- time after lastOcclusionReachedTime that camera will zoom out
	self.timeLastPoppedWayIn = 0 -- this holds the last time camera popped nearly into first person
	self.isZoomingOut = false
	self.tweenOutTime = 0.2
	self.curOcclusionTween = nil
	self.occlusionTweenObject = nil

	-- Side correction (when player is against a wall)
	self.sideCorrectionGoalVector = nil
	self.lastSideCorrectionMagnitude = 0
	self.lastSideCorrectionReachedTime = 0 -- marks the last time the camera was at the true correction distance
	self.revertSideCorrectionSpeedMultiplier = 2 -- speed at which camera reverts the side correction (towards 0 correction)
	self.defaultTimeUntilRevertSideCorrection = 0.75
	self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection -- time after lastSideCorrectionReachedTime that camera will revert the correction
	self.isRevertingSideCorrection = false

	-- Datamodel references
	self.eventConnections = {}
	self.raycastIgnoreList = {}
	self.currentCamera = nil
	self.currentCharacter = nil
	self.currentHumanoid = nil
	self.currentRootPart = nil
	self.controlModule = nil -- used to get player's touch input for moving character
	self.random = Random.new()

	return self
end

function ShoulderCamera:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end
	self.enabled = enabled

	if self.enabled then
		RunService:BindToRenderStep(CAMERA_RENDERSTEP_NAME, Enum.RenderPriority.Camera.Value - 1, function(dt) self:onRenderStep(dt) end)
		ContextActionService:BindAction(ZOOM_ACTION_NAME, function(...) self:onZoomAction(...) end, false, unpack(self.zoomInputs))
		ContextActionService:BindAction(SPRINT_ACTION_NAME, function(...) self:onSprintAction(...) end, false, unpack(self.sprintInputs))

		table.insert(self.eventConnections, LocalPlayer.CharacterAdded:Connect(function(character) self:onCurrentCharacterChanged(character) end))
		table.insert(self.eventConnections, LocalPlayer.CharacterRemoving:Connect(function() self:onCurrentCharacterChanged(nil) end))
		table.insert(self.eventConnections, workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() self:onCurrentCameraChanged(workspace.CurrentCamera) end))
		table.insert(self.eventConnections, UserInputService.InputBegan:Connect(function(inputObj, wasProcessed) self:onInputBegan(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputChanged:Connect(function(inputObj, wasProcessed) self:onInputChanged(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputEnded:Connect(function(inputObj, wasProcessed) self:onInputEnded(inputObj, wasProcessed) end))

		self:onCurrentCharacterChanged(LocalPlayer.Character)
		self:onCurrentCameraChanged(workspace.CurrentCamera)

		-- Make transition to shouldercamera smooth by facing in same direction as previous camera
		local cameraLook = self.currentCamera.CFrame.lookVector
		self.yaw = math.atan2(-cameraLook.X, -cameraLook.Z)
		self.pitch = math.asin(cameraLook.Y)

		self.currentCamera.CameraType = Enum.CameraType.Scriptable

		self:setZoomFactor(self.currentZoomFactor) -- this ensures that zoomedFOV reflecs currentZoomFactor

		workspace.CurrentCamera.CameraSubject = self.currentRootPart

		self.occlusionTweenObject = Instance.new("NumberValue")
		self.occlusionTweenObject.Name = "OcclusionTweenObject"
		self.occlusionTweenObject.Parent = script
		self.occlusionTweenObject.Changed:Connect(function(value)
			self.lastOcclusionDistance = value
		end)

		-- Sets up weapon system to use camera for raycast direction instead of gun look vector
		self.weaponsSystem.aimRayCallback = function()
			local cameraCFrame = self.currentCFrame
			return Ray.new(cameraCFrame.p, cameraCFrame.LookVector * 500)
		end
	else
		RunService:UnbindFromRenderStep(CAMERA_RENDERSTEP_NAME)
		ContextActionService:UnbindAction(ZOOM_ACTION_NAME)
		ContextActionService:UnbindAction(SPRINT_ACTION_NAME)

		if self.currentHumanoid then
			self.currentHumanoid.AutoRotate = true
		end

		if self.currentCamera then
			self.currentCamera.CameraType = Enum.CameraType.Custom
		end

		self:updateZoomState()

		self.yaw = 0
		self.pitch = 0

		for _, conn in pairs(self.eventConnections) do
			conn:Disconnect()
		end
		self.eventConnections = {}

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end
end

function ShoulderCamera:onRenderStep(dt)
	if not self.enabled or
	   not self.currentCamera or
	   not self.currentCharacter or
	   not self.currentHumanoid or
	   not self.currentRootPart
	then
		return
	end

	-- Hide mouse and lock to center if applicable
	if self.mouseLocked and not GuiService:GetEmotesMenuOpen() then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end

	-- Handle gamepad input
	self:processGamepadInput(dt)

	-- Smoothly zoom to desired values
	if self.hasScope then
		ShoulderCamera.SpringService:Target(self, 0.8, 8, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 8, { FieldOfView = self.desiredFieldOfView })
	else
		ShoulderCamera.SpringService:Target(self, 0.8, 3, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 3, { FieldOfView = self.desiredFieldOfView })
	end

	-- Handle walk speed changes
	if self.sprintEnabled or self.slowZoomWalkEnabled then
		self.desiredWalkSpeed = self.normalWalkSpeed
		if self.sprintEnabled and (self.sprintingInputActivated or self:sprintFromTouchInput() or self:sprintFromGamepadInput()) and not self.zoomState then
			self.desiredWalkSpeed = self.sprintingWalkSpeed
		end
		if self.slowZoomWalkEnabled and self.zoomAlpha > 0.1 then
			self.desiredWalkSpeed = self.zoomWalkSpeed
		end

		ShoulderCamera.SpringService:Target(self.currentHumanoid, 0.95, 4, { WalkSpeed = self.desiredWalkSpeed })
	end

	-- Initialize variables used for side correction, occlusion, and calculating camera focus/rotation
	local rootPartPos = self.currentRootPart.CFrame.Position
	local rootPartUnrotatedCFrame = CFrame.new(rootPartPos)
	local yawRotation = CFrame.Angles(0, self.yaw, 0)
	local pitchRotation = CFrame.Angles(self.pitch + self.currentRecoil.Y, 0, 0)
	local xOffset = CFrame.new(self.normalOffset.X, 0, 0)
	local yOffset = CFrame.new(0, self.normalOffset.Y, 0)
	local zOffset = CFrame.new(0, 0, self.normalOffset.Z)
	local collisionRadius = self:getCollisionRadius()
	local cameraYawRotationAndXOffset =
		yawRotation * 		-- First rotate around the Y axis (look left/right)
		xOffset 			-- Then perform the desired offset (so camera is centered to side of player instead of directly on player)
	local cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset

	-- Handle/Calculate side correction when player is adjacent to a wall (so camera doesn't go in the wall)
	local vecToFocus = cameraFocus.p - rootPartPos
	local rayToFocus = Ray.new(rootPartPos, vecToFocus + (vecToFocus.Unit * collisionRadius))
	local hitPart, hitPoint, hitNormal = self:penetrateCast(rayToFocus, self.raycastIgnoreList)
	local currentTime = tick()
	local sideCorrectionGoalVector = Vector3.new() -- if nothing is adjacent to player, goal vector is (0, 0, 0)
	if hitPart then
		hitPoint = hitPoint + (hitNormal * collisionRadius)
		sideCorrectionGoalVector = hitPoint - cameraFocus.p
		if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then -- make it easy for camera to pop closer to player (move left)
			if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection and self.lastSideCorrectionMagnitude ~= 0 then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection * 2 -- double time until revert if popping in repeatedly
			elseif self.lastSideCorrectionMagnitude == 0 and self.timeUntilRevertSideCorrection ~= self.defaultTimeUntilRevertSideCorrection then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection
			end
			self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
			self.lastSideCorrectionReachedTime = currentTime
			self.isRevertingSideCorrection = false
		else
			self.isRevertingSideCorrection = true
		end
	elseif self.lastSideCorrectionMagnitude ~= 0 then
		self.isRevertingSideCorrection = true
	end
	if self.isRevertingSideCorrection then -- make it hard/slow for camera to revert side correction (move right)
		if sideCorrectionGoalVector.Magnitude > self.lastSideCorrectionMagnitude - 1 and sideCorrectionGoalVector.Magnitude ~= 0 then
			self.lastSideCorrectionReachedTime = currentTime -- reset timer if occlusion significantly increased since last frame
		end
		if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection then
			local sideCorrectionChangeAmount = dt * (vecToFocus.Magnitude) * self.revertSideCorrectionSpeedMultiplier
			self.lastSideCorrectionMagnitude = self.lastSideCorrectionMagnitude - sideCorrectionChangeAmount
			if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then
				self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
				self.lastSideCorrectionReachedTime = currentTime
				self.isRevertingSideCorrection = false
			end
		end
	end

	-- Update cameraFocus to reflect side correction
	cameraYawRotationAndXOffset = cameraYawRotationAndXOffset + (-vecToFocus.Unit * self.lastSideCorrectionMagnitude)
	cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset
	self.currentCamera.Focus = cameraFocus

	-- Calculate and apply CFrame for camera
	local cameraCFrameInSubjectSpace =
		cameraYawRotationAndXOffset *
		pitchRotation * 	-- rotate around the X axis (look up/down)
		yOffset *			-- move camera up/vertically
		zOffset				-- move camera back
	self.currentCFrame = rootPartUnrotatedCFrame * cameraCFrameInSubjectSpace

	-- Move camera forward if zoomed in
	if self.zoomAlpha > 0 then
		local trueZoomedOffset = math.max(self.zoomedOffsetDistance - self.lastOcclusionDistance, 0) -- don't zoom too far in if already occluded
		self.currentCFrame = self.currentCFrame:lerp(self.currentCFrame + trueZoomedOffset * self.currentCFrame.LookVector.Unit, self.zoomAlpha)
	end

	self.currentCamera.CFrame = self.currentCFrame

	-- Handle occlusion
	local occlusionDistance = self.currentCamera:GetLargestCutoffDistance(self.raycastIgnoreList)
	if occlusionDistance > 1e-5 then
		occlusionDistance = occlusionDistance + collisionRadius
	end
	if occlusionDistance >= self.lastOcclusionDistance then -- make it easy for the camera to pop in towards the player
		if self.curOcclusionTween ~= nil then
			self.curOcclusionTween:Cancel()
			self.curOcclusionTween = nil
		end
		if currentTime > self.lastOcclusionReachedTime + self.timeUntilZoomOut and self.lastOcclusionDistance ~= 0 then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut * 2 -- double time until zoom out if popping in repeatedly
		elseif self.lastOcclusionDistance == 0  and self.timeUntilZoomOut ~= self.defaultTimeUntilZoomOut then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut
		end

		if occlusionDistance / self.normalOffset.Z > 0.8 and self.timeLastPoppedWayIn == 0 then
			self.timeLastPoppedWayIn = currentTime
		end

		self.lastOcclusionDistance = occlusionDistance
		self.lastOcclusionReachedTime = currentTime
		self.isZoomingOut = false
	else -- make it hard/slow for camera to zoom out
		self.isZoomingOut = true
		if occlusionDistance > self.lastOcclusionDistance - 2 and occlusionDistance ~= 0 then -- reset timer if occlusion significantly increased since last frame
			self.lastOcclusionReachedTime = currentTime
		end

		-- If occlusion pops camera in to almost first person for a short time, pop out instantly
		if currentTime < self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.lastOcclusionDistance / self.normalOffset.Z > 0.8 then
			self.lastOcclusionDistance = occlusionDistance
			self.lastOcclusionReachedTime = currentTime
			self.isZoomingOut = false
		elseif currentTime >= self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.timeLastPoppedWayIn ~= 0 then
			self.timeLastPoppedWayIn = 0
		end
	end

	-- Update occlusion amount if timeout time has passed
	if currentTime >= self.lastOcclusionReachedTime + self.timeUntilZoomOut and not self.zoomState then
		if self.curOcclusionTween == nil then
			self.occlusionTweenObject.Value = self.lastOcclusionDistance
			local tweenInfo = TweenInfo.new(self.tweenOutTime)
			local goal = {}
			goal.Value = self.lastOcclusionDistance - self.normalOffset.Z
			self.curOcclusionTween = TweenService:Create(self.occlusionTweenObject, tweenInfo, goal)
			self.curOcclusionTween:Play()
		end
	end

	-- Apply occlusion to camera CFrame
	local currentOffsetDir = self.currentCFrame.LookVector.Unit
	self.currentCFrame = self.currentCFrame + (currentOffsetDir * self.lastOcclusionDistance)
	self.currentCamera.CFrame = self.currentCFrame

	-- Apply recoil decay
	self.currentRecoil = self.currentRecoil - (self.currentRecoil * self.recoilDecay * dt)

	if self:isHumanoidControllable() and self.rotateCharacterWithCamera then
		self.currentHumanoid.AutoRotate = false
		self.currentRootPart.CFrame = CFrame.Angles(0, self.yaw, 0) + self.currentRootPart.Position -- rotate character to be upright and facing the same direction as camera
		self:applyRootJointFix()
	else
		self.currentHumanoid.AutoRotate = true
	end

	self:handlePartTransparencies()
	self:handleTouchToolFiring()
end

-- This function keeps the held weapon from bouncing up and down too much when you move
function ShoulderCamera:applyRootJointFix()
	if self.rootJoint then
		local translationScale = self.zoomState and Vector3.new(0.25, 0.25, 0.25) or Vector3.new(0.5, 0.5, 0.5)
		local rotationScale = self.zoomState and 0.15 or 0.2
		local rootRotation = self.rootJoint.Part0.CFrame - self.rootJoint.Part0.CFrame.Position
		local rotation = self.rootJoint.Transform - self.rootJoint.Transform.Position
		local yawRotation = CFrame.Angles(0, self.yaw, 0)
		local leadRotation = rootRotation:toObjectSpace(yawRotation)
		local rotationFix = self.rootRigAttach.CFrame
		if self:isHumanoidControllable() then
			rotationFix = self.rootJoint.Transform:inverse() * leadRotation * rotation:Lerp(CFrame.new(), 1 - rotationScale) + (self.rootJoint.Transform.Position * translationScale)
		end

		self.rootJoint.C0 = CFrame.new(self.rootJoint.C0.Position, self.rootJoint.C0.Position + rotationFix.LookVector.Unit)
	end
end

function ShoulderCamera:sprintFromTouchInput()
	local moveVector = nil
	local activeController = nil
	local activeControllerIsTouch = nil
	if self.controlModule then
		moveVector = self.controlModule:GetMoveVector()
		activeController = self.controlModule:GetActiveController()
	end
	if moveVector and activeController then
		activeControllerIsTouch = activeController.thumbstickFrame ~= nil or activeController.thumbpadFrame ~= nil
	end

	if activeControllerIsTouch then
		return (moveVector and moveVector.Magnitude >= 0.9)
	else
		return false
	end
end

function ShoulderCamera:sprintFromGamepadInput()
	return self.movementPan.Magnitude > 0.9
end

function ShoulderCamera:onCurrentCharacterChanged(character)
	self.currentCharacter = character
	if self.currentCharacter then
		self.raycastIgnoreList[1] = self.currentCharacter
		self.currentHumanoid = character:WaitForChild("Humanoid")
		self.currentRootPart = character:WaitForChild("HumanoidRootPart")

		self.rootRigAttach = self.currentRootPart:WaitForChild("RootRigAttachment")
		self.rootJoint = character:WaitForChild("LowerTorso"):WaitForChild("Root")
		self.currentWaist = character:WaitForChild("UpperTorso"):WaitForChild("Waist")
		self.currentWrist = character:WaitForChild("RightHand"):WaitForChild("RightWrist")
		self.wristAttach0 = character:WaitForChild("RightLowerArm"):WaitForChild("RightWristRigAttachment")
		self.wristAttach1 = character:WaitForChild("RightHand"):WaitForChild("RightWristRigAttachment")
		self.rightGripAttachment = character:WaitForChild("RightHand"):WaitForChild("RightGripAttachment")

		self.currentTool = character:FindFirstChildOfClass("Tool")

		self.eventConnections.humanoidDied = self.currentHumanoid.Died:Connect(function()
			self.zoomedFromInput = false
			self:updateZoomState()
		end)
		self.eventConnections.characterChildAdded = character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.currentTool = child
				self:updateZoomState()
			end
		end)
		self.eventConnections.characterChildRemoved = character.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") and self.currentTool == child then
				self.currentTool = character:FindFirstChildOfClass("Tool")
				self:updateZoomState()
			end
		end)

		if Players.LocalPlayer then
			local PlayerScripts = Players.LocalPlayer:FindFirstChild("PlayerScripts")
			if PlayerScripts then
				local PlayerModule = PlayerScripts:FindFirstChild("PlayerModule")
				if PlayerModule then
					self.controlModule = require(PlayerModule:FindFirstChild("ControlModule"))
				end
			end
		end
	else
		if self.eventConnections.humanoidDied then
			self.eventConnections.humanoidDied:Disconnect()
			self.eventConnections.humanoidDied = nil
		end
		if self.eventConnections.characterChildAdded then
			self.eventConnections.characterChildAdded:Disconnect()
			self.eventConnections.characterChildAdded = nil
		end
		if self.eventConnections.characterChildRemoved then
			self.eventConnections.characterChildRemoved:Disconnect()
			self.eventConnections.characterChildRemoved = nil
		end

		self.currentTool = nil
		self.currentHumanoid = nil
		self.currentRootPart = nil
		self.controlModule = nil
	end
end

function ShoulderCamera:onCurrentCameraChanged(camera)
	if self.currentCamera == camera then
		return
	end

	self.currentCamera = camera

	if self.currentCamera then
		self.raycastIgnoreList[2] = self.currentCamera

		if self.eventConnections.cameraTypeChanged then
			self.eventConnections.cameraTypeChanged:Disconnect()
			self.eventConnections.cameraTypeChanged = nil
		end
		self.eventConnections.cameraTypeChanged = self.currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
			if self.enabled then
				self.currentCamera.CameraType = Enum.CameraType.Scriptable
			end
		end)
	end
end

function ShoulderCamera:isHumanoidControllable()
	if not self.currentHumanoid then
		return false
	end
	local humanoidState = self.currentHumanoid:GetState()
	return CONTROLLABLE_HUMANOID_STATES[humanoidState] == true
end

function ShoulderCamera:getCollisionRadius()
	if not self.currentCamera then
		return 0
	end
	local viewportSize = self.currentCamera.ViewportSize
	local aspectRatio = viewportSize.X / viewportSize.Y
	local fovRads = math.rad(self.fieldOfView)
	local imageHeight = math.tan(fovRads) * math.abs(self.currentCamera.NearPlaneZ)
	local imageWidth = imageHeight * aspectRatio

	local cornerPos = Vector3.new(imageWidth, imageHeight, self.currentCamera.NearPlaneZ)
	return cornerPos.Magnitude
end

function ShoulderCamera:penetrateCast(ray, ignoreList)
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function ShoulderCamera:getRelativePitch()
	if self.currentRootPart then
		local pitchRotation = CFrame.Angles(self.pitch, 0, 0)
		local relativeRotation = self.currentRootPart.CFrame:toObjectSpace(pitchRotation)
		local relativeLook = relativeRotation.lookVector

		local angle = math.asin(relativeLook.Y)
		return math.clamp(angle, self.minPitch, self.maxPitch)
	end
	return self.pitch
end

function ShoulderCamera:getCurrentFieldOfView()
	if self.zoomState then
		return self.zoomedFOV
	else
		return self.fieldOfView
	end
end

function ShoulderCamera:handlePartTransparencies()
	local partsLookup = {}
	local accoutrementsLookup = {}

	for _, child in pairs(self.currentCharacter:GetChildren()) do
		local hidden = false
		if child:IsA("BasePart") then
			hidden = partsLookup[child.Name] == true
			child.LocalTransparencyModifier = hidden and 1 or 0
		elseif child:IsA("Accoutrement") then
			local descendants = child:GetDescendants()
			local accoutrementParts = {}
			for _, desc in pairs(descendants) do
				if desc:IsA("Attachment") and accoutrementsLookup[desc.Name] then
					hidden = true
				elseif desc:IsA("BasePart") then
					table.insert(accoutrementParts, desc)
				end
			end
			for _, part in pairs(accoutrementParts) do
				part.LocalTransparencyModifier = hidden and 1 or 0
			end
		elseif child:IsA("Tool") then
			hidden = self.zoomState and (self.hasScope or self.hideToolWhileZoomed)
			for _, part in pairs(child:GetDescendants()) do
				if part:IsA("BasePart") then
					part.LocalTransparencyModifier = hidden and 1 or 0
				end
			end
		end
	end
end

function ShoulderCamera:setSprintEnabled(enabled)
	self.sprintEnabled = enabled
end

function ShoulderCamera:setSlowZoomWalkEnabled(enabled)
	self.slowZoomWalkEnabled = enabled
end

function ShoulderCamera:setHasScope(hasScope)
	if self.hasScope == hasScope then
		return
	end

	self.hasScope = hasScope
	self:updateZoomState()
end

function ShoulderCamera:onSprintAction(actionName, inputState, inputObj)
	self.sprintingInputActivated = inputState == Enum.UserInputState.Begin
end


-- Zoom related functions

function ShoulderCamera:isZoomed()
	return self.zoomState
end

function ShoulderCamera:setHideToolWhileZoomed(hide)
	self.hideToolWhileZoomed = hide
end

function ShoulderCamera:setZoomFactor(zoomFactor)
	self.currentZoomFactor = zoomFactor
	local nominalFOVRadians = math.rad(self.fieldOfView)
	local nominalImageHeight = math.tan(nominalFOVRadians / 2)
	local zoomedImageHeight = nominalImageHeight / self.currentZoomFactor
	self.zoomedFOV = math.deg(math.atan(zoomedImageHeight) * 2)
	self:updateZoomState()
end

function ShoulderCamera:resetZoomFactor()
	self:setZoomFactor(self.defaultZoomFactor)
end

function ShoulderCamera:setForceZoomed(zoomed)
	if self.forcedZoomed == zoomed then return end
	self.forcedZoomed = zoomed
	self:updateZoomState()
end

function ShoulderCamera:setZoomedFromInput(zoomedFromInput)
	if self.zoomedFromInput == zoomedFromInput or (self.currentHumanoid and self.currentHumanoid:GetState() == Enum.HumanoidStateType.Dead) then
		return
	end

	self.zoomedFromInput = zoomedFromInput
	self:updateZoomState()
end

function ShoulderCamera:updateZoomState()
	local isZoomed = self.forcedZoomed
	if self.canZoom and not self.forcedZoomed then
		isZoomed = self.zoomedFromInput
	end

	if not self.enabled or not self.currentTool then
		isZoomed = false
	end

	self.zoomState = isZoomed

	self.currentMouseRadsPerPixel = isZoomed and self.zoomedMouseRadsPerPixel or self.mouseRadsPerPixel
	self.currentTouchSensitivity = isZoomed and self.zoomedTouchSensitivity or self.touchSensitivity

	if self.weaponsSystem and self.weaponsSystem.gui then
		self.weaponsSystem.gui:setCrosshairScaleTarget(self.zoomState and self.zoomedCrosshairScale or self.normalCrosshairScale)
		self.weaponsSystem.gui:setCrosshairEnabled(not self.zoomState or not self.hasScope)
		self.weaponsSystem.gui:setScopeEnabled(self.zoomState and self.hasScope)
		if self.currentTool then
			self.currentTool.ManualActivationOnly = self.zoomState and self.hasScope and UserInputService.TouchEnabled
		end
	end

	if self.currentCamera then
		self.desiredFieldOfView = self:getCurrentFieldOfView()
	end
end

function ShoulderCamera:onZoomAction(actionName, inputState, inputObj)
	if not self.enabled or not self.canZoom or not self.currentCamera or not self.currentCharacter or not self.weaponsSystem.currentWeapon then
		self:setZoomedFromInput(false)
		return Enum.ContextActionResult.Pass
	end

	self:setZoomedFromInput(inputState == Enum.UserInputState.Begin)
	return Enum.ContextActionResult.Sink
end


-- Recoil related functions

function ShoulderCamera:setCurrentRecoilIntensity(x, y)
	self.currentRecoil = Vector2.new(x, y)
end

function ShoulderCamera:addRecoil(recoilAmount)
	self.currentRecoil = self.currentRecoil + recoilAmount
end


-- Input related functions

function ShoulderCamera:applyInput(yaw, pitch)
	local yInvertValue = UserGameSettings:GetCameraYInvertValue()
	self.yaw = self.yaw + yaw
	self.pitch = math.clamp(self.pitch + pitch * yInvertValue, self.minPitch, self.maxPitch)
end

function ShoulderCamera:processGamepadInput(dt)
	local gamepadPan = self.gamepadPan
	if gamepadPan then
		gamepadPan = gamepadLinearToCurve(gamepadPan)
		if gamepadPan.X == 0 and gamepadPan.Y == 0 then
			self.lastThumbstickTime = nil
			if self.lastThumbstickPos.X == 0 and self.lastThumbstickPos.Y == 0 then
				self.currentGamepadSpeed = 0
			end
		end

		local finalConstant = 0
		local currentTime = tick()

		if self.lastThumbstickTime then
			local elapsed = (currentTime - self.lastThumbstickTime) * 10
			self.currentGamepadSpeed = self.currentGamepadSpeed + (6 * ((elapsed ^ 2) / 0.7))

			if self.currentGamepadSpeed > 6 then self.currentGamepadSpeed = 6 end

			if self.lastGamepadVelocity then
				local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
				local velocityDeltaMag = (velocity - self.lastGamepadVelocity).Magnitude

				if velocityDeltaMag > 12 then
					self.currentGamepadSpeed = self.currentGamepadSpeed * (20 / velocityDeltaMag)
					if self.currentGamepadSpeed > 6 then
						self.currentGamepadSpeed = 6
					end
				end
			end

			finalConstant = GameSettings.GamepadCameraSensitivity * self.currentGamepadSpeed * dt
			self.lastGamepadVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickTime = currentTime

		local yawInput = -gamepadPan.X * finalConstant * self.gamepadSensitivityModifier.X
		local pitchInput = finalConstant * gamepadPan.Y * GameSettings:GetCameraYInvertValue() * self.gamepadSensitivityModifier.Y

		self:applyInput(yawInput, pitchInput)
	end
end

function ShoulderCamera:handleTouchToolFiring()
	if self.touchObj then
		if self.lastTapEndTime then -- and not (self.zoomState and self.hasScope) then
			local touchTime = tick() - self.lastTapEndTime
			if touchTime < self.touchDelayTime and self.currentTool and self.touchPanAccumulator.Magnitude < 0.5 and not self.firingTool and not self.applyingTouchPan then
				self.firingTool = true
				self.currentTool:Activate()
			end
		end
	else
		if self.currentTool and self.firingTool then
			self.currentTool:Deactivate()
		end
		self.firingTool = false
	end
end

function ShoulderCamera:isTouchPositionForCamera(pos)
	if LocalPlayer then
		local guiObjects = LocalPlayer.PlayerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)
		for _, guiObject in ipairs(guiObjects) do
			if guiObject.Name == "DynamicThumbstickFrame" then
				return false
			end
		end
		return true
	end
	return false
end

function ShoulderCamera:onInputBegan(inputObj, wasProcessed)
	if self.touchObj then
		self.touchObj = nil
		wasProcessed = false
	end

	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		local touchStartPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
		if not wasProcessed and self:isTouchPositionForCamera(touchStartPos) and not self.touchObj then
			self.touchObj = inputObj
			self.touchStartTime = tick()
			self.eventConnections.touchChanged = inputObj.Changed:Connect(function(prop)
				if prop == "Position" then
					local touchTime = tick() - self.touchStartTime

					local newTouchPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
					local delta = (newTouchPos - touchStartPos) * self.currentTouchSensitivity
					local yawInput = -delta.X
					local pitchInput = -delta.Y
					if self.touchPanAccumulator.Magnitude > 0.01 and touchTime > self.touchDelayTime then
						if not self.applyingTouchPan then
							self.applyingTouchPan = true
							self.touchPanAccumulator = Vector2.new(0, 0)
						end
					end
					self:applyInput(yawInput, pitchInput)
					self.touchPanAccumulator = self.touchPanAccumulator + Vector2.new(yawInput, pitchInput)
					touchStartPos = newTouchPos
				end
			end)
		end
	end
end

function ShoulderCamera:onInputChanged(inputObj, wasProcessed)
	if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
		local yawInput = -inputObj.Delta.X * self.currentMouseRadsPerPixel.X
		local pitchInput = -inputObj.Delta.Y * self.currentMouseRadsPerPixel.Y

		self:applyInput(yawInput, pitchInput)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	end
end

function ShoulderCamera:onInputEnded(inputObj, wasProcessed)
	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(0, 0)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(0, 0)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		if self.touchObj == inputObj then
			if self.eventConnections and self.eventConnections.touchChanged then
				self.eventConnections.touchChanged:Disconnect()
				self.eventConnections.touchChanged = nil
			end

			local touchTime = tick() - self.touchStartTime
			if self.currentTool and self.firingTool then
				self.currentTool:Deactivate()
			elseif self.zoomState and self.hasScope and touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.currentTool:Activate() -- this makes sure to shoot the sniper with a single tap when it is zoomed in
				self.currentTool:Deactivate()
			end
			self.firingTool = false

			self.touchPanAccumulator = Vector2.new(0, 0)
			if touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.lastTapEndTime = tick()
			else
				self.lastTapEndTime = nil
			end
			self.applyingTouchPan = false

			self.gamepadPan = Vector2.new(0, 0)
			self.touchObj = nil
		end
	end
end

return ShoulderCamera

end))
ModuleScript310.Name = "SpringService"
ModuleScript310.Parent = Folder303
table.insert(cors,sandbox(ModuleScript310,function()
-- SpringService.lua
-- Binds properties to spring simulations
-- @author Parker Stebbins <pstebbins@roblox.com>

local RunService = game:GetService('RunService')

local LinearSpring = {} do
	LinearSpring.__index = LinearSpring

	local pi = math.pi
	local exp = math.exp
	local sin = math.sin
	local cos = math.cos
	local sqrt = math.sqrt

	function LinearSpring.new(dampingRatio, frequency, goal)
		assert(
			dampingRatio*frequency >= 0,
			'No steady state solution for the given damping ratio & frequency'
		)

		return setmetatable(
			{
				d = dampingRatio, -- Damping ratio - Dimensionless
				f = frequency, -- Undamped frequency - Hertz
				g = goal, -- Goal position - Vector
				v = goal*0, -- Current velocity - Vector
			},
			LinearSpring
		)
	end

	function LinearSpring:setGoal(goal)
		self.g = goal
	end

	function LinearSpring:canSleep()
		return false -- @todo add sleeping
	end

	function LinearSpring:step(dt, p0)

		-- Problem: Advance the spring simulation by t seconds.
		-- Start by taking the ODE of a damped harmonic oscillator:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is desired position, f is angular frequency, and d is damping ratio.
		-- Apply some constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- The IVP can now be solved to obtain analytic expressions for X[t] and X'[t].
		-- The solution takes on one of three forms depending on the value of d.

		local d = self.d
		local f = self.f*pi*2 -- cycle/s -> rad/s
		local g = self.g
		local v0 = self.v

		local o = p0 - g
		local decay = exp(-dt*d*f)

		local p1, v1

		if d == 1 then -- Critically damped

			p1 = (v0*dt + o*(f*dt + 1))*decay + g
			v1 = (v0 - (o*f + v0)*(f*dt))*decay

		elseif d < 1 then -- Underdamped

			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- @todo improve stability as d approaches 1

			p1 = (o*i + (v0 + o*(d*f))*j/(f*c))*decay + g
			v1 = (v0*(i*c) - (v0*d + o*f)*j)*(decay/c)

		else -- Overdamped

			local c = sqrt(d*d - 1)

			local r1 = -f*(d - c)
			local r2 = -f*(d + c)

			-- @todo improve stability as d approaches 1

			local co2 = (v0 - o*r1)/(2*f*c)
			local co1 = o - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			p1 = e1 + e2 + g
			v1 = r1*e1 + r2*e2
		end

		self.v = v1

		return p1
	end
end

local LinearValue = {} do
	LinearValue.__index = LinearValue

	function LinearValue.new(...)
		return setmetatable(
			{
				...
			},
			LinearValue
		)
	end

	function LinearValue:__add(rhs)
		-- vector + vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] + rhs[i]
		end

		return out
	end

	function LinearValue:__sub(rhs)
		-- vector - vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] - rhs[i]
		end

		return out
	end

	function LinearValue:__mul(rhs)
		-- vector*scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]*rhs
		end

		return out
	end

	function LinearValue:__div(rhs)
		-- vector/scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]/rhs
		end

		return out
	end
end

local springMetadata = {
	-- Defines a spring type with functions for converting to/from values that the spring can digest
	number = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value)
		end,
		fromIntermediate = function(value)
			return value[1]
		end,
	},

	UDim = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.Scale, value.Offset)
		end,
		fromIntermediate = function(value)
			return UDim.new(value[1], value[2])
		end,
	},

	UDim2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return LinearValue.new(x.Scale, x.Offset, y.Scale, y.Offset)
		end,
		fromIntermediate = function(value)
			return UDim2.new(value[1], value[2], value[3], value[4])
		end,
	},

	Vector2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y)
		end,
		fromIntermediate = function(value)
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y, value.Z)
		end,
		fromIntermediate = function(value)
			return Vector3.new(value[1], value[2], value[3])
		end,
	},
}

local springStates = {} -- {[object] = {[property] = Spring}

local steppedEvent = RunService:IsClient() and RunService.RenderStepped or RunService.Heartbeat
steppedEvent:Connect(function(dt)
	for object, state in pairs(springStates) do
		for name, spring in pairs(state) do
			local oldValue = object[name]
			local meta = assert(springMetadata[typeof(oldValue)])

			local oldIntermediate = meta.toIntermediate(oldValue)
			local newIntermediate = spring:step(dt, oldIntermediate)

			if spring:canSleep() then
				state[name] = nil
			end

			object[name] = meta.fromIntermediate(newIntermediate)
		end

		if not next(state) then
			springStates[object] = nil
		end
	end
end)

local SpringService = {} do
	function SpringService:Target(object, dampingRatio, frequency, properties)
		local state = springStates[object]

		if not state then
			state = {}
			springStates[object] = state
		end

		for name, goal in pairs(properties) do
			local spring = state[name]

			local meta = assert(
				springMetadata[typeof(goal)],
				'Unsupported type: ' .. typeof(goal)
			)
			local intermediateGoal = meta.toIntermediate(goal)

			if spring then
				spring:setGoal(intermediateGoal)
			else
				spring = meta.springType.new(dampingRatio, frequency, intermediateGoal)
				state[name] = spring
			end
		end
	end

	function SpringService:Stop(object, property)
		if property then
			-- Unbind a property
			local state = springStates[object]
			if state then
				state[property] = nil
			end
		else
			-- Unbind all the properties
			springStates[object] = nil
		end
	end
end

return SpringService

end))
ModuleScript311.Name = "WeaponsGui"
ModuleScript311.Parent = Folder303
table.insert(cors,sandbox(ModuleScript311,function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer

local WeaponsSystemFolder = script.Parent.Parent
local WeaponData = WeaponsSystemFolder:WaitForChild("WeaponData")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local SpringService = require(Libraries:WaitForChild("SpringService"))

local DirectionalIndicatorGuiManager = require(Libraries:WaitForChild("DirectionalIndicatorGuiManager"))
local DamageBillboardHandler = require(Libraries:WaitForChild("DamageBillboardHandler"))

local WeaponsSystemGuiTemplate = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("WeaponsSystemGui")

local AIM_ON_NORMAL = "rbxassetid://2804583948"
local AIM_OFF_NORMAL = "rbxassetid://2804597178"
local AIM_ON_PRESSED = "rbxassetid://2804598866"
local AIM_OFF_PRESSED = "rbxassetid://2804599869"

local FIRE_NORMAL = "rbxassetid://2804818047"
local FIRE_PRESSED = "rbxassetid://2804818076"

local WeaponsGui = {}
WeaponsGui.__index = WeaponsGui

function WeaponsGui.new(weaponsSystem)
	local self = setmetatable({}, WeaponsGui)
	self.weaponsSystem = weaponsSystem
	self.connections = {}
	self.enabled = false

	self.referenceViewportSize = Vector2.new(1000, 1000) -- viewport size that ui elements in scalingElementsFolder were designed on
	self.scaleWeight = 0.75 -- determines weight of scaling (a higher value increases the degree to which elements are scaled)
	self.originalScaleAmounts = {}

	self.crosshairDampingRatio = 0.9
	self.crosshairFrequency = 3
	self.crosshairScaleTarget = 1
	self.crosshairScale = 1
	self.crosshairWeaponScale = 1
	self.crosshairEnabled = true

	self.scopeEnabled = false
	self.isZoomed = false

	self.gui = WeaponsSystemGuiTemplate:Clone()
	self.gui.Enabled = false

	coroutine.wrap(function()
		self.scalingElementsFolder = self.gui:WaitForChild("ScalingElements")

		self.DirectionalIndicatorGuiManager = DirectionalIndicatorGuiManager.new(self)

		self.crosshairFrame = self.scalingElementsFolder:WaitForChild("Crosshair")
		self.crosshairBottom = self.crosshairFrame:WaitForChild("Bottom")
		self.crosshairLeft = self.crosshairFrame:WaitForChild("Left")
		self.crosshairRight = self.crosshairFrame:WaitForChild("Right")
		self.crosshairTop = self.crosshairFrame:WaitForChild("Top")
		self.origCrosshairScales = {} -- these will be used to size crosshair pieces when screen size changes
		self.origCrosshairScales[self.crosshairBottom] = Vector2.new(self.crosshairBottom.Size.X.Scale, self.crosshairBottom.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairLeft] = Vector2.new(self.crosshairLeft.Size.X.Scale, self.crosshairLeft.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairRight] = Vector2.new(self.crosshairRight.Size.X.Scale, self.crosshairRight.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairTop] = Vector2.new(self.crosshairTop.Size.X.Scale, self.crosshairTop.Size.Y.Scale)
		self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

		self.hitMarker = self.scalingElementsFolder:WaitForChild("HitMarker"):WaitForChild("HitMarkerImage")

		self.scopeFrame = self.gui:WaitForChild("Scope")
		local scopeImage = self.scopeFrame:WaitForChild("ScopeImage")

		self.smallTouchscreen = self.gui:WaitForChild("SmallTouchscreen")
		self.largeTouchscreen = self.gui:WaitForChild("LargeTouchscreen")

		self.smallAimButton = self.smallTouchscreen:WaitForChild("AimButton")
		self.smallAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.largeAimButton = self.largeTouchscreen:WaitForChild("AimButton")
		self.largeAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.smallFireButton = self.smallTouchscreen:WaitForChild("FireButton")
		self.smallFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.smallFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)
		self.largeFireButton = self.largeTouchscreen:WaitForChild("FireButton")
		self.largeFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.largeFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)

		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		self.gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
		self.gui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() self:onScreenSizeChanged() end)
		self:onScreenSizeChanged()

		WeaponData.OnClientEvent:Connect(function(cmd, otherPlayerPosition)
			if cmd == "HitByOtherPlayer" then
				self.DirectionalIndicatorGuiManager:ActivateDirectionalIndicator("DamageIndicator", otherPlayerPosition)
			end
		end)

		ContentProvider:PreloadAsync({
			self.crosshairBottom,
			self.crosshairLeft,
			self.crosshairRight,
			self.crosshairTop,
			scopeImage,
			self.smallAimButton,
			self.largeAimButton,
			self.smallFireButton,
			self.largeFireButton,
		})
	end)()

	return self
end

local function getJumpButton()
	if UserInputService.TouchEnabled then
		local touchGui = LocalPlayer.PlayerGui:WaitForChild("TouchGui")
		return touchGui.TouchControlFrame:FindFirstChild("JumpButton")
	end

	return nil
end

function WeaponsGui:onScreenSizeChanged()
	if self.smallTouchscreen and self.largeTouchscreen then
		if UserInputService.TouchEnabled then
			local isSmallScreen
			local jumpButton = getJumpButton()
			if jumpButton then
				isSmallScreen = jumpButton.Size.X.Offset <= 70
			else
				isSmallScreen = self.gui.AbsoluteSize.Y < 600
			end
			self.smallTouchscreen.Visible = isSmallScreen
			self.largeTouchscreen.Visible = not isSmallScreen
		else
			self.smallTouchscreen.Visible = false
			self.largeTouchscreen.Visible = false
		end
	end

	-- Scales all ui elements in scalingElementsFolder based on current screen size relative to self.referenceViewportSize
	local viewportSize = workspace.CurrentCamera.ViewportSize
	for _, child in pairs(self.scalingElementsFolder:GetChildren()) do
		self:updateScale(child, viewportSize)
	end

	self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

	-- Update crosshair sizes...they must use offset because crosshairFrame changes size frequently
	self.crosshairBottom.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairBottom].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairBottom].Y * self.crosshairNormalSize.Y)
	self.crosshairLeft.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairLeft].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairLeft].Y * self.crosshairNormalSize.Y)
	self.crosshairRight.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairRight].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairRight].Y * self.crosshairNormalSize.Y)
	self.crosshairTop.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairTop].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairTop].Y * self.crosshairNormalSize.Y)
end

-- This scales the scale amount non-linearly according to scaleWeight
function WeaponsGui:getWeightedScaleAmount(originalScaleAmount, newScreenDim, referenceScreenDim)
	return (1 - self.scaleWeight) * originalScaleAmount * referenceScreenDim / newScreenDim + self.scaleWeight * originalScaleAmount
end

function WeaponsGui:updateScale(guiObject, viewportSize)
	if guiObject:IsA("GuiObject") then
		local xScale = guiObject.Size.X.Scale
		local yScale = guiObject.Size.Y.Scale
		if xScale ~= 0 or yScale ~= 0 or self.originalScaleAmounts[guiObject] ~= nil then
			if self.originalScaleAmounts[guiObject] == nil then
				self.originalScaleAmounts[guiObject] = Vector2.new(xScale, yScale)
			end

			xScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].X, viewportSize.X, self.referenceViewportSize.X)
			yScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].Y, viewportSize.Y, self.referenceViewportSize.Y)
			guiObject.Size = UDim2.new(xScale, 0, yScale, 0)
		end
		return -- makes it so only the most outer container will be scaled
	end

	for _, child in ipairs(guiObject:GetChildren()) do
		self:updateScale(child, viewportSize)
	end
end

function WeaponsGui:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end

	self.enabled = enabled
	if self.enabled then
		self.connections.renderStepped = RunService.RenderStepped:Connect(function(dt) self:onRenderStepped(dt) end)
	else
		self:setZoomed(false)

		for _, v in pairs(self.connections) do
			v:Disconnect()
		end
		self.connections = {}
	end

	if self.gui then
		self.gui.Enabled = self.enabled
	end
end

function WeaponsGui:setCrosshairEnabled(crosshairEnabled)
	if self.crosshairEnabled == crosshairEnabled then
		return
	end

	self.crosshairEnabled = crosshairEnabled
	if self.crosshairFrame then
		self.crosshairFrame.Visible = self.crosshairEnabled
	end
	if self.hitMarker then
		self.hitMarker.ImageTransparency = 1
		self.hitMarker.Visible = self.crosshairEnabled
	end
end

function WeaponsGui:setScopeEnabled(scopeEnabled)
	if self.scopeEnabled == scopeEnabled then
		return
	end

	self.scopeEnabled = scopeEnabled
	if self.scopeFrame then
		self.scopeFrame.Visible = self.scopeEnabled
	end

	local jumpButton = getJumpButton()

	if self.scopeEnabled then
		self.smallFireButton.Visible = true
		self.largeFireButton.Visible = true

		if jumpButton then
			jumpButton.Visible = false
		end
	else
		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		if jumpButton then
			jumpButton.Visible = true
		end
	end
end

function WeaponsGui:setCrosshairWeaponScale(scale)
	if self.crosshairWeaponScale == scale then
		return
	end

	self.crosshairWeaponScale = scale
end

function WeaponsGui:setCrosshairScaleTarget(target, dampingRatio, frequency)
	if typeof(dampingRatio) == "number" then
		self.crosshairDampingRatio = dampingRatio
	end
	if typeof(frequency) == "number" then
		self.crosshairFrequency = frequency
	end
	if self.crosshairScaleTarget == target then
		return
	end

	self.crosshairScaleTarget = target
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:setCrosshairScale(scale)
	if self.crosshairScale == scale then
		return
	end

	self.crosshairScale = scale
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:OnHitOtherPlayer(damage, humanoidHit) -- show hit indicator, then fade
	self.hitMarker.ImageTransparency = 0
	local tweenInfo = TweenInfo.new(0.8)
	local goal = {}
	goal.ImageTransparency = 1
	local tween = TweenService:Create(self.hitMarker, tweenInfo, goal)
	tween:Play()

	DamageBillboardHandler:ShowDamageBillboard(damage, humanoidHit.Parent:FindFirstChild("Head"))
end

function WeaponsGui:onRenderStepped(dt)
	if not self.enabled then
		return
	end
	if not self.gui then
		return
	end

	if self.crosshairFrame and self.crosshairEnabled then
		local crosshairSize = self.crosshairNormalSize * self.crosshairScale * self.crosshairWeaponScale
		self.crosshairFrame.Size = UDim2.new(0, crosshairSize.X, 0, crosshairSize.Y)
	end
end

function WeaponsGui:setZoomed(zoomed)
	if zoomed == self.isZoomed then
		return
	end

	self.isZoomed = zoomed
	local normalImage = self.isZoomed and AIM_OFF_NORMAL or AIM_ON_NORMAL
	local pressedImage = self.isZoomed and AIM_OFF_PRESSED or AIM_ON_PRESSED

	if self.smallAimButton then
		self.smallAimButton.Image = normalImage
		self.smallAimButton.PressedImage = pressedImage
	end
	if self.largeAimButton then
		self.largeAimButton.Image = normalImage
		self.largeAimButton.PressedImage = pressedImage
	end

	if self.weaponsSystem.camera then
		self.weaponsSystem.camera:setForceZoomed(self.isZoomed)
	end
end

function WeaponsGui:onTouchAimButtonActivated()
	self:setZoomed(not self.isZoomed)
end

function WeaponsGui:onTouchFireButton(inputObj, inputState)
	local currentWeapon = self.weaponsSystem.currentWeapon
	if currentWeapon and currentWeapon.instance and currentWeapon.instance:IsA("Tool") then
		if inputObj.UserInputState == Enum.UserInputState.Begin then
			currentWeapon.instance:Activate()
			if self.smallFireButton then
				self.smallFireButton.Image = FIRE_PRESSED
			end
			if self.largeFireButton then
				self.largeFireButton.Image = FIRE_PRESSED
			end

			inputObj:GetPropertyChangedSignal("UserInputState"):Connect(function()
				if inputObj.UserInputState == Enum.UserInputState.End then
					currentWeapon.instance:Deactivate()
					if self.smallFireButton then
						self.smallFireButton.Image = FIRE_NORMAL
					end
					if self.largeFireButton then
						self.largeFireButton.Image = FIRE_NORMAL
					end
				end
			end)
		end
	end
end

return WeaponsGui
end))
ModuleScript312.Name = "ancestorHasTag"
ModuleScript312.Parent = Folder303
table.insert(cors,sandbox(ModuleScript312,function()
local CollectionService = game:GetService("CollectionService")

local function ancestorHasTag(instance, tag)
	local currentInstance = instance
	while currentInstance do
		if CollectionService:HasTag(currentInstance, tag) then
			return true
		else
			currentInstance = currentInstance.Parent
		end
	end

	return false
end

return ancestorHasTag
end))
ModuleScript313.Name = "BaseWeapon"
ModuleScript313.Parent = Folder303
table.insert(cors,sandbox(ModuleScript313,function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local AnimationsFolder = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Animations")

local localRandom = Random.new()

local BaseWeapon = {}
BaseWeapon.__index = BaseWeapon

BaseWeapon.CanAimDownSights = false
BaseWeapon.CanBeReloaded = false
BaseWeapon.CanBeFired = false
BaseWeapon.CanHit = false

function BaseWeapon.new(weaponsSystem, instance)
	assert(instance, "BaseWeapon.new() requires a valid Instance to be attached to.")

	local self = setmetatable({}, BaseWeapon)
	self.connections = {}
	self.descendants = {}
	self.descendantsRegistered = false
	self.optionalDescendantNames = {}
	self.weaponsSystem = weaponsSystem
	self.instance = instance
	self.animController = nil
	self.player = nil
	self.enabled = false
	self.equipped = false
	self.activated = false
	self.nextShotId = 1
	self.activeRenderStepName = nil
	self.curReloadSound = nil

	self.animTracks = {}
	self.sounds = {}
	self.configValues = {}
	self.trackedConfigurations = {}

	self.ammoInWeaponValue = nil

	self.reloading = false
	self.canReload = true

	self:registerDescendants()
	self.connections.descendantAdded = self.instance.DescendantAdded:Connect(function(descendant)
		self:onDescendantAdded(descendant)
	end)

	return self
end

function BaseWeapon:doInitialSetup()
	local selfClass = getmetatable(self)
	self.instanceIsTool = self.instance:IsA("Tool")

	-- Set up child added/removed
	self.connections.childAdded = self.instance.ChildAdded:Connect(function(child)
		self:onChildAdded(child)
	end)
	self.connections.childRemoved = self.instance.ChildRemoved:Connect(function(child)
		self:onChildRemoved(child)
	end)
	for _, child in pairs(self.instance:GetChildren()) do
		self:onChildAdded(child)
	end

	-- Initialize self.ammoInWeaponValue
	if selfClass.CanBeReloaded then
		if IsServer then
			self.ammoInWeaponValue = self.instance:FindFirstChild("CurrentAmmo")
			if not self.ammoInWeaponValue then
				self.ammoInWeaponValue = Instance.new("IntValue")
				self.ammoInWeaponValue.Name = "CurrentAmmo"
				self.ammoInWeaponValue.Value = 0
				self.ammoInWeaponValue.Parent = self.instance
			end
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		else
			self.ammoInWeaponValue = self.instance:WaitForChild("CurrentAmmo")
		end
	end

	self.connections.ancestryChanged = self.instance.AncestryChanged:Connect(function() self:onAncestryChanged() end)
	self:onAncestryChanged()

	-- Set up equipped/unequipped and activated/deactivated
	if self.instanceIsTool then
		self.connections.equipped = self.instance.Equipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(true)
				if self:getAmmoInWeapon() <= 0 then
					-- Have to wait a frame, otherwise the reload animation will not play
					coroutine.wrap(function()
						wait()
						self:reload()
					end)()
				end
			end
		end)
		self.connections.unequipped = self.instance.Unequipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(false)
				if self.reloading then
					self:cancelReload()
				end
			end
		end)
		if self.instance:IsDescendantOf(workspace) and self.player then
			self:setEquipped(true)
		end

		self.connections.activated = self.instance.Activated:Connect(function()
			self:setActivated(true)
		end)
		self.connections.deactivated = self.instance.Deactivated:Connect(function()
			self:setActivated(false)
		end)

		-- Weld handle to weapon primary part
		if IsServer then
			self.handle = self.instance:FindFirstChild("Handle")

			local model = self.instance:FindFirstChildOfClass("Model")
			local handleAttachment = model:FindFirstChild("HandleAttachment", true)

			if self.handle and handleAttachment then
				local handleOffset = model.PrimaryPart.CFrame:toObjectSpace(handleAttachment.WorldCFrame)

				local weld = Instance.new("Weld")
				weld.Name = "HandleWeld"
				weld.Part0 = self.handle
				weld.Part1 = model.PrimaryPart
				weld.C0 = CFrame.new()
				weld.C1 = handleOffset
				weld.Parent = self.handle

				self.handle.Anchored = false
				model.PrimaryPart.Anchored = false
			end
		end
	end
end

function BaseWeapon:registerDescendants()
	if not self.instance then
		error("No instance set yet!")
	end

	if self.descendantsRegistered then
		warn("Descendants already registered!")
		return
	end

	for _, descendant in ipairs(self.instance:GetDescendants()) do
		if self.descendants[descendant.Name] == nil then
			self.descendants[descendant.Name] = descendant
		else
			self.descendants[descendant.Name] = "Multiple"
		end
	end
	self.descendantsRegistered = true
end

function BaseWeapon:addOptionalDescendant(key, descendantName)
	if self.instance == nil then
		error("No instance set yet!")
	end

	if not self.descendantsRegistered then
		error("Descendants not registered!")
	end

	if self.descendants[descendantName] == "Multiple" then
		error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendantName.."\", so you cannot addOptionalDescendant with that descendant name.")
	end

	local found = self.descendants[descendantName]
	if found then
		self[key] = found
		return
	else
		self.optionalDescendantNames[descendantName] = key
	end
end

function BaseWeapon:onDescendantAdded(descendant)
	if self.descendants[descendant.Name] == nil then
		self.descendants[descendant.Name] = descendant
	else
		self.descendants[descendant.Name] = "Multiple"
	end

	local desiredKey = self.optionalDescendantNames[descendant.Name]
	if desiredKey then
		if self.descendants[descendant.Name] == "Multiple" then
			error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendant.Name.."\", so you cannot addOptionalDependency with that descendant name.")
		end
		self[desiredKey] = descendant
		self.optionalDescendantNames[descendant.Name] = nil
	end
end

function BaseWeapon:cleanupConnection(...)
	local args = { ... }
	for _, name in pairs(args) do
		if typeof(name) == "string" and self.connections[name] then
			self.connections[name]:Disconnect()
			self.connections[name] = nil
		end
	end
end

function BaseWeapon:onAncestryChanged()
	if self.instanceIsTool then
		local player = nil
		if self.instance:IsDescendantOf(Players) then
			local parentPlayer = self.instance.Parent.Parent
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		elseif self.instance:IsDescendantOf(workspace) then
			local parentPlayer = Players:GetPlayerFromCharacter(self.instance.Parent)
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		end

		self:setPlayer(player)
	end
end

function BaseWeapon:setPlayer(player)
	if self.player == player then
		return
	end

	self.player = player
end

function BaseWeapon:setEquipped(equipped)
	if self.equipped == equipped then
		return
	end

	self.equipped = equipped
	self:onEquippedChanged()

	if not self.equipped then
		self:stopAnimations()
	end
end

function BaseWeapon:onEquippedChanged()
	if self.activeRenderStepName then
		RunService:UnbindFromRenderStep(self.activeRenderStepName)
		self.activeRenderStepName = nil
	end
	self:cleanupConnection("localStepped")

	if not IsServer and self.weaponsSystem then
		self.weaponsSystem.setWeaponEquipped(self, self.equipped)
		if self.equipped then
			if self.player == Players.LocalPlayer then
				RunService:BindToRenderStep(self.instance:GetFullName(), Enum.RenderPriority.Input.Value, function(dt)
					self:onRenderStepped(dt)
				end)
				self.activeRenderStepName = self.instance:GetFullName()
			end
			self.connections.localStepped = RunService.Heartbeat:Connect(function(dt)
				self:onStepped(dt)
			end)
		end
	end

	if self.instanceIsTool then
		for _, part in pairs(self.instance:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = part ~= self.handle and not self.equipped
			end
		end
	end

	self:setActivated(false)
end

function BaseWeapon:setActivated(activated, fromNetwork)
	if not IsServer and fromNetwork and self.player == Players.LocalPlayer then
		return
	end

	if self.activated == activated then
		return
	end

	self.activated = activated
	if IsServer and not fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponActivated"):FireAllClients(self.player, self.instance, self.activated)
	end

	self:onActivatedChanged()
end

function BaseWeapon:onActivatedChanged()

end

function BaseWeapon:renderFire(fireInfo)

end

function BaseWeapon:simulateFire(fireInfo)

end

function BaseWeapon:isOwnerAlive()
	if self.instance:IsA("Tool") then
		local humanoid = self.instance.Parent:FindFirstChildOfClass("Humanoid")
		if humanoid then
			return humanoid:GetState() ~= Enum.HumanoidStateType.Dead
		end
	end

	return true
end

function BaseWeapon:fire(origin, dir, charge)
	if not self:isOwnerAlive() or self.reloading then
		return
	end

	if self:useAmmo(1) <= 0 then
		self:reload()
		return
	end

	local fireInfo = {}
	fireInfo.origin = origin
	fireInfo.dir = dir
	fireInfo.charge = math.clamp(charge or 1, 0, 1)
	fireInfo.id = self.nextShotId
	self.nextShotId = self.nextShotId + 1

	if not IsServer then
		self:onFired(self.player, fireInfo, false)
		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireServer(self.instance, fireInfo)
	else
		self:onFired(self.player, fireInfo, false)
	end
end

function BaseWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer then
		if firingPlayer == Players.LocalPlayer and fromNetwork then
			return
		end

		self:simulateFire(firingPlayer, fireInfo)
	else
		if self:useAmmo(1) <= 0 then
			return
		end

		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireAllClients(firingPlayer, self.instance, fireInfo)
	end
end

function BaseWeapon:getConfigValue(valueName, defaultValue)
	if self.configValues[valueName] ~= nil then
		return self.configValues[valueName]
	else
		return defaultValue
	end
end

function BaseWeapon:tryPlaySound(soundName, playbackSpeedRange)
	playbackSpeedRange = playbackSpeedRange or 0

	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	if not soundTemplate then
		return
	end

	local sound = soundTemplate:Clone()
	sound.PlaybackSpeed = sound.PlaybackSpeed + localRandom:NextNumber(-playbackSpeedRange * 0.5, playbackSpeedRange * 0.5)
	sound.Parent = soundTemplate.Parent
	sound:Play()
	coroutine.wrap(function()
		wait(sound.TimeLength / sound.PlaybackSpeed)
		sound:Destroy()
	end)()

	return sound
end

function BaseWeapon:getSound(soundName)
	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	return soundTemplate
end

function BaseWeapon:onDestroyed()

end

function BaseWeapon:onConfigValueAdded(valueObj)
	local valueName = valueObj.Name
	local newValue = valueObj.Value
	self.configValues[valueName] = newValue
	self:onConfigValueChanged(valueName, newValue, nil)

	self.connections["valueChanged:" .. valueName] = valueObj.Changed:Connect(function(changedValue)
		local oldValue = self.configValues[valueName]
		self.configValues[valueName] = changedValue

		self:onConfigValueChanged(valueName, changedValue, oldValue)
	end)
	self.connections["valueRenamed:" .. valueName] = valueObj:GetPropertyChangedSignal("Name"):Connect(function()
		self.configValues[valueName] = nil
		self:cleanupConnection("valueChanged:" .. valueName)
		self:cleanupConnection("valueRenamed:" .. valueName)
		self:onConfigValueAdded(valueObj)
	end)
end

function BaseWeapon:onConfigValueRemoved(valueObj)
	local valueName = valueObj.Name
	self.configValues[valueName] = nil

	self:cleanupConnection("valueChanged:" .. valueName)
	self:cleanupConnection("valueRenamed:" .. valueName)
end

-- This function is used to set configuration values from outside configuration objects/folders
function BaseWeapon:importConfiguration(config)
	if not config or not config:IsA("Configuration") then
		for _, child in pairs(config:GetChildren()) do
			if child:IsA("ValueBase") then
				local valueName = child.Name
				local newValue = child.Value
				local oldValue = self.configValues[valueName]
				self.configValues[valueName] = newValue
				self:onConfigValueChanged(valueName, newValue, oldValue)
			end
		end
	end
end

function BaseWeapon:setConfiguration(config)
	self:cleanupConnection("configChildAdded", "configChildRemoved")
	if not config or not config:IsA("Configuration") then
		return
	end

	for _, child in pairs(config:GetChildren()) do
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end
	self.connections.configChildAdded = config.ChildAdded:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end)
	self.connections.configChildRemoved = config.ChildRemoved:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueRemoved(child)
		end
	end)
end

function BaseWeapon:onChildAdded(child)
	if child:IsA("Configuration") then
		self:setConfiguration(child)
	end
end

function BaseWeapon:onChildRemoved(child)
	if child:IsA("Configuration") then
		self:setConfiguration(nil)
	end
end

function BaseWeapon:onConfigValueChanged(valueName, newValue, oldValue)

end

function BaseWeapon:onRenderStepped(dt)

end

function BaseWeapon:onStepped(dt)

end

function BaseWeapon:getAnimationController()
	if self.animController then
		if not self.instanceIsTool or (self.animController.Parent and self.animController.Parent:IsAncestorOf(self.instance)) then
			return self.animController
		end
	end

	self:setAnimationController(nil)

	if self.instanceIsTool then
		local humanoid = IsServer and self.instance.Parent:FindFirstChildOfClass("Humanoid") or self.instance.Parent:WaitForChild("Humanoid", math.huge)
		local animController = nil
		if not humanoid then
			animController = self.instance.Parent:FindFirstChildOfClass("AnimationController")
		end

		self:setAnimationController(humanoid or animController)
		return self.animController
	end
end

function BaseWeapon:setAnimationController(animController)
	if animController == self.animController then
		return
	end
	self:stopAnimations()
	self.animController = animController
end

function BaseWeapon:stopAnimations()
	for _, track in pairs(self.animTracks) do
		if track.IsPlaying then
			track:Stop()
		end
	end
	self.animTracks = {}
end

function BaseWeapon:getAnimTrack(key)
	local track = self.animTracks[key]
	if not track then
		local animController = self:getAnimationController()
		if not animController then
			warn("No animation controller when trying to play ", key)
			return nil
		end

		local animation = AnimationsFolder:FindFirstChild(key)
		if not animation then
			error(string.format("No such animation \"%s\" ", tostring(key)))
		end

		track = animController:LoadAnimation(animation)
		self.animTracks[key] = track
	end

	return track
end

function BaseWeapon:reload(player, fromNetwork)
	if
		not self.equipped or
		self.reloading or
		not self.canReload or
		self:getAmmoInWeapon() == self:getConfigValue("AmmoCapacity", 30)
	then
		return false
	end

	if not IsServer then
		if self.player ~= nil and self.player ~= Players.LocalPlayer then
			return
		end
		self.weaponsSystem.getRemoteEvent("WeaponReloadRequest"):FireServer(self.instance)
		self:onReloaded(self.player)
	else
		self:onReloaded(player, fromNetwork)
		self.weaponsSystem.getRemoteEvent("WeaponReloaded"):FireAllClients(player, self.instance)
	end
end

function BaseWeapon:onReloaded(player, fromNetwork)
	if fromNetwork and player == Players.LocalPlayer then -- make sure localplayer doesn't reload twice
		return
	end

	self.reloading = true
	self.canReload = false

	-- Play reload animation and sound
	if not IsServer then
		local reloadTrackKey = self:getConfigValue("ReloadAnimation", "RifleReload")
		if reloadTrackKey then
			self.reloadTrack = self:getAnimTrack(reloadTrackKey)
			if self.reloadTrack then
				self.reloadTrack:Play()
			end
		end

		self.curReloadSound = self:tryPlaySound("Reload", nil)
		if self.curReloadSound then
			self.curReloadSound.Ended:Connect(function()
				self.curReloadSound = nil
			end)
		end
	end

	local reloadTime = self:getConfigValue("ReloadTime", 2)
	local startTime = tick()

	if self.connections.reload ~= nil then -- this prevents an endless ammo bug
		return
	end
	self.connections.reload = RunService.Heartbeat:Connect(function()
		-- Stop trying to reload if the player unequipped this weapon or reloading was canceled some other way
		if not self.reloading then
			if self.connections.reload then
				self.connections.reload:Disconnect()
				self.connections.reload = nil
			end
		end

		-- Wait until gun finishes reloading
		if tick() < startTime + reloadTime then
			return
		end

		-- Add ammo to weapon
		if self.ammoInWeaponValue then
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		end

		if self.connections.reload then
			self.connections.reload:Disconnect()
			self.connections.reload = nil
		end

		self.reloading = false
		self.canReload = false
	end)
end

function BaseWeapon:cancelReload(player, fromNetwork)
	if not self.reloading then
		return
	end
	if fromNetwork and player == Players.LocalPlayer then
		return
	end

	if not IsServer and not fromNetwork and player == Players.LocalPlayer then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireServer(self.instance)
	elseif IsServer and fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireAllClients(player, self.instance)
	end

	self.reloading = false
	self.canReload = true

	if not IsServer and self.reloadTrack and self.reloadTrack.IsPlaying then
		warn("Stopping reloadTrack")
		self.reloadTrack:Stop()
	end
	if self.curReloadSound then
		self.curReloadSound:Stop()
		self.curReloadSound:Destroy()
		self.curReloadSound = nil
	end
end

function BaseWeapon:getAmmoInWeapon()
	if self.ammoInWeaponValue then
		return self.ammoInWeaponValue.Value
	end
	return 0
end

function BaseWeapon:useAmmo(amount)
	if self.ammoInWeaponValue then
		local ammoUsed = math.min(amount, self.ammoInWeaponValue.Value)
		self.ammoInWeaponValue.Value = self.ammoInWeaponValue.Value - ammoUsed
		self.canReload = true
		return ammoUsed
	else
		return 0
	end
end

function BaseWeapon:renderCharge()

end

return BaseWeapon

end))
ModuleScript314.Name = "WeaponsSystem"
ModuleScript314.Parent = Folder185
table.insert(cors,sandbox(ModuleScript314,function()
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

-- Dependencies
local WeaponData = script.Parent:WaitForChild("WeaponData")
local WeaponsSystemFolder = script.Parent
local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local ShoulderCamera = require(Libraries:WaitForChild("ShoulderCamera"))
local WeaponsGui = require(Libraries:WaitForChild("WeaponsGui"))
local SpringService = require(Libraries:WaitForChild("SpringService"))
local ancestorHasTag = require(Libraries:WaitForChild("ancestorHasTag"))
ShoulderCamera.SpringService = SpringService

local Configuration = WeaponsSystemFolder:WaitForChild("Configuration")
local ConfigurationValues = {
	SprintEnabled = Configuration:WaitForChild("SprintEnabled"),
	SlowZoomWalkEnabled = Configuration:WaitForChild("SlowZoomWalkEnabled"),
}

local WEAPON_TAG = "WeaponsSystemWeapon"
local WEAPON_TYPES_LOOKUP = {}

local REMOTE_EVENT_NAMES = {
	"WeaponFired",
	"WeaponHit",
	"WeaponReloadRequest",
	"WeaponReloaded",
	"WeaponReloadCanceled",
	"WeaponActivated"
}
local REMOTE_FUNCTION_NAMES = {}

--Set up WeaponTypes lookup table
do
	local function onNewWeaponType(weaponTypeModule)
		if not weaponTypeModule:IsA("ModuleScript") then
			return
		end
		local weaponTypeName = weaponTypeModule.Name
		xpcall(function()
			coroutine.wrap(function()
				local weaponType = require(weaponTypeModule)
				assert(typeof(weaponType) == "table", string.format("WeaponType \"%s\" did not return a valid table", weaponTypeModule:GetFullName()))
				WEAPON_TYPES_LOOKUP[weaponTypeName] = weaponType
			end)()
		end, function(errMsg)
			warn(string.format("Error while loading %s: %s", weaponTypeModule:GetFullName(), errMsg))
			warn(debug.traceback())
		end)
	end
	for _, child in pairs(WeaponTypes:GetChildren()) do
		onNewWeaponType(child)
	end
	WeaponTypes.ChildAdded:Connect(onNewWeaponType)
end

local WeaponsSystem = {}
WeaponsSystem.didSetup = false
WeaponsSystem.knownWeapons = {}
WeaponsSystem.connections = {}
WeaponsSystem.networkFolder = nil
WeaponsSystem.remoteEvents = {}
WeaponsSystem.remoteFunctions = {}
WeaponsSystem.currentWeapon = nil
WeaponsSystem.aimRayCallback = nil

WeaponsSystem.CurrentWeaponChanged = Instance.new("BindableEvent")

local NetworkingCallbacks = require(WeaponsSystemFolder:WaitForChild("NetworkingCallbacks"))
NetworkingCallbacks.WeaponsSystem = WeaponsSystem

local _damageCallback = nil
local _getTeamCallback = nil

function WeaponsSystem.setDamageCallback(cb)
	_damageCallback = cb
end

function WeaponsSystem.setGetTeamCallback(cb)
	_getTeamCallback = cb
end

function WeaponsSystem.setup()
	if WeaponsSystem.didSetup then
		warn("Warning: trying to run WeaponsSystem setup twice on the same module.")
		return
	end
	print(script.Parent:GetFullName(), "is now active.")

	WeaponsSystem.doingSetup = true

	--Setup network routing
	if IsServer then
		local networkFolder = Instance.new("Folder")
		networkFolder.Name = "Network"

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			local remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = remoteEventName
			remoteEvent.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteEventName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteEvent \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnServerEvent:Connect(function(...)
				callback(...)
			end)
			WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			local remoteFunc = Instance.new("RemoteEvent")
			remoteFunc.Name = remoteFuncName
			remoteFunc.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteFuncName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteFunction \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			remoteFunc.OnServerInvoke = function(...)
				return callback(...)
			end
			WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
		end

		networkFolder.Parent = WeaponsSystemFolder
		WeaponsSystem.networkFolder = networkFolder
	else
		WeaponsSystem.StarterGui = game:GetService("StarterGui")

		WeaponsSystem.camera = ShoulderCamera.new(WeaponsSystem)
		WeaponsSystem.gui = WeaponsGui.new(WeaponsSystem)

		if ConfigurationValues.SprintEnabled.Value then
			WeaponsSystem.camera:setSprintEnabled(ConfigurationValues.SprintEnabled.Value)
		end
		
		if ConfigurationValues.SlowZoomWalkEnabled.Value then
			WeaponsSystem.camera:setSlowZoomWalkEnabled(ConfigurationValues.SlowZoomWalkEnabled.Value)
		end

		local networkFolder = WeaponsSystemFolder:WaitForChild("Network", math.huge)

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			coroutine.wrap(function()
				local remoteEvent = networkFolder:WaitForChild(remoteEventName, math.huge)
				local callback = NetworkingCallbacks[remoteEventName]
				if callback then
					WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnClientEvent:Connect(function(...)
						callback(...)
					end)
				end
				WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
			end)()
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			coroutine.wrap(function()
				local remoteFunc = networkFolder:WaitForChild(remoteFuncName, math.huge)
				local callback = NetworkingCallbacks[remoteFuncName]
				if callback then
					remoteFunc.OnClientInvoke = function(...)
						return callback(...)
					end
				end
				WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
			end)()
		end

		Players.LocalPlayer.CharacterAdded:Connect(WeaponsSystem.onCharacterAdded)
		if Players.LocalPlayer.Character then
			WeaponsSystem.onCharacterAdded(Players.LocalPlayer.Character)
		end

		WeaponsSystem.networkFolder = networkFolder
		WeaponsSystem.camera:setEnabled(true)
	end

	--Setup weapon tools and listening
	WeaponsSystem.connections.weaponAdded = CollectionService:GetInstanceAddedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponAdded)
	WeaponsSystem.connections.weaponRemoved = CollectionService:GetInstanceRemovedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponRemoved)

	for _, instance in pairs(CollectionService:GetTagged(WEAPON_TAG)) do
		WeaponsSystem.onWeaponAdded(instance)
	end

	WeaponsSystem.doingSetup = false
	WeaponsSystem.didSetup = true
end

function WeaponsSystem.onCharacterAdded(character)
	-- Make it so players unequip weapons while seated, then reequip weapons when they become unseated
	local humanoid = character:WaitForChild("Humanoid")
	WeaponsSystem.connections.seated = humanoid.Seated:Connect(function(isSeated)
		if isSeated then
			WeaponsSystem.seatedWeapon = character:FindFirstChildOfClass("Tool")
			humanoid:UnequipTools()
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		else
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			humanoid:EquipTool(WeaponsSystem.seatedWeapon)
		end
	end)
end

function WeaponsSystem.shutdown()
	if not WeaponsSystem.didSetup then
		return
	end

	for _, weapon in pairs(WeaponsSystem.knownWeapons) do
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons = {}

	if IsServer and WeaponsSystem.networkFolder then
		WeaponsSystem.networkFolder:Destroy()
	end
	WeaponsSystem.networkFolder = nil
	WeaponsSystem.remoteEvents = {}
	WeaponsSystem.remoteFunctions = {}

	for _, connection in pairs(WeaponsSystem.connections) do
		if typeof(connection) == "RBXScriptConnection" then
			connection:Disconnect()
		end
	end
	WeaponsSystem.connections = {}
end

function WeaponsSystem.getWeaponTypeFromTags(instance)
	for _, tag in pairs(CollectionService:GetTags(instance)) do
		local weaponTypeFound = WEAPON_TYPES_LOOKUP[tag]
		if weaponTypeFound then
			return weaponTypeFound
		end
	end

	return nil
end

function WeaponsSystem.createWeaponForInstance(weaponInstance)
	coroutine.wrap(function()
		local weaponType = WeaponsSystem.getWeaponTypeFromTags(weaponInstance)
		if not weaponType then
			local weaponTypeObj = weaponInstance:WaitForChild("WeaponType")

			if weaponTypeObj and weaponTypeObj:IsA("StringValue") then
				local weaponTypeName = weaponTypeObj.Value
				local weaponTypeFound = WEAPON_TYPES_LOOKUP[weaponTypeName]
				if not weaponTypeFound then
					warn(string.format("Cannot find the weapon type \"%s\" for the instance %s!", weaponTypeName, weaponInstance:GetFullName()))
					return
				end

				weaponType = weaponTypeFound
			else
				warn("Could not find a WeaponType tag or StringValue for the instance ", weaponInstance:GetFullName())
				return
			end
		end

		-- Since we might have yielded while trying to get the WeaponType, we need to make sure not to continue
		-- making a new weapon if something else beat this iteration.
		if WeaponsSystem.getWeaponForInstance(weaponInstance) then
			warn("Already got ", weaponInstance:GetFullName())
			warn(debug.traceback())
			return
		end

		-- We should be pretty sure we got a valid weaponType by now
		assert(weaponType, "Got invalid weaponType")

		local weapon = weaponType.new(WeaponsSystem, weaponInstance)
		WeaponsSystem.knownWeapons[weaponInstance] = weapon
	end)()
end

function WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not typeof(weaponInstance) == "Instance" then
		warn("WeaponsSystem.getWeaponForInstance(weaponInstance): 'weaponInstance' was not an instance.")
		return nil
	end

	return WeaponsSystem.knownWeapons[weaponInstance]
end

-- and (IsServer or weaponInstance:IsDescendantOf(Players.LocalPlayer))

function WeaponsSystem.onWeaponAdded(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not weapon then
		WeaponsSystem.createWeaponForInstance(weaponInstance)
	end
end

function WeaponsSystem.onWeaponRemoved(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if weapon then
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons[weaponInstance] = nil
end

function WeaponsSystem.getRemoteEvent(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteEvent = WeaponsSystem.remoteEvents[name]
	if IsServer then
		if not remoteEvent then
			warn("No RemoteEvent named ", name)
			return nil
		end

		return remoteEvent
	else
		if not remoteEvent then
			remoteEvent = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteEvent
	end
end

function WeaponsSystem.getRemoteFunction(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteFunc = WeaponsSystem.remoteFunctions[name]
	if IsServer then
		if not remoteFunc then
			warn("No RemoteFunction named ", name)
			return nil
		end

		return remoteFunc
	else
		if not remoteFunc then
			remoteFunc = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteFunc
	end
end

function WeaponsSystem.setWeaponEquipped(weapon, equipped)
	assert(not IsServer, "WeaponsSystem.setWeaponEquipped should only be called on the client.")
	if not weapon then
		return
	end

	local lastWeapon = WeaponsSystem.currentWeapon
	local hasWeapon = false
	local weaponChanged = false

	if lastWeapon == weapon then
		if not equipped then
			WeaponsSystem.currentWeapon = nil
			hasWeapon = false
			weaponChanged = true
		else
			weaponChanged = false
		end
	else
		if equipped then
			WeaponsSystem.currentWeapon = weapon
			hasWeapon = true
			weaponChanged = true
		end
	end

	if WeaponsSystem.camera then
		WeaponsSystem.camera:resetZoomFactor()
		WeaponsSystem.camera:setHasScope(false)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.camera:setZoomFactor(WeaponsSystem.currentWeapon:getConfigValue("ZoomFactor", 1.1))
			WeaponsSystem.camera:setHasScope(WeaponsSystem.currentWeapon:getConfigValue("HasScope", false))
		end
	end

	if WeaponsSystem.gui then
		WeaponsSystem.gui:setEnabled(hasWeapon)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.gui:setCrosshairWeaponScale(WeaponsSystem.currentWeapon:getConfigValue("CrosshairScale", 1))
		else
			WeaponsSystem.gui:setCrosshairWeaponScale(1)
		end
	end

	if weaponChanged then
		WeaponsSystem.CurrentWeaponChanged:Fire(weapon.instance, lastWeapon and lastWeapon.instance)
	end
end

function WeaponsSystem.getHumanoid(part)
	while part and part ~= workspace do
		if part:IsA("Model") and part.PrimaryPart and part.PrimaryPart.Name == "HumanoidRootPart" then
			return part:FindFirstChildOfClass("Humanoid")
		end

		part = part.Parent
	end
end

function WeaponsSystem.getPlayerFromHumanoid(humanoid)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and humanoid:IsDescendantOf(player.Character) then
			return player
		end
	end
end

local function _defaultDamageCallback(system, target, amount, damageType, dealer, hitInfo, damageData)
	if target:IsA("Humanoid") then
		target:TakeDamage(amount)
	end
end

function WeaponsSystem.doDamage(target, amount, damageType, dealer, hitInfo, damageData)
	if not target or ancestorHasTag(target, "WeaponsSystemIgnore") then
		return
	end
	if IsServer then
		if target:IsA("Humanoid") and dealer:IsA("Player") and dealer.Character then
			local dealerHumanoid = dealer.Character:FindFirstChildOfClass("Humanoid")
			local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
			if dealerHumanoid and target ~= dealerHumanoid and targetPlayer then
				-- Trigger the damage indicator
				WeaponData:FireClient(targetPlayer, "HitByOtherPlayer", dealer.Character.HumanoidRootPart.CFrame.Position)
			end
		end

		-- NOTE:  damageData is a more or less free-form parameter that can be used for passing information from the code that is dealing damage about the cause.
		-- .The most obvious usage is extracting icons from the various weapon types (in which case a weapon instance would likely be passed in)
		-- ..The default weapons pass in that data
		local handler = _damageCallback or _defaultDamageCallback
		handler(WeaponsSystem, target, amount, damageType, dealer, hitInfo, damageData)
	end
end

local function _defaultGetTeamCallback(player)
	return 0
end

function WeaponsSystem.getTeam(player)
	local handler = _getTeamCallback or _defaultGetTeamCallback
	return handler(player)
end

function WeaponsSystem.playersOnDifferentTeams(player1, player2)
	if player1 == player2 or player1 == nil or player2 == nil then
		-- This allows players to damage themselves and NPC's
		return true
	end

	local player1Team = WeaponsSystem.getTeam(player1)
	local player2Team = WeaponsSystem.getTeam(player2)
	return player1Team == 0 or player1Team ~= player2Team
end

return WeaponsSystem

end))
Tool315.Name = "AR3"
Tool315.Parent = Folder0
Configuration316.Parent = Tool315
IntValue317.Name = "AmmoCapacity"
IntValue317.Parent = Configuration316
IntValue317.Value = 30
StringValue318.Name = "CasingEffect"
StringValue318.Parent = Configuration316
StringValue318.Value = "RifleCasing"
StringValue319.Name = "FireMode"
StringValue319.Parent = Configuration316
StringValue319.Value = "Automatic"
NumberValue320.Name = "GravityFactor"
NumberValue320.Parent = Configuration316
NumberValue320.Value = 0.5
NumberValue321.Name = "HitDamage"
NumberValue321.Parent = Configuration316
NumberValue321.Value = 14
NumberValue322.Name = "MuzzleFlashSize0"
NumberValue322.Parent = Configuration316
NumberValue322.Value = 1.1
NumberValue323.Name = "MuzzleFlashSize1"
NumberValue323.Parent = Configuration316
NumberValue323.Value = 1.4
NumberValue324.Name = "RecoilDecay"
NumberValue324.Parent = Configuration316
NumberValue324.Value = 0.81
NumberValue325.Name = "RecoilMax"
NumberValue325.Parent = Configuration316
NumberValue325.Value = 0.9
NumberValue326.Name = "RecoilMin"
NumberValue326.Parent = Configuration316
NumberValue326.Value = 0.7
NumberValue327.Name = "ShotCooldown"
NumberValue327.Parent = Configuration316
NumberValue327.Value = 0.125
StringValue328.Name = "ShotEffect"
StringValue328.Parent = Configuration316
StringValue328.Value = "Bullet"
NumberValue329.Name = "TotalRecoilMax"
NumberValue329.Parent = Configuration316
NumberValue329.Value = 1.1
NumberValue330.Name = "MaxSpread"
NumberValue330.Parent = Configuration316
NumberValue330.Value = 0.6
Part331.Name = "Handle"
Part331.Parent = Tool315
Part331.CFrame = CFrame.new(-3.78547812, 4.76891279, -11.3743439, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
Part331.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
Part331.Position = Vector3.new(-3.78547812, 4.76891279, -11.3743439)
Part331.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
Part331.Transparency = 1
Part331.Size = Vector3.new(0.5, 1, 3)
Part331.BottomSurface = Enum.SurfaceType.Smooth
Part331.CanCollide = false
Part331.TopSurface = Enum.SurfaceType.Smooth
Model332.Name = "AR"
Model332.Parent = Tool315
Model332.PrimaryPart = MeshPart333
MeshPart333.Name = "Rifle"
MeshPart333.Parent = Model332
MeshPart333.CFrame = CFrame.new(-4.16212606, 4.7642808, -11.374588, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
MeshPart333.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
MeshPart333.Position = Vector3.new(-4.16212606, 4.7642808, -11.374588)
MeshPart333.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
MeshPart333.Size = Vector3.new(0.194108516, 1.05410731, 4.72941303)
MeshPart333.Material = Enum.Material.Metal
MeshPart333.TextureID = "rbxassetid://3361236264"
Beam334.Name = "MuzzleFlash"
Beam334.Parent = MeshPart333
Beam334.Attachment0 = nil
Beam334.Attachment1 = nil
Beam334.Color = ColorSequence.new(Color3.new(0.839216, 0.670588, 0),Color3.new(1, 0.917647, 0.435294))
Beam334.Enabled = false
Beam334.LightEmission = 1
Beam334.Segments = 5
Beam334.Texture = "rbxassetid://872910628"
Beam334.TextureSpeed = 0
Beam334.Transparency = NumberSequence.new(0,0)
WeldConstraint335.Parent = MeshPart333
WeldConstraint335.Part0 = MeshPart333
WeldConstraint335.Part1 = MeshPart338
Sound336.Name = "Fired"
Sound336.Parent = MeshPart333
Sound336.SoundId = "rbxassetid://3806349898"
Sound337.Name = "Reload"
Sound337.Parent = MeshPart333
Sound337.SoundId = "rbxassetid://3821787597"
MeshPart338.Name = "Magazine"
MeshPart338.Parent = Model332
MeshPart338.CFrame = CFrame.new(-4.22765398, 4.42460537, -11.3581009, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
MeshPart338.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
MeshPart338.Position = Vector3.new(-4.22765398, 4.42460537, -11.3581009)
MeshPart338.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
MeshPart338.Color = Color3.new(0.290196, 0.278431, 0.286275)
MeshPart338.Size = Vector3.new(0.100694895, 1.03380096, 0.625120997)
MeshPart338.BrickColor = BrickColor.new("Dark taupe")
MeshPart338.Material = Enum.Material.Metal
MeshPart338.brickColor = BrickColor.new("Dark taupe")
MeshPart338.TextureID = "rbxassetid://3361236264"
MeshPart339.Name = "Bolt"
MeshPart339.Parent = Model332
MeshPart339.CFrame = CFrame.new(-4.13399696, 5.11249018, -11.4556656, -0.00101100025, -0.0123390043, -0.999923468, 0.0289530084, 0.999504387, -0.0123631069, 0.999580264, -0.028963292, -0.000653247873)
MeshPart339.Orientation = Vector3.new(0.709999979, -90.0400009, 1.65999997)
MeshPart339.Position = Vector3.new(-4.13399696, 5.11249018, -11.4556656)
MeshPart339.Rotation = Vector3.new(93.0199966, -89.2900009, 94.6800003)
MeshPart339.Color = Color3.new(0.388235, 0.372549, 0.384314)
MeshPart339.Size = Vector3.new(0.22213085, 0.126657262, 0.561310232)
MeshPart339.BrickColor = BrickColor.new("Dark stone grey")
MeshPart339.Material = Enum.Material.Metal
MeshPart339.brickColor = BrickColor.new("Dark stone grey")
StringValue340.Name = "WeaponType"
StringValue340.Parent = Tool315
StringValue340.Value = "BulletWeapon"
Folder341.Name = "WeaponsSystem"
Folder341.Parent = Tool315
IntValue342.Name = "Version"
IntValue342.Parent = Folder341
RemoteEvent343.Name = "WeaponData"
RemoteEvent343.Parent = Folder341
Folder344.Name = "Assets"
Folder344.Parent = Folder341
ScreenGui345.Name = "WeaponsSystemGui"
ScreenGui345.Parent = Folder344
ScreenGui345.AutoLocalize = false
ScreenGui345.Localize = false
ScreenGui345.ResetOnSpawn = false
ScreenGui345.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui345.DisplayOrder = 10000
Frame346.Name = "Scope"
Frame346.Parent = ScreenGui345
Frame346.Visible = false
Frame346.Size = UDim2.new(1, 0, 1, 0)
Frame346.BackgroundColor = BrickColor.new("Institutional white")
Frame346.BackgroundColor3 = Color3.new(1, 1, 1)
Frame346.BackgroundTransparency = 1
Frame346.ZIndex = 5
ImageLabel347.Name = "ScopeImage"
ImageLabel347.Parent = Frame346
ImageLabel347.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel347.Size = UDim2.new(1, 0, 0.949999988, 0)
ImageLabel347.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel347.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel347.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel347.BackgroundTransparency = 1
ImageLabel347.ZIndex = 2
ImageLabel347.Image = "rbxassetid://1598134910"
UIAspectRatioConstraint348.Parent = ImageLabel347
Frame349.Name = "LeftBlack"
Frame349.Parent = ImageLabel347
Frame349.Position = UDim2.new(0, 0, 0.5, 0)
Frame349.Size = UDim2.new(1, 0, 1, 0)
Frame349.AnchorPoint = Vector2.new(1, 0.5)
Frame349.BackgroundColor = BrickColor.new("Really black")
Frame349.BackgroundColor3 = Color3.new(0, 0, 0)
Frame349.BorderSizePixel = 0
Frame350.Name = "RightBlack"
Frame350.Parent = ImageLabel347
Frame350.Position = UDim2.new(1, 0, 0.5, 0)
Frame350.Size = UDim2.new(1, 0, 1, 0)
Frame350.AnchorPoint = Vector2.new(0, 0.5)
Frame350.BackgroundColor = BrickColor.new("Really black")
Frame350.BackgroundColor3 = Color3.new(0, 0, 0)
Frame350.BorderSizePixel = 0
Frame351.Name = "BottomBlack"
Frame351.Parent = ImageLabel347
Frame351.Position = UDim2.new(0.5, 0, 1, 0)
Frame351.Size = UDim2.new(5, 0, 1, 0)
Frame351.AnchorPoint = Vector2.new(0.5, 0)
Frame351.BackgroundColor = BrickColor.new("Really black")
Frame351.BackgroundColor3 = Color3.new(0, 0, 0)
Frame351.BorderSizePixel = 0
Frame352.Name = "TopBlack"
Frame352.Parent = ImageLabel347
Frame352.Position = UDim2.new(0.5, 0, 0, 0)
Frame352.Size = UDim2.new(5, 0, 1, 0)
Frame352.AnchorPoint = Vector2.new(0.5, 1)
Frame352.BackgroundColor = BrickColor.new("Really black")
Frame352.BackgroundColor3 = Color3.new(0, 0, 0)
Frame352.BorderSizePixel = 0
Frame353.Name = "SmallTouchscreen"
Frame353.Parent = ScreenGui345
Frame353.Visible = false
Frame353.Size = UDim2.new(1, 0, 1, 0)
Frame353.BackgroundColor = BrickColor.new("Institutional white")
Frame353.BackgroundColor3 = Color3.new(1, 1, 1)
Frame353.BackgroundTransparency = 1
Frame353.ZIndex = 10
ImageButton354.Name = "FireButton"
ImageButton354.Parent = Frame353
ImageButton354.Position = UDim2.new(1, -95, 1, -90)
ImageButton354.Size = UDim2.new(0, 72, 0, 72)
ImageButton354.Active = false
ImageButton354.BackgroundColor = BrickColor.new("Institutional white")
ImageButton354.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton354.BackgroundTransparency = 1
ImageButton354.ZIndex = 10
ImageButton354.Image = "rbxassetid://2804818047"
ImageButton355.Name = "AimButton"
ImageButton355.Parent = Frame353
ImageButton355.Position = UDim2.new(1, -25, 1, -148)
ImageButton355.Size = UDim2.new(0, 44, 0, 44)
ImageButton355.AnchorPoint = Vector2.new(1, 0)
ImageButton355.BackgroundColor = BrickColor.new("Institutional white")
ImageButton355.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton355.BackgroundTransparency = 1
ImageButton355.ZIndex = 10
ImageButton355.Image = "rbxassetid://2804583948"
Frame356.Name = "LargeTouchscreen"
Frame356.Parent = ScreenGui345
Frame356.Visible = false
Frame356.Size = UDim2.new(1, 0, 1, 0)
Frame356.BackgroundColor = BrickColor.new("Institutional white")
Frame356.BackgroundColor3 = Color3.new(1, 1, 1)
Frame356.BackgroundTransparency = 1
Frame356.ZIndex = 10
ImageButton357.Name = "FireButton"
ImageButton357.Parent = Frame356
ImageButton357.Position = UDim2.new(1, -170, 1, -210)
ImageButton357.Size = UDim2.new(0, 120, 0, 120)
ImageButton357.Active = false
ImageButton357.BackgroundColor = BrickColor.new("Institutional white")
ImageButton357.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton357.BackgroundTransparency = 1
ImageButton357.ZIndex = 10
ImageButton357.Image = "rbxassetid://2804818047"
ImageButton358.Name = "AimButton"
ImageButton358.Parent = Frame356
ImageButton358.Position = UDim2.new(1, -50, 1, -296)
ImageButton358.Size = UDim2.new(0, 88, 0, 88)
ImageButton358.AnchorPoint = Vector2.new(1, 0)
ImageButton358.BackgroundColor = BrickColor.new("Institutional white")
ImageButton358.BackgroundColor3 = Color3.new(1, 1, 1)
ImageButton358.BackgroundTransparency = 1
ImageButton358.ZIndex = 10
ImageButton358.Image = "rbxassetid://2804583948"
Folder359.Name = "ScalingElements"
Folder359.Parent = ScreenGui345
Frame360.Name = "Crosshair"
Frame360.Parent = Folder359
Frame360.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame360.Size = UDim2.new(0.0480000004, 0, 0.0480000004, 0)
Frame360.AnchorPoint = Vector2.new(0.5, 0.5)
Frame360.BackgroundColor = BrickColor.new("Institutional white")
Frame360.BackgroundColor3 = Color3.new(1, 1, 1)
Frame360.BackgroundTransparency = 1
ImageLabel361.Name = "Top"
ImageLabel361.Parent = Frame360
ImageLabel361.Position = UDim2.new(0.5, 0, 0, 0)
ImageLabel361.Size = UDim2.new(0.416700006, 0, 0.416999996, 0)
ImageLabel361.AnchorPoint = Vector2.new(0.5, 0)
ImageLabel361.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel361.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel361.BackgroundTransparency = 1
ImageLabel361.Image = "rbxassetid://2755681329"
ImageLabel362.Name = "Bottom"
ImageLabel362.Parent = Frame360
ImageLabel362.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel362.Rotation = 180
ImageLabel362.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel362.AnchorPoint = Vector2.new(0.5, 1)
ImageLabel362.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel362.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel362.BackgroundTransparency = 1
ImageLabel362.Image = "rbxassetid://2755681329"
ImageLabel363.Name = "Left"
ImageLabel363.Parent = Frame360
ImageLabel363.Position = UDim2.new(0, 0, 0.5, 0)
ImageLabel363.Rotation = 270
ImageLabel363.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel363.AnchorPoint = Vector2.new(0, 0.5)
ImageLabel363.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel363.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel363.BackgroundTransparency = 1
ImageLabel363.Image = "rbxassetid://2755681329"
ImageLabel364.Name = "Right"
ImageLabel364.Parent = Frame360
ImageLabel364.Position = UDim2.new(1, 0, 0.5, 0)
ImageLabel364.Rotation = 90
ImageLabel364.Size = UDim2.new(0.416999996, 0, 0.416999996, 0)
ImageLabel364.AnchorPoint = Vector2.new(1, 0.5)
ImageLabel364.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel364.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel364.BackgroundTransparency = 1
ImageLabel364.Image = "rbxassetid://2755681329"
UIAspectRatioConstraint365.Parent = Frame360
Frame366.Name = "HitMarker"
Frame366.Parent = Folder359
Frame366.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame366.Size = UDim2.new(0.0480000004, 0, 0.0480000004, 0)
Frame366.AnchorPoint = Vector2.new(0.5, 0.5)
Frame366.BackgroundColor = BrickColor.new("Institutional white")
Frame366.BackgroundColor3 = Color3.new(1, 1, 1)
Frame366.BackgroundTransparency = 1
UIAspectRatioConstraint367.Parent = Frame366
ImageLabel368.Name = "HitMarkerImage"
ImageLabel368.Parent = Frame366
ImageLabel368.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel368.Rotation = 180
ImageLabel368.Size = UDim2.new(1, 0, 1, 0)
ImageLabel368.AnchorPoint = Vector2.new(0.5, 1)
ImageLabel368.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel368.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel368.BackgroundTransparency = 1
ImageLabel368.Image = "rbxassetid://285779644"
ImageLabel368.ImageTransparency = 1
Folder369.Name = "DirectionalIndicators"
Folder369.Parent = Folder359
Frame370.Name = "DamageIndicator"
Frame370.Parent = Folder369
Frame370.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame370.Rotation = 180
Frame370.Size = UDim2.new(0.180000007, 0, 0.360000014, 0)
Frame370.AnchorPoint = Vector2.new(0.5, 0.5)
Frame370.BackgroundColor = BrickColor.new("Institutional white")
Frame370.BackgroundColor3 = Color3.new(1, 1, 1)
Frame370.BackgroundTransparency = 1
ImageLabel371.Name = "DamageIndicator"
ImageLabel371.Parent = Frame370
ImageLabel371.Position = UDim2.new(0.5, 0, 1, 0)
ImageLabel371.Rotation = 90
ImageLabel371.Size = UDim2.new(1, 0, 0.5, 0)
ImageLabel371.AnchorPoint = Vector2.new(0.5, 0.620000005)
ImageLabel371.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel371.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel371.BackgroundTransparency = 1
ImageLabel371.Image = "rbxassetid://3498623805"
ImageLabel371.ImageColor3 = Color3.new(0.898039, 0, 0)
ImageLabel371.ImageTransparency = 1
ImageLabel371.ScaleType = Enum.ScaleType.Slice
UIAspectRatioConstraint372.Parent = ImageLabel371
UIAspectRatioConstraint372.AspectRatio = 0.27200001478195
Configuration373.Parent = Frame370
StringValue374.Name = "Name"
StringValue374.Parent = Configuration373
StringValue374.Value = "DamageIndicator"
NumberValue375.Name = "TimeBeforeFade"
NumberValue375.Parent = Configuration373
NumberValue375.Value = 1.5
NumberValue376.Name = "FadeTime"
NumberValue376.Parent = Configuration373
NumberValue376.Value = 1
NumberValue377.Name = "TransparencyBeforeFade"
NumberValue377.Parent = Configuration373
NumberValue377.Value = 0.25
NumberValue378.Name = "DistanceLevelFromCenter"
NumberValue378.Parent = Configuration373
NumberValue378.Value = 6
NumberValue379.Name = "WidthLevel"
NumberValue379.Parent = Configuration373
NumberValue379.Value = 6
UIAspectRatioConstraint380.Parent = Frame370
Folder381.Name = "Animations"
Folder381.Parent = Folder344
Animation382.Name = "RifleAim"
Animation382.Parent = Folder381
Animation382.AnimationId = "rbxassetid://3972164452"
Animation383.Name = "RifleAimDownSights"
Animation383.Parent = Folder381
Animation383.AnimationId = "rbxassetid://3972157449"
Animation384.Name = "RifleReload"
Animation384.Parent = Folder381
Animation384.AnimationId = "rbxassetid://3972131105"
Folder385.Name = "Effects"
Folder385.Parent = Folder344
Folder386.Name = "Shots"
Folder386.Parent = Folder385
Part387.Name = "Bullet"
Part387.Parent = Folder386
Part387.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part387.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part387.Transparency = 1
Part387.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part387.Anchored = true
Part387.BottomSurface = Enum.SurfaceType.Smooth
Part387.CanCollide = false
Part387.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter388.Name = "TrailParticles"
ParticleEmitter388.Parent = mas
ParticleEmitter388.Speed = NumberRange.new(0, 2)
ParticleEmitter388.Rotation = NumberRange.new(-180, 180)
ParticleEmitter388.Color = ColorSequence.new(Color3.new(0.423529, 0.329412, 0),Color3.new(0.760784, 0.607843, 0))
ParticleEmitter388.Enabled = false
ParticleEmitter388.Texture = "rbxassetid://3852340006"
ParticleEmitter388.Transparency = NumberSequence.new(0,0.087499976158142,0.41249996423721,1)
ParticleEmitter388.Size = NumberSequence.new(0.070000000298023,0.070000000298023)
ParticleEmitter388.Lifetime = NumberRange.new(0.25, 0.5)
ParticleEmitter388.Rate = 100
ParticleEmitter388.RotSpeed = NumberRange.new(-50, 50)
ParticleEmitter388.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter388.VelocityInheritance = 0.30000001192093
ParticleEmitter388.VelocitySpread = 30
Beam389.Name = "Beam0"
Beam389.Parent = Part387
Beam389.Attachment0 = nil
Beam389.Attachment1 = nil
Beam389.Enabled = false
Beam389.FaceCamera = true
Beam389.Segments = 50
Beam389.Texture = "rbxassetid://3867967806"
Beam389.TextureSpeed = 0
Beam389.Transparency = NumberSequence.new(1,0,0,1)
Beam389.Width0 = 0.10000000149012
Beam389.Width1 = 0.25
Beam390.Name = "Beam1"
Beam390.Parent = Part387
Beam390.Attachment0 = nil
Beam390.Attachment1 = nil
Beam390.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam390.Enabled = false
Beam390.FaceCamera = true
Beam390.LightEmission = 1
Beam390.Segments = 50
Beam390.Texture = "rbxassetid://1287002748"
Beam390.TextureSpeed = 0
Beam390.Transparency = NumberSequence.new(1,1)
Beam390.Width0 = 0.10000000149012
Beam390.Width1 = 0.10000000149012
ParticleEmitter391.Name = "HitParticles"
ParticleEmitter391.Parent = mas
ParticleEmitter391.Speed = NumberRange.new(0, 10)
ParticleEmitter391.Rotation = NumberRange.new(-180, 180)
ParticleEmitter391.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter391.LightEmission = 0.10000000149012
ParticleEmitter391.LightInfluence = 1
ParticleEmitter391.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter391.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter391.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter391.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter391.Drag = 0.5
ParticleEmitter391.EmissionDirection = Enum.NormalId.Front
ParticleEmitter391.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter391.Rate = 0
ParticleEmitter391.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter391.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter391.VelocityInheritance = -0.0010000000474975
ParticleEmitter391.VelocitySpread = 30
Sound392.Name = "HitSound"
Sound392.Parent = mas
Sound392.SoundId = "rbxassetid://1489924400"
Sound392.Volume = 0
Part393.Name = "Grenade"
Part393.Parent = Folder386
Part393.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part393.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part393.Transparency = 1
Part393.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part393.Anchored = true
Part393.BottomSurface = Enum.SurfaceType.Smooth
Part393.CanCollide = false
Part393.TopSurface = Enum.SurfaceType.Smooth
Beam394.Name = "Beam0"
Beam394.Parent = Part393
Beam394.Attachment0 = nil
Beam394.Attachment1 = nil
Beam394.Color = ColorSequence.new(Color3.new(1, 0.796078, 0.270588),Color3.new(1, 0.798884, 0.280833),Color3.new(1, 0.964706, 0.886275))
Beam394.Enabled = false
Beam394.FaceCamera = true
Beam394.LightEmission = 1
Beam394.Segments = 50
Beam394.Texture = "rbxassetid://2463944225"
Beam394.TextureSpeed = 0
Beam394.Transparency = NumberSequence.new(1,0.90710383653641,0,1)
Beam394.Width0 = 0.10000000149012
Beam394.Width1 = 0.25
Beam395.Name = "Beam1"
Beam395.Parent = Part393
Beam395.Attachment0 = nil
Beam395.Attachment1 = nil
Beam395.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam395.Enabled = false
Beam395.FaceCamera = true
Beam395.LightEmission = 1
Beam395.Segments = 50
Beam395.Texture = "rbxassetid://1287002748"
Beam395.TextureSpeed = 0
Beam395.Transparency = NumberSequence.new(1,0.95081967115402,0.76502734422684,0.43169403076172,0,1)
Beam395.Width0 = 0.10000000149012
Beam395.Width1 = 0.10000000149012
Sound396.Name = "HitSound"
Sound396.Parent = mas
Sound396.SoundId = "rbxassetid://3963013256"
Sound396.Volume = 5
SpecialMesh397.Parent = Part393
SpecialMesh397.MeshId = "http://www.roblox.com/asset/?id=232379763"
SpecialMesh397.Scale = Vector3.new(1.5, 1.5, 1.5)
SpecialMesh397.TextureId = "http://www.roblox.com/asset/?id=232379808"
SpecialMesh397.MeshType = Enum.MeshType.FileMesh
Sound398.Name = "Flying"
Sound398.Parent = Part393
Sound398.Looped = true
Sound398.EmitterSize = 5
Sound398.MinDistance = 5
Sound398.SoundId = "rbxassetid://3963014042"
Part399.Name = "Arrow"
Part399.Parent = Folder386
Part399.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part399.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part399.Transparency = 1
Part399.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part399.Anchored = true
Part399.BottomSurface = Enum.SurfaceType.Smooth
Part399.CanCollide = false
Part399.TopSurface = Enum.SurfaceType.Smooth
Beam400.Name = "Beam0"
Beam400.Parent = Part399
Beam400.Attachment0 = nil
Beam400.Attachment1 = nil
Beam400.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.964706, 0.886275))
Beam400.Enabled = false
Beam400.FaceCamera = true
Beam400.LightEmission = 1
Beam400.Segments = 50
Beam400.Texture = "rbxassetid://2463944225"
Beam400.TextureLength = 0.5
Beam400.TextureSpeed = 0
Beam400.Transparency = NumberSequence.new(1,0.74863386154175,1,0.4426229596138,1,0.25136613845825,1,0.14754098653793,0.85792350769043,0,1,0,1,0,1)
Beam400.Width0 = 0.25
Beam400.Width1 = 0.25
Beam401.Name = "Beam1"
Beam401.Parent = Part399
Beam401.Attachment0 = nil
Beam401.Attachment1 = nil
Beam401.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(0.862745, 0.862745, 0.862745))
Beam401.Enabled = false
Beam401.FaceCamera = true
Beam401.LightEmission = 1
Beam401.Segments = 50
Beam401.Texture = "rbxassetid://1287002748"
Beam401.TextureSpeed = 0
Beam401.Transparency = NumberSequence.new(1,0.75409835577011,0.55191254615784,0.43169403076172,0.43169403076172,0.28415304422379,1)
Beam401.Width0 = 0.25
Beam401.Width1 = 0.25
ParticleEmitter402.Name = "HitParticles"
ParticleEmitter402.Parent = mas
ParticleEmitter402.Speed = NumberRange.new(0, 10)
ParticleEmitter402.Rotation = NumberRange.new(-180, 180)
ParticleEmitter402.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter402.LightEmission = 0.10000000149012
ParticleEmitter402.LightInfluence = 1
ParticleEmitter402.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter402.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter402.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter402.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter402.Drag = 0.5
ParticleEmitter402.EmissionDirection = Enum.NormalId.Front
ParticleEmitter402.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter402.Rate = 0
ParticleEmitter402.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter402.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter402.VelocityInheritance = -0.0010000000474975
ParticleEmitter402.VelocitySpread = 30
Sound403.Name = "HitSound"
Sound403.Parent = mas
Sound403.SoundId = "rbxassetid://3963012401"
Sound403.Volume = 0.25
SpecialMesh404.Parent = Part399
SpecialMesh404.MeshId = "rbxassetid://2493118549"
SpecialMesh404.Offset = Vector3.new(0, 0, -0.899999976)
SpecialMesh404.Scale = Vector3.new(0.43178001, 0.43178001, 0.43178001)
SpecialMesh404.TextureId = "rbxassetid://2493025364"
SpecialMesh404.MeshType = Enum.MeshType.FileMesh
Part405.Name = "Rocket"
Part405.Parent = Folder386
Part405.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part405.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part405.Transparency = 1
Part405.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part405.Anchored = true
Part405.BottomSurface = Enum.SurfaceType.Smooth
Part405.CanCollide = false
Part405.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter406.Name = "LeadingParticles"
ParticleEmitter406.Parent = mas
ParticleEmitter406.Speed = NumberRange.new(-5, -5)
ParticleEmitter406.Rotation = NumberRange.new(-180, 180)
ParticleEmitter406.Color = ColorSequence.new(Color3.new(1, 0.470588, 0.117647),Color3.new(1, 0.352941, 0.156863),Color3.new(0.815686, 0.490196, 0))
ParticleEmitter406.Enabled = false
ParticleEmitter406.LightEmission = 1
ParticleEmitter406.Texture = "rbxasset://textures/particles/fire_main.dds"
ParticleEmitter406.Transparency = NumberSequence.new(1,0.07407408952713,0,0,0.098765432834625,0.25308638811111,1)
ParticleEmitter406.Size = NumberSequence.new(0.3125,0.34722208976746,0.72916686534882,1.5625,2.8819441795349)
ParticleEmitter406.Drag = 5
ParticleEmitter406.EmissionDirection = Enum.NormalId.Left
ParticleEmitter406.Lifetime = NumberRange.new(0.10000000149012, 0.25)
ParticleEmitter406.Rate = 500
ParticleEmitter406.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter406.SpreadAngle = Vector2.new(10, 10)
ParticleEmitter406.VelocityInheritance = -0.10000000149012
ParticleEmitter406.VelocitySpread = 10
Beam407.Name = "Beam0"
Beam407.Parent = Part405
Beam407.Attachment0 = nil
Beam407.Attachment1 = nil
Beam407.Color = ColorSequence.new(Color3.new(1, 0.796078, 0.270588),Color3.new(1, 0.798884, 0.280833),Color3.new(1, 0.964706, 0.886275))
Beam407.Enabled = false
Beam407.FaceCamera = true
Beam407.LightEmission = 1
Beam407.Segments = 50
Beam407.Texture = "rbxassetid://2463944225"
Beam407.TextureSpeed = 0
Beam407.Transparency = NumberSequence.new(1,0.90710383653641,0,1)
Beam407.Width0 = 0.10000000149012
Beam407.Width1 = 0.25
Beam408.Name = "Beam1"
Beam408.Parent = Part405
Beam408.Attachment0 = nil
Beam408.Attachment1 = nil
Beam408.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam408.Enabled = false
Beam408.FaceCamera = true
Beam408.LightEmission = 1
Beam408.Segments = 50
Beam408.Texture = "rbxassetid://1287002748"
Beam408.TextureSpeed = 0
Beam408.Transparency = NumberSequence.new(1,0.95081967115402,0.76502734422684,0.43169403076172,0,1)
Beam408.Width0 = 0.10000000149012
Beam408.Width1 = 0.10000000149012
ParticleEmitter409.Name = "HitParticles"
ParticleEmitter409.Parent = mas
ParticleEmitter409.Speed = NumberRange.new(0, 10)
ParticleEmitter409.Rotation = NumberRange.new(-180, 180)
ParticleEmitter409.Color = ColorSequence.new(Color3.new(1, 0.988235, 0.929412),Color3.new(0.97466, 0.925769, 0.797998),Color3.new(1, 0.803922, 0.0941176),Color3.new(1, 0.705882, 0.109804),Color3.new(0.196078, 0.133333, 0.0117647))
ParticleEmitter409.LightEmission = 1
ParticleEmitter409.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter409.Transparency = NumberSequence.new(1,0,0.76543211936951,0.9753086566925,0.98765432834625,1)
ParticleEmitter409.Size = NumberSequence.new(0,2.9166669845581,2.361111164093,5.5208339691162,8.125)
ParticleEmitter409.Drag = 10
ParticleEmitter409.EmissionDirection = Enum.NormalId.Front
ParticleEmitter409.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter409.Rate = 0
ParticleEmitter409.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter409.SpreadAngle = Vector2.new(15, 15)
ParticleEmitter409.VelocitySpread = 15
Sound410.Name = "HitSound"
Sound410.Parent = mas
Sound410.SoundId = "rbxassetid://3963015379"
Sound410.Volume = 5
SpecialMesh411.Parent = Part405
SpecialMesh411.MeshId = "rbxassetid://94690081"
SpecialMesh411.Offset = Vector3.new(0, 0, -2)
SpecialMesh411.Scale = Vector3.new(2, 2, 2)
SpecialMesh411.TextureId = "rbxassetid://94689966"
SpecialMesh411.MeshType = Enum.MeshType.FileMesh
Sound412.Name = "Flying"
Sound412.Parent = Part405
Sound412.Looped = true
Sound412.EmitterSize = 5
Sound412.MinDistance = 5
Sound412.SoundId = "rbxassetid://3963016451"
Sound412.Volume = 2
Part413.Name = "Railgun"
Part413.Parent = Folder386
Part413.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part413.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part413.Transparency = 1
Part413.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part413.Anchored = true
Part413.BottomSurface = Enum.SurfaceType.Smooth
Part413.CanCollide = false
Part413.TopSurface = Enum.SurfaceType.Smooth
Beam414.Name = "Beam0"
Beam414.Parent = Part413
Beam414.Attachment0 = nil
Beam414.Attachment1 = nil
Beam414.Color = ColorSequence.new(Color3.new(1, 0.921569, 0.560784),Color3.new(1, 0.921569, 0.560784))
Beam414.Enabled = false
Beam414.FaceCamera = true
Beam414.LightEmission = 1
Beam414.Segments = 50
Beam414.Texture = "rbxassetid://1286995910"
Beam414.TextureSpeed = 0
Beam414.Transparency = NumberSequence.new(1,0,0,1)
Beam414.Width0 = 0.10000000149012
Beam414.Width1 = 0.25
Beam415.Name = "Beam1"
Beam415.Parent = Part413
Beam415.Attachment0 = nil
Beam415.Attachment1 = nil
Beam415.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam415.Enabled = false
Beam415.FaceCamera = true
Beam415.LightEmission = 1
Beam415.Segments = 50
Beam415.Texture = "rbxassetid://1287002748"
Beam415.TextureSpeed = 0
Beam415.Transparency = NumberSequence.new(1,0,0,1)
Beam415.Width0 = 0.10000000149012
Beam415.Width1 = 0.10000000149012
Sound416.Name = "HitSound"
Sound416.Parent = mas
Sound416.Pitch = 0.25
Sound416.PlaybackSpeed = 0.25
Sound416.SoundId = "rbxassetid://1489924400"
Sound416.Volume = 2
ParticleEmitter417.Name = "HitParticles"
ParticleEmitter417.Parent = mas
ParticleEmitter417.Speed = NumberRange.new(0, 2)
ParticleEmitter417.Rotation = NumberRange.new(-180, 180)
ParticleEmitter417.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.976659, 0.943567),Color3.new(1, 0.690196, 0.25098),Color3.new(1, 0.588235, 0.172549),Color3.new(0.4, 0.0352941, 0.0352941),Color3.new(0.14902, 0.121569, 0.121569),Color3.new(0.14902, 0.14902, 0.14902))
ParticleEmitter417.Enabled = false
ParticleEmitter417.LightEmission = 1
ParticleEmitter417.Texture = "rbxassetid://552389687"
ParticleEmitter417.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter417.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter417.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter417.Drag = 0.5
ParticleEmitter417.EmissionDirection = Enum.NormalId.Front
ParticleEmitter417.Lifetime = NumberRange.new(0.10000000149012, 1)
ParticleEmitter417.Rate = 0
ParticleEmitter417.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter417.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter417.VelocityInheritance = -0.0010000000474975
ParticleEmitter417.VelocitySpread = 30
ParticleEmitter418.Name = "MuzzleParticles"
ParticleEmitter418.Parent = Part413
ParticleEmitter418.Speed = NumberRange.new(5, 25)
ParticleEmitter418.Rotation = NumberRange.new(-180, 180)
ParticleEmitter418.Color = ColorSequence.new(Color3.new(1, 1, 1),Color3.new(1, 0.580392, 0.580392),Color3.new(0.188235, 0.0352941, 0.0352941))
ParticleEmitter418.Enabled = false
ParticleEmitter418.LightEmission = 0.5
ParticleEmitter418.LightInfluence = 0.5
ParticleEmitter418.Texture = "rbxassetid://552389687"
ParticleEmitter418.Transparency = NumberSequence.new(1,0.83950614929199,0.90123456716537,0.70370370149612,0.80246913433075,0.67283952236176,0.93209874629974,0.56172835826874,0.8950617313385,0.6851851940155,0.92592591047287,1)
ParticleEmitter418.Size = NumberSequence.new(0,0.83333313465118,3.1944441795349,0.625,0.72916686534882,0,0.41666686534882,0)
ParticleEmitter418.Drag = 8
ParticleEmitter418.EmissionDirection = Enum.NormalId.Front
ParticleEmitter418.Lifetime = NumberRange.new(0.5, 1)
ParticleEmitter418.Rate = 0
ParticleEmitter418.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter418.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter418.VelocitySpread = 30
Part419.Name = "Plasma"
Part419.Parent = Folder386
Part419.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part419.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part419.Transparency = 1
Part419.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part419.Anchored = true
Part419.BottomSurface = Enum.SurfaceType.Smooth
Part419.CanCollide = false
Part419.TopSurface = Enum.SurfaceType.Smooth
ParticleEmitter420.Name = "LeadingParticles"
ParticleEmitter420.Parent = mas
ParticleEmitter420.Speed = NumberRange.new(5, 10)
ParticleEmitter420.Rotation = NumberRange.new(-180, 180)
ParticleEmitter420.Color = ColorSequence.new(Color3.new(0.498039, 0.917647, 1),Color3.new(1, 1, 1))
ParticleEmitter420.Enabled = false
ParticleEmitter420.LightEmission = 1
ParticleEmitter420.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter420.Transparency = NumberSequence.new(1,0,0,0.74074077606201,0.95679014921188,1)
ParticleEmitter420.Size = NumberSequence.new(0.3125,0.59027791023254,1.3194441795349,0.41666686534882,0.20833313465118,0)
ParticleEmitter420.Drag = 0.5
ParticleEmitter420.Lifetime = NumberRange.new(0.10000000149012, 0.25)
ParticleEmitter420.LockedToPart = true
ParticleEmitter420.Rate = 100
ParticleEmitter420.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter420.SpreadAngle = Vector2.new(180, 180)
ParticleEmitter420.VelocitySpread = 180
Beam421.Name = "Beam0"
Beam421.Parent = Part419
Beam421.Attachment0 = nil
Beam421.Attachment1 = nil
Beam421.Color = ColorSequence.new(Color3.new(0.498039, 0.917647, 1),Color3.new(0.498039, 0.917647, 1))
Beam421.Enabled = false
Beam421.FaceCamera = true
Beam421.LightEmission = 1
Beam421.Segments = 50
Beam421.Texture = "rbxassetid://2463944225"
Beam421.TextureSpeed = 0
Beam421.Transparency = NumberSequence.new(1,0,0,1)
Beam421.Width0 = 0.10000000149012
Beam421.Width1 = 0.25
Beam422.Name = "Beam1"
Beam422.Parent = Part419
Beam422.Attachment0 = nil
Beam422.Attachment1 = nil
Beam422.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam422.Enabled = false
Beam422.FaceCamera = true
Beam422.LightEmission = 1
Beam422.Segments = 50
Beam422.Texture = "rbxassetid://1287002748"
Beam422.TextureSpeed = 0
Beam422.Transparency = NumberSequence.new(1,0,0,1)
Beam422.Width0 = 0.10000000149012
Beam422.Width1 = 0.10000000149012
ParticleEmitter423.Name = "HitParticles"
ParticleEmitter423.Parent = mas
ParticleEmitter423.Speed = NumberRange.new(0, 10)
ParticleEmitter423.Rotation = NumberRange.new(-180, 180)
ParticleEmitter423.Color = ColorSequence.new(Color3.new(0.607843, 0.937255, 1),Color3.new(0, 0.392157, 0.470588))
ParticleEmitter423.LightEmission = 1
ParticleEmitter423.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter423.Transparency = NumberSequence.new(1,0,0.76543211936951,0.9753086566925,0.98765432834625,1)
ParticleEmitter423.Size = NumberSequence.new(0,1.25,0.97222208976746,2.1180553436279,3.5069441795349)
ParticleEmitter423.Drag = 10
ParticleEmitter423.EmissionDirection = Enum.NormalId.Front
ParticleEmitter423.Lifetime = NumberRange.new(0.5, 2)
ParticleEmitter423.Rate = 0
ParticleEmitter423.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter423.SpreadAngle = Vector2.new(15, 15)
ParticleEmitter423.VelocitySpread = 15
Sound424.Name = "HitSound"
Sound424.Parent = mas
Sound424.Pitch = 2
Sound424.PlaybackSpeed = 2
Sound424.SoundId = "rbxassetid://878000314"
Sound424.Volume = 0.25
Part425.Name = "CannonBall"
Part425.Parent = Folder386
Part425.CFrame = CFrame.new(-6.13895988, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part425.Position = Vector3.new(-6.13895988, 4.99302006, -11.435256)
Part425.Color = Color3.new(0.160784, 0.164706, 0.188235)
Part425.Transparency = 1
Part425.Size = Vector3.new(2, 2, 2)
Part425.BottomSurface = Enum.SurfaceType.Smooth
Part425.BrickColor = BrickColor.new("Black")
Part425.CustomPhysicalProperties = 13, 0.800000012, 0.0500000007, 10, 100
Part425.Material = Enum.Material.Metal
Part425.TopSurface = Enum.SurfaceType.Smooth
Part425.brickColor = BrickColor.new("Black")
Part425.Shape = Enum.PartType.Ball
Beam426.Name = "Beam0"
Beam426.Parent = Part425
Beam426.Attachment0 = nil
Beam426.Attachment1 = nil
Beam426.Color = ColorSequence.new(Color3.new(0.639216, 0.639216, 0.639216),Color3.new(0.34902, 0.34902, 0.34902))
Beam426.Enabled = false
Beam426.FaceCamera = true
Beam426.LightEmission = 1
Beam426.LightInfluence = 1
Beam426.Segments = 50
Beam426.Texture = "rbxassetid://2463944225"
Beam426.TextureSpeed = 0
Beam426.Transparency = NumberSequence.new(1,0,0,1)
Beam426.Width0 = 0.10000000149012
Beam426.Width1 = 2
Beam427.Name = "Beam1"
Beam427.Parent = Part425
Beam427.Attachment0 = nil
Beam427.Attachment1 = nil
Beam427.Color = ColorSequence.new(Color3.new(1, 0.966445, 0.826612),Color3.new(0.97731, 0.951751, 0.782223))
Beam427.Enabled = false
Beam427.FaceCamera = true
Beam427.LightEmission = 1
Beam427.Segments = 50
Beam427.Texture = "rbxassetid://2463944225"
Beam427.TextureSpeed = 0
Beam427.Transparency = NumberSequence.new(1,0,0,1)
Beam427.Width0 = 0.10000000149012
Beam427.Width1 = 3
Sound428.Name = "HitSound"
Sound428.Parent = mas
Sound428.SoundId = "rbxassetid://1489924400"
Sound428.Volume = 0.25
ParticleEmitter429.Name = "HitParticles"
ParticleEmitter429.Parent = mas
ParticleEmitter429.Speed = NumberRange.new(0, 10)
ParticleEmitter429.Rotation = NumberRange.new(-180, 180)
ParticleEmitter429.Color = ColorSequence.new(Color3.new(1, 0, 1),Color3.new(1, 0, 1),Color3.new(0.333333, 0.309804, 0.290196),Color3.new(0.266667, 0.266667, 0.266667))
ParticleEmitter429.Enabled = false
ParticleEmitter429.LightEmission = 0.10000000149012
ParticleEmitter429.LightInfluence = 1
ParticleEmitter429.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter429.Transparency = NumberSequence.new(1,0,0,0.69135802984238,0.84567904472351,0.9753086566925,1)
ParticleEmitter429.Size = NumberSequence.new(0,2.048611164093,3.1597220897675,4.7569441795349,5.034722328186)
ParticleEmitter429.Acceleration = Vector3.new(0, 5, 0)
ParticleEmitter429.Drag = 0.5
ParticleEmitter429.EmissionDirection = Enum.NormalId.Front
ParticleEmitter429.Lifetime = NumberRange.new(0.10000000149012, 2)
ParticleEmitter429.Rate = 0
ParticleEmitter429.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter429.SpreadAngle = Vector2.new(30, 30)
ParticleEmitter429.VelocityInheritance = -0.0010000000474975
ParticleEmitter429.VelocitySpread = 30
Folder430.Name = "HitMarks"
Folder430.Parent = Folder385
Part431.Name = "BulletHole"
Part431.Parent = Folder430
Part431.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part431.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part431.Transparency = 1
Part431.Size = Vector3.new(0.5, 0.5, 0.0500000007)
Part431.BottomSurface = Enum.SurfaceType.Smooth
Part431.CanCollide = false
Part431.TopSurface = Enum.SurfaceType.Smooth
BillboardGui432.Name = "ImpactBillboard"
BillboardGui432.Parent = Part431
BillboardGui432.LightInfluence = 1
BillboardGui432.Size = UDim2.new(5, 0, 5, 0)
BillboardGui432.ResetOnSpawn = false
BillboardGui432.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
BillboardGui432.Adornee = Part431
BillboardGui432.ExtentsOffset = Vector3.new(0, 0, 0.25)
ImageLabel433.Name = "Impact"
ImageLabel433.Parent = BillboardGui432
ImageLabel433.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel433.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel433.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel433.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel433.BackgroundTransparency = 1
ImageLabel433.BorderSizePixel = 0
ImageLabel433.Image = "rbxassetid://3918596245"
ImageLabel433.ImageTransparency = 1
Decal434.Name = "BulletHole"
Decal434.Parent = Part431
Decal434.Texture = "http://www.roblox.com/asset/?id=2078626"
Decal434.Transparency = 1
Decal434.Face = Enum.NormalId.Back
Decal434.Color3 = Color3.new(1, 0.831373, 0.435294)
Part435.Name = "Pellet"
Part435.Parent = Folder430
Part435.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part435.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part435.Transparency = 1
Part435.Size = Vector3.new(0.200000003, 0.200000003, 0.0500000007)
Part435.BottomSurface = Enum.SurfaceType.Smooth
Part435.CanCollide = false
Part435.TopSurface = Enum.SurfaceType.Smooth
Decal436.Name = "BulletHole"
Decal436.Parent = Part435
Decal436.Texture = "http://www.roblox.com/asset/?id=2078626"
Decal436.Transparency = 1
Decal436.Face = Enum.NormalId.Back
Decal436.Color3 = Color3.new(1, 0.831373, 0.435294)
Part437.Name = "Arrow"
Part437.Parent = Folder430
Part437.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part437.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
Part437.Transparency = 1
Part437.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part437.BottomSurface = Enum.SurfaceType.Smooth
Part437.CanCollide = false
Part437.TopSurface = Enum.SurfaceType.Smooth
SpecialMesh438.Parent = Part437
SpecialMesh438.MeshId = "rbxassetid://2493118549"
SpecialMesh438.Offset = Vector3.new(0, 0, 0.75)
SpecialMesh438.Scale = Vector3.new(0.43178001, 0.43178001, 0.43178001)
SpecialMesh438.TextureId = "rbxassetid://2493025364"
SpecialMesh438.MeshType = Enum.MeshType.FileMesh
Part439.Name = "Scorch"
Part439.Parent = Folder430
Part439.CFrame = CFrame.new(-5.2789588, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part439.Position = Vector3.new(-5.2789588, 4.99302006, -11.435256)
Part439.Transparency = 1
Part439.Size = Vector3.new(2, 2, 0.0500000007)
Part439.BottomSurface = Enum.SurfaceType.Smooth
Part439.CanCollide = false
Part439.TopSurface = Enum.SurfaceType.Smooth
Decal440.Name = "ScorchMark"
Decal440.Parent = Part439
Decal440.Texture = "rbxassetid://53875997"
Decal440.Transparency = 1
Decal440.Face = Enum.NormalId.Back
Decal441.Name = "Glow"
Decal441.Parent = Part439
Decal441.Texture = "http://www.roblox.com/asset/?id=246689799"
Decal441.Transparency = 1
Decal441.Face = Enum.NormalId.Back
Decal441.Color3 = Color3.new(1, 0.258824, 0.113725)
Part442.Name = "Explosion"
Part442.Parent = Folder430
Part442.CFrame = CFrame.new(-5.2789588, 4.99302006, -11.435256, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part442.Position = Vector3.new(-5.2789588, 4.99302006, -11.435256)
Part442.Transparency = 1
Part442.Size = Vector3.new(2.5, 2.5, 0.0500000007)
Part442.BottomSurface = Enum.SurfaceType.Smooth
Part442.CanCollide = false
Part442.TopSurface = Enum.SurfaceType.Smooth
Decal443.Name = "ScorchMark"
Decal443.Parent = Part442
Decal443.Texture = "rbxassetid://53875997"
Decal443.Transparency = 1
Decal443.Face = Enum.NormalId.Back
Decal444.Name = "Glow"
Decal444.Parent = Part442
Decal444.Texture = "http://www.roblox.com/asset/?id=246689799"
Decal444.Transparency = 1
Decal444.Face = Enum.NormalId.Back
Decal444.Color3 = Color3.new(1, 0.258824, 0.113725)
Folder445.Name = "Casings"
Folder445.Parent = Folder385
MeshPart446.Name = "RifleCasing"
MeshPart446.Parent = Folder445
MeshPart446.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 0, 1, -0, -1, 0, 0, 0, 0, 1)
MeshPart446.Orientation = Vector3.new(0, 0, -90)
MeshPart446.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
MeshPart446.Rotation = Vector3.new(0, 0, -90)
MeshPart446.Color = Color3.new(1, 0.690196, 0)
MeshPart446.Transparency = 1
MeshPart446.Size = Vector3.new(0.105999999, 0.330000013, 0.105999999)
MeshPart446.BrickColor = BrickColor.new("Deep orange")
MeshPart446.Material = Enum.Material.Metal
MeshPart446.brickColor = BrickColor.new("Deep orange")
MeshPart446.TextureID = "rbxassetid://2794275376"
Sound447.Name = "CasingHitSound"
Sound447.Parent = MeshPart446
Sound447.EmitterSize = 1
Sound447.MinDistance = 1
Sound447.SoundId = "rbxassetid://3909012115"
Sound447.Volume = 1
MeshPart448.Name = "PistolCasing"
MeshPart448.Parent = Folder445
MeshPart448.CFrame = CFrame.new(-6.52995777, 4.99302006, -11.435256, 0, 1, -0, -1, 0, 0, 0, 0, 1)
MeshPart448.Orientation = Vector3.new(0, 0, -90)
MeshPart448.Position = Vector3.new(-6.52995777, 4.99302006, -11.435256)
MeshPart448.Rotation = Vector3.new(0, 0, -90)
MeshPart448.Color = Color3.new(1, 0.690196, 0)
MeshPart448.Transparency = 1
MeshPart448.Size = Vector3.new(0.0829999968, 0.107000001, 0.0829999968)
MeshPart448.BrickColor = BrickColor.new("Deep orange")
MeshPart448.Material = Enum.Material.Metal
MeshPart448.brickColor = BrickColor.new("Deep orange")
MeshPart448.TextureID = "rbxassetid://2794275376"
Sound449.Name = "CasingHitSound"
Sound449.Parent = MeshPart448
Sound449.EmitterSize = 1
Sound449.MinDistance = 1
Sound449.SoundId = "rbxassetid://3909012115"
Sound449.Volume = 1
LocalScript450.Name = "ClientWeaponsScript"
LocalScript450.Parent = Folder341
table.insert(cors,sandbox(LocalScript450,function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local playerChildAddedConnection
local replicatedStorageChildAddedConnection
local clientWeaponsScript
local weaponsSystemFolder

local function setupWeaponsSystem()
	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
end

local function onReplicatedStorageChildAdded(child)
	if child.Name == "WeaponsSystem" then
		setupWeaponsSystem()
		replicatedStorageChildAddedConnection:Disconnect()
	end
end

local function onPlayerChildAdded(child)
	if child.Name == "PlayerScripts" then
		clientWeaponsScript.Parent = child
		playerChildAddedConnection:Disconnect()
	end
end

if script.Parent.Name ~= "PlayerScripts" then
	clientWeaponsScript = script:Clone()
	local PlayerScripts = script.Parent.Parent:FindFirstChild("PlayerScripts")
	
	if PlayerScripts ~= nil then
		clientWeaponsScript.Parent = PlayerScripts
	else
		playerChildAddedConnection = script.Parent.Parent.ChildAdded:Connect(onPlayerChildAdded)
	end
else
	weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
	if weaponsSystemFolder ~= nil then
		setupWeaponsSystem()
	else
		replicatedStorageChildAddedConnection = ReplicatedStorage.ChildAdded:Connect(onReplicatedStorageChildAdded)
	end
end
end))
ModuleScript451.Name = "NetworkingCallbacks"
ModuleScript451.Parent = Folder341
table.insert(cors,sandbox(ModuleScript451,function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()
local LocalPlayer = (not IsServer) and Players.LocalPlayer or nil

local NetworkingCallbacks = {}
NetworkingCallbacks.WeaponsSystem = nil

function NetworkingCallbacks.WeaponFired(player, instance, fireInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weaponType.CanBeFired and weapon.player == player then
			weapon:onFired(player, fireInfo, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadRequest(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded then
			weapon:reload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloaded(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= nil and player ~= LocalPlayer then
			weapon:onReloaded(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadCanceled(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= LocalPlayer then
			weapon:cancelReload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponHit(player, instance, hitInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanHit then
			if IsServer then
				weapon:onHit(hitInfo)
			end
		end
	end
end

function NetworkingCallbacks.WeaponActivated(player, instance, activated)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weapon.player == player then
			weapon:setActivated(activated, true)
		end
	end
end

return NetworkingCallbacks

end))
Folder452.Name = "WeaponTypes"
Folder452.Parent = Folder341
ModuleScript453.Name = "BowWeapon"
ModuleScript453.Parent = Folder452
table.insert(cors,sandbox(ModuleScript453,function()
local RunService = game:GetService("RunService")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent

local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local BulletWeapon = require(WeaponTypes:WaitForChild("BulletWeapon"))

local BowWeapon = {}
BowWeapon.__index = BowWeapon
setmetatable(BowWeapon, BulletWeapon)

BowWeapon.CanAimDownSights = true
BowWeapon.CanBeFired = true
BowWeapon.CanBeReloaded = true
BowWeapon.CanHit = true

function BowWeapon.new(weaponsSystem, instance)
	local self = BulletWeapon.new(weaponsSystem, instance)
	setmetatable(self, BowWeapon)

	self.hasArrow = true

	self.arrowPart = self.instance:FindFirstChild("Arrow", true)
	self.armsPart = self.instance:FindFirstChild("Arms", true)
	if self.armsPart then
		self.armsMesh = self.armsPart:FindFirstChildOfClass("SpecialMesh")

		self.tightOffsetValue = self.armsPart:FindFirstChild("TightOffset")
		self.tightScaleValue = self.armsPart:FindFirstChild("TightScale")

		self.looseOffsetValue = self.armsPart:FindFirstChild("LooseOffset")
		self.looseScaleValue = self.armsPart:FindFirstChild("LooseScale")

		self.leftLooseAttach = self.armsPart:FindFirstChild("LeftLoose")
		self.rightLooseAttach = self.armsPart:FindFirstChild("RightLoose")

		self.leftTightAttach = self.armsPart:FindFirstChild("LeftTight")
		self.rightTightAttach = self.armsPart:FindFirstChild("RightTight")

		self.leftString0 = self.armsPart:FindFirstChild("LeftString0")
		self.rightString0 = self.armsPart:FindFirstChild("RightString0")
	end

	self.string1 = self.instance:FindFirstChild("String1", true)
	self.stringLooseAttach = self.instance:FindFirstChild("StringLoose", true)
	self.stringTightAttach = self.instance:FindFirstChild("StringTight", true)

	self:setHasArrow(false)

	return self
end

function BowWeapon:renderCharge()
	if self.armsMesh and self.looseOffsetValue and self.looseScaleValue and self.tightOffsetValue and self.tightScaleValue then
		local looseOffset, tightOffset = self.looseOffsetValue.Value, self.tightOffsetValue.Value
		local looseScale, tightScale = self.looseScaleValue.Value, self.tightScaleValue.Value

		self.armsMesh.Offset = looseOffset:Lerp(tightOffset, self.charge)
		self.armsMesh.Scale = looseScale:Lerp(tightScale, self.charge)
	end

	if self.leftString0 and self.leftLooseAttach and self.leftTightAttach then
		self.leftString0.CFrame = self.leftLooseAttach.CFrame:lerp(self.leftTightAttach.CFrame, self.charge)
	end
	if self.rightString0 and self.rightLooseAttach and self.rightTightAttach then
		self.rightString0.CFrame = self.rightLooseAttach.CFrame:lerp(self.rightTightAttach.CFrame, self.charge)
	end

	if self.string1 and self.stringLooseAttach and self.stringTightAttach then
		self.string1.CFrame = self.stringLooseAttach.CFrame:lerp(self.stringTightAttach.CFrame, self.charge)
	end
end

function BowWeapon:handleCharging(dt)
	if self.hasArrow then return end
	BulletWeapon.handleCharging(self, dt)

	if self.charge >= 1 then
		self:setHasArrow(true)
	end
end

function BowWeapon:onActivatedChanged()
	if not IsServer then
		if not self.activated then
			if self.didFire then
				self.didFire = false
			end
		end
	end
	BulletWeapon.onActivatedChanged(self)
end

function BowWeapon:isCharged()
	return self.hasArrow and self.charge >= 1
end

function BowWeapon:doLocalFire()
	BulletWeapon.doLocalFire(self)
	self:setHasArrow(false)
	self.didFire = true
end

function BowWeapon:setHasArrow(hasArrow)
	if self.hasArrow == hasArrow then
		return
	end

	self.hasArrow = hasArrow
	if self.arrowPart then
		self.arrowPart.Transparency = self.hasArrow and 0 or 1
	end
end

return BowWeapon
end))
ModuleScript454.Name = "BulletWeapon"
ModuleScript454.Parent = Folder452
table.insert(cors,sandbox(ModuleScript454,function()
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local ContextActionService = game:GetService("ContextActionService")
local CollectionService = game:GetService("CollectionService")
local ContentProvider = game:GetService("ContentProvider")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local BaseWeapon = require(Libraries:WaitForChild("BaseWeapon"))
local Parabola = require(Libraries:WaitForChild("Parabola"))
local Roblox = require(Libraries:WaitForChild("Roblox"))

local Effects = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Effects")
local ShotsFolder = Effects:WaitForChild("Shots")
local HitMarksFolder = Effects:WaitForChild("HitMarks")
local CasingsFolder = Effects:WaitForChild("Casings")

local NO_BULLET_DECALS = false
local NO_BULLET_CASINGS = false

--The ignore list will fill up over time. This is how many seconds it will go before
--being refreshed in order to keep it from filling up with instances that aren't in
--the datamodel anymore.
local IGNORE_LIST_LIFETIME = 5

local MAX_BULLET_TIME = 10

local localRandom = Random.new()
local localPlayer = not IsServer and Players.LocalPlayer

local BulletWeapon = {}
BulletWeapon.__index = BulletWeapon
setmetatable(BulletWeapon, BaseWeapon)

BulletWeapon.CanAimDownSights = true
BulletWeapon.CanBeFired = true
BulletWeapon.CanBeReloaded = true
BulletWeapon.CanHit = true

function BulletWeapon.new(weaponsSystem, instance)
	local self = BaseWeapon.new(weaponsSystem, instance)
	setmetatable(self, BulletWeapon)

	self.usesCharging = false
	self.charge = 0
	self.chargeSoundPitchMin = 0.5
	self.chargeSoundPitchMax = 1

	self.triggerDisconnected = false
	self.startupFinished = false -- TODO: make startup time use a configuration value
	self.burstFiring = false
	self.burstIdx = 0
	self.nextFireTime = 0

	self.recoilIntensity = 0
	self.aimPoint = Vector3.new()

	self:addOptionalDescendant("tipAttach", "TipAttachment")

	self:addOptionalDescendant("boltMotor", "BoltMotor")
	self:addOptionalDescendant("boltMotorStart", "BoltMotorStart")
	self:addOptionalDescendant("boltMotorTarget", "BoltMotorTarget")

	self:addOptionalDescendant("chargeGlowPart", "ChargeGlow")
	self:addOptionalDescendant("chargeCompleteParticles", "ChargeCompleteParticles")
	self:addOptionalDescendant("dischargeCompleteParticles", "DischargeCompleteParticles")

	self:addOptionalDescendant("muzzleFlash0", "MuzzleFlash0")
	self:addOptionalDescendant("muzzleFlash1", "MuzzleFlash1")
	self:addOptionalDescendant("muzzleFlashBeam", "MuzzleFlash")

	self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))

	self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
	self:addOptionalDescendant("casingEjectPoint", "CasingEjectPoint")

	self.ignoreList = {}
	self.ignoreListRefreshTime = 0

	self:addOptionalDescendant("handAttach", "LeftHandAttachment")
	self.handAlignPos = nil
	self.handAlignRot = nil

	self.chargingParticles = {}
	self.instance.DescendantAdded:Connect(function(descendant)
		if descendant.Name == "ChargingParticles" and descendant:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, descendant)
		end
	end)
	for _, v in pairs(self.instance:GetDescendants()) do
		if v.Name == "ChargingParticles" and v:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, v)
		end
	end

	self:doInitialSetup()

	return self
end

function BulletWeapon:onEquippedChanged()
	BaseWeapon.onEquippedChanged(self)

	if not IsServer then
		if self.weaponsSystem.camera then
			if self.equipped then
				self.startupFinished = false
			end
		end

		if self.equipped then
			ContextActionService:BindAction("ReloadWeapon", function(...) self:onReloadAction(...) end, false, Enum.KeyCode.R, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindAction("ReloadWeapon")

			-- Stop charging/discharging sounds
			local chargingSound = self:getSound("Charging")
			local dischargingSound = self:getSound("Discharging")
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
		end

		self.triggerDisconnected = false
	end
end

function BulletWeapon:onReloadAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin and not self.reloading then
		self:reload()
	end
end

function BulletWeapon:animateBoltAction(isOpen)
	if not self.boltMotor or not self.boltMotorStart or not self.boltMotorTarget then
		return
	end

	if isOpen then
		self:tryPlaySound("BoltOpenSound")
	else
		self:tryPlaySound("BoltCloseSound")
	end

	local actionMoveTime = isOpen and self:getConfigValue("ActionOpenTime", 0.025) or self:getConfigValue("ActionCloseTime", 0.075)
	local targetCFrame = isOpen and self.boltMotorTarget.CFrame or self.boltMotorStart.CFrame

	local boltTween = TweenService:Create(self.boltMotor, TweenInfo.new(actionMoveTime, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { C0 = targetCFrame })
	boltTween:Play()
	boltTween.Completed:Wait()
end

function BulletWeapon:getRandomSeedForId(id)
	return id
end

-- This function is only called on clients
function BulletWeapon:simulateFire(firingPlayer, fireInfo)
	BaseWeapon.simulateFire(self, fireInfo)

	-- Play "Fired" sound
	if self.lastFireSound then
		self.lastFireSound:Stop()
	end
	self.lastFireSound = self:tryPlaySound("Fired", self:getConfigValue("FiredPlaybackSpeedRange", 0.1))

	-- Simulate each projectile/bullet fired from current weapon
	local numProjectiles = self:getConfigValue("NumProjectiles", 1)
	local randomGenerator = Random.new(self:getRandomSeedForId(fireInfo.id))
	for i = 1, numProjectiles do
		self:simulateProjectile(firingPlayer, fireInfo, i, randomGenerator)
	end

	-- Animate the bolt if the current gun has one
	local actionOpenTime = self:getConfigValue("ActionOpenTime", 0.025)
	if self.boltMotor then
		coroutine.wrap(function()
			self:animateBoltAction(true)
			wait(actionOpenTime)
			self:animateBoltAction(false)
		end)()
	end

	-- Eject bullet casings and play "CasingHitSound" (child of casing) sound if applicable for current weapon
	if not NO_BULLET_CASINGS and self.casingTemplate and self.casingEjectPoint then
		local casing = self.casingTemplate:Clone()
		casing.Anchored = false
		casing.Archivable = false
		casing.CFrame = self.casingEjectPoint.WorldCFrame
		casing.Velocity = self.casingEjectPoint.Parent.Velocity + (self.casingEjectPoint.WorldAxis * localRandom:NextNumber(self:getConfigValue("CasingEjectSpeedMin", 15), self:getConfigValue("CasingEjectSpeedMax", 18)))
		casing.Parent = workspace.CurrentCamera
		CollectionService:AddTag(casing, "WeaponsSystemIgnore")

		local casingHitSound = casing:FindFirstChild("CasingHitSound")
		if casingHitSound then
			local touchedConn = nil
			touchedConn = casing.Touched:Connect(function(hitPart)
				if not hitPart:IsDescendantOf(self.instance) then
					casingHitSound:Play()
					touchedConn:Disconnect()
					touchedConn = nil
				end
			end)
		end

		Debris:AddItem(casing, 2)
	end

	if self.player == Players.LocalPlayer then
		coroutine.wrap(function()
			-- Wait for "RecoilDelayTime" before adding recoil
			local startTime = tick()
			local recoilDelayTime = self:getConfigValue("RecoilDelayTime", 0.07)
			while tick() < startTime + recoilDelayTime do
				RunService.RenderStepped:Wait()
			end
			RunService.RenderStepped:Wait()

			-- Add recoil to camera
			local recoilMin, recoilMax = self:getConfigValue("RecoilMin", 0.05), self:getConfigValue("RecoilMax", 0.5)
			local intensityToAdd = randomGenerator:NextNumber(recoilMin, recoilMax)
			local xIntensity = math.sin(tick() * 2) * intensityToAdd * math.rad(0.05)
			local yIntensity = intensityToAdd * 0.025
			self.weaponsSystem.camera:addRecoil(Vector2.new(xIntensity, yIntensity))

			if not (self.weaponsSystem.camera:isZoomed() and self:getConfigValue("HasScope", false)) then
				self.recoilIntensity = math.clamp(self.recoilIntensity * 1 + (intensityToAdd / 10), 0.005, 1)
			end

			-- Make crosshair reflect recoil/spread amount
			local weaponsGui = self.weaponsSystem.gui
			if weaponsGui then
				weaponsGui:setCrosshairScale(1 + intensityToAdd)
			end
		end)()
	end
end

function BulletWeapon:getIgnoreList(includeLocalPlayer)
	local now = tick()
	local ignoreList = self.ignoreList
	if not ignoreList or now - self.ignoreListRefreshTime > IGNORE_LIST_LIFETIME then
		ignoreList = {
			self.instanceIsTool and self.instance.Parent or self.instance,
			workspace.CurrentCamera
		}
		if not RunService:IsServer() then
			if includeLocalPlayer and Players.LocalPlayer and Players.LocalPlayer.Character then
				table.insert(ignoreList, Players.LocalPlayer.Character)
			end
		end
		self.ignoreList = ignoreList
	end
	return ignoreList
end

-- This function is only called on clients
function BulletWeapon:simulateProjectile(firingPlayer, fireInfo, projectileIdx, randomGenerator)
	local localPlayerInitiatedShot = self.player == Players.LocalPlayer

	-- Retrieve config values
	local bulletSpeed = self:getConfigValue("BulletSpeed", 1000)
	local maxDistance = self:getConfigValue("MaxDistance", 2000)
	local trailLength = self:getConfigValue("TrailLength", nil)
	local trailLengthFactor = self:getConfigValue("TrailLengthFactor", 1)
	local showEntireTrailUntilHit = self:getConfigValue("ShowEntireTrailUntilHit", false)
	local gravityFactor = self:getConfigValue("GravityFactor", 0)
	local minSpread = self:getConfigValue("MinSpread", 0)
	local maxSpread = self:getConfigValue("MaxSpread", 0)
	local shouldMovePart = self:getConfigValue("ShouldMovePart", false)
	local explodeOnImpact = self:getConfigValue("ExplodeOnImpact", false)
	local blastRadius = self:getConfigValue("BlastRadius", 8)

	-- Cheat the origin of the shot back if gun tip in wall/object
	if self.tipAttach ~= nil then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local tipDir = tipCFrame.LookVector
		local amountToCheatBack = math.abs((self.instance:FindFirstChild("Handle").Position - tipPos):Dot(tipDir)) + 1
		local gunRay = Ray.new(tipPos - tipDir.Unit * amountToCheatBack, tipDir.Unit * amountToCheatBack)
		local hitPart, hitPoint = Roblox.penetrateCast(gunRay, self:getIgnoreList(localPlayerInitiatedShot))
		if hitPart and math.abs((tipPos - hitPoint).Magnitude) > 0 then
			fireInfo.origin = hitPoint - tipDir.Unit * 0.1
			fireInfo.dir = tipDir.Unit
		end
	end

	local origin, dir = fireInfo.origin, fireInfo.dir

	dir = Roblox.applySpread(dir, randomGenerator, math.rad(minSpread), math.rad(maxSpread))

	-- Initialize variables for visuals/particle effects
	local bulletEffect = self.bulletEffectTemplate:Clone()
	bulletEffect.CFrame = CFrame.new(origin, origin + dir)
	bulletEffect.Parent = workspace.CurrentCamera
	CollectionService:AddTag(bulletEffect, "WeaponsSystemIgnore")

	local leadingParticles = bulletEffect:FindFirstChild("LeadingParticles", true)
	local attachment0 = bulletEffect:FindFirstChild("Attachment0")
	local trailParticles = nil
	if attachment0 then
		trailParticles = attachment0:FindFirstChild("TrailParticles")
	end

	local hitAttach = bulletEffect:FindFirstChild("HitEffect")
	local hitParticles = bulletEffect:FindFirstChild("HitParticles", true)
	local numHitParticles = self:getConfigValue("NumHitParticles", 3)
	local hitSound = bulletEffect:FindFirstChild("HitSound", true)
	local flyingSound = bulletEffect:FindFirstChild("Flying", true)

	local muzzleFlashTime = self:getConfigValue("MuzzleFlashTime", 0.03)
	local muzzleFlashShown = false

	local beamThickness0 = self:getConfigValue("BeamWidth0", 1.5)
	local beamThickness1 = self:getConfigValue("BeamWidth1", 1.8)
	local beamFadeTime = self:getConfigValue("BeamFadeTime", nil)

	-- Enable beam trails for projectile
	local beam0 = bulletEffect:FindFirstChild("Beam0")
	if beam0 then
		beam0.Enabled = true
	end
	local beam1 = bulletEffect:FindFirstChild("Beam1")
	if beam1 then
		beam1.Enabled = true
	end

	-- Emit muzzle particles
	local muzzleParticles = bulletEffect:FindFirstChild("MuzzleParticles", true)
	local numMuzzleParticles = self:getConfigValue("NumMuzzleParticles", 50)
	if muzzleParticles then
		muzzleParticles.Parent.CFrame = CFrame.new(origin, origin + dir)
		local numSteps = 5
		for _ = 1, numSteps do
			muzzleParticles.Parent.Velocity = Vector3.new(localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10))
			muzzleParticles:Emit(numMuzzleParticles / numSteps)
		end
	end

	-- Show muzzle flash
	if self.tipAttach and self.muzzleFlash0 and self.muzzleFlash1 and self.muzzleFlashBeam and projectileIdx == 1 then
		local minFlashRotation, maxFlashRotation = self:getConfigValue("MuzzleFlashRotation0", -math.pi), self:getConfigValue("MuzzleFlashRotation1", math.pi)
		local minFlashSize, maxFlashSize = self:getConfigValue("MuzzleFlashSize0", 1), self:getConfigValue("MuzzleFlashSize1", 1)
		local flashRotation = localRandom:NextNumber(minFlashRotation, maxFlashRotation)
		local flashSize = localRandom:NextNumber(minFlashSize, maxFlashSize)
		local baseCFrame = self.tipAttach.CFrame * CFrame.Angles(0, 0, flashRotation)
		self.muzzleFlash0.CFrame = baseCFrame * CFrame.new(flashSize * -0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)
		self.muzzleFlash1.CFrame = baseCFrame * CFrame.new(flashSize * 0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)

		self.muzzleFlashBeam.Enabled = true
		self.muzzleFlashBeam.Width0 = flashSize
		self.muzzleFlashBeam.Width1 = flashSize
		muzzleFlashShown = true
	end

	-- Play projectile flying sound
	if flyingSound then
		flyingSound:Play()
	end

	-- Enable trail particles
	if trailParticles then
		trailParticles.Enabled = true
	end

	-- Set up parabola for projectile path
	local parabola = Parabola.new()
	parabola:setPhysicsLaunch(origin, dir * bulletSpeed, nil, 35 * -gravityFactor)
	-- More samples for higher gravity since path will be more curved but raycasts can only be straight lines
	if gravityFactor > 0.66 then
		parabola:setNumSamples(3)
	elseif gravityFactor > 0.33 then
		parabola:setNumSamples(2)
	else
		parabola:setNumSamples(1)
	end

	-- Set up/initialize variables used in steppedCallback
	local stepConn = nil
	local pTravelDistance = 0 -- projected travel distance so far if projectile never stops
	local startTime = tick()
	local didHit = false
	local stoppedMotion = false
	local stoppedMotionAt = 0
	local timeSinceStart = 0
	local flyingVisualEffectsFinished = false -- true if all particle effects shown while projectile is flying are done
	local visualEffectsFinishTime = math.huge
	local visualEffectsLingerTime = 0 -- max time any visual effect needs to finish
	if beamFadeTime then
		visualEffectsLingerTime = beamFadeTime
	end
	local hitInfo = {
		sid = fireInfo.id,
		pid = projectileIdx,
		maxDist = maxDistance,
		part = nil,
		p = nil,
		n = nil,
		m = Enum.Material.Air,
		d = 1e9,
	}

	local steppedCallback = function(dt)
		local now = tick()
		timeSinceStart = now - startTime

		local travelDist = bulletSpeed * dt -- distance projectile has travelled since last frame
		trailLength = trailLength or travelDist * trailLengthFactor

		-- Note: the next three variables are all in terms of distance from starting point (which should be tip of current weapon)
		local projBack = pTravelDistance - trailLength -- furthest back part of projectile (including the trail effect, so will be the start of the trail effect if any)
		local projFront = pTravelDistance -- most forward part of projectile
		local maxDist = hitInfo.maxDist or 0 -- before it collides, this is the max distance the projectile can travel. After it collides, this is the hit point

		-- This will make trailing beams render from tip of gun to wherever projectile is until projectile is destroyed
		if showEntireTrailUntilHit then
			projBack = 0
		end

		-- Validate projBack and projFront
		projBack = math.clamp(projBack, 0, maxDist)
		projFront = math.clamp(projFront, 0, maxDist)

		if not didHit then
			-- Check if bullet hit since last frame
			local castProjBack, castProjFront = projFront, projFront + travelDist
			parabola:setDomain(castProjBack, castProjFront)
			local hitPart, hitPoint, hitNormal, hitMaterial, hitT = parabola:findPart(self.ignoreList)

			if hitPart then
				didHit = true
				projFront = castProjBack + hitT * (castProjFront - castProjBack) -- set projFront to point along projectile arc where an object was hit
				parabola:setDomain(projBack, projFront) -- update parabola domain to match new projFront

				-- Update hitInfo
				hitInfo.part = hitPart
				hitInfo.p = hitPoint
				hitInfo.n = hitNormal
				hitInfo.m = hitMaterial
				hitInfo.d = (hitPoint - origin).Magnitude
				hitInfo.t = hitT
				hitInfo.maxDist = projFront -- since the projectile hit, maxDist is now the hitPoint instead of maxDistance

				-- Register hit on clients
				self:onHit(hitInfo)

				-- Notify the server that this projectile hit something from client that initiated the shot
				-- Show hit indicators on gui of client that shot projectile
				if localPlayerInitiatedShot then
					local hitInfoClone = {}
					for hitInfoKey, value in pairs(hitInfo) do
						hitInfoClone[hitInfoKey] = value
					end
					self.weaponsSystem.getRemoteEvent("WeaponHit"):FireServer(self.instance, hitInfoClone)
				end


				-- Deal with all effects that start/stop/change on hit

				-- Disable trail particles
				if trailParticles then
					trailParticles.Enabled = false
				end

				-- Stop bullet flying sound
				if flyingSound and flyingSound.IsPlaying then
					flyingSound:Stop()
				end

				-- Hide the actual projectile model
				if bulletEffect then
					bulletEffect.Transparency = 1
				end

				-- Stop emitting leading particles
				if leadingParticles then
					leadingParticles.Rate = 0
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, leadingParticles.Lifetime.Max)
				end

				-- Show the explosion on clients for explosive projectiles
				if explodeOnImpact then
					local explosion = Instance.new("Explosion")
					explosion.Position = hitPoint + (hitNormal * 0.5)
					explosion.BlastRadius = blastRadius
					explosion.BlastPressure = 0 -- no blast pressure because the real explosion happens on server
					explosion.ExplosionType = Enum.ExplosionType.NoCraters
					explosion.DestroyJointRadiusPercent = 0
					explosion.Visible = true
					if localPlayerInitiatedShot then
						-- Trigger hit indicators on client that initiated the shot if the explosion hit another player/humanoid
						explosion.Hit:Connect(function(explodedPart, hitDist)
							local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
							if humanoid and
							   explodedPart.Name == "UpperTorso" and
							   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
							   self.weaponsSystem.gui and
							   explodedPart.Parent ~= self.player.Character and
							   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
							then
								self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), humanoid)
							end
						end)
					end
					explosion.Parent = workspace
				end

				-- Make sure hitAttach is in correct position before showing hit effects
				if hitAttach and beam0 and beam0.Attachment1 then
					parabola:renderToBeam(beam0)
					hitAttach.CFrame = beam0.Attachment1.CFrame * CFrame.Angles(0, math.rad(90), 0)
				end

				-- Show hit particle effect
				local hitPartColor = hitPart and hitPart.Color or Color3.fromRGB(255, 255, 255)
				if hitPart and hitPart:IsA("Terrain") then
					hitPartColor = workspace.Terrain:GetMaterialColor(hitMaterial or Enum.Material.Sand)
				end
				if hitInfo.h and hitInfo.h:IsA("Humanoid") and hitParticles and numHitParticles > 0 and hitPart then
					-- Show particle effect for hitting a player/humanoid
					hitParticles.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				elseif (not hitInfo.h or not hitInfo.h:IsA("Humanoid")) and hitParticles and numHitParticles > 0 then
					-- Show particle effect for hitting anything else
					if hitPart and self:getConfigValue("HitParticlesUsePartColor", true) then
						local existingSeq = hitParticles.Color
						local newKeypoints = {}

						for i, keypoint in pairs(existingSeq.Keypoints) do
							local newColor = keypoint.Value
							if newColor == Color3.fromRGB(255, 0, 255) then
								newColor = hitPartColor
							end
							newKeypoints[i] = ColorSequenceKeypoint.new(keypoint.Time, newColor)
						end

						hitParticles.Color = ColorSequence.new(newKeypoints)
					end

					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				end

				-- Play hit sound
				if hitSound then
					hitSound:Play()
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitSound.TimeLength)
				end

				-- Manage/show decals, billboards, and models (such as an arrow) that appear where the projectile hit (only if the hit object was not a humanoid/player)
				local hitPointObjectSpace = hitPart.CFrame:pointToObjectSpace(hitPoint)
				local hitNormalObjectSpace = hitPart.CFrame:vectorToObjectSpace(hitNormal)
				if not NO_BULLET_DECALS and
				   hitPart and
				   not hitPart.Parent or not hitPart.Parent:FindFirstChildOfClass("Humanoid") and
				   hitPointObjectSpace and
				   hitNormalObjectSpace and
				   self.hitMarkTemplate
				then
					-- Clone hitMark (this contains all the decals/billboards/models to show on the hit surface)
					local hitMark = self.hitMarkTemplate:Clone()
					hitMark.Parent = hitPart
					CollectionService:AddTag(hitMark, "WeaponsSystemIgnore")

					-- Move/align hitMark to the hit surface
					local incomingVec = parabola:sampleVelocity(1).Unit
					if self:getConfigValue("AlignHitMarkToNormal", true) then
						-- Make hitMark face straight out from surface where projectile hit (good for decals)
						local forward = hitNormalObjectSpace
						local up = incomingVec
						local right = -forward:Cross(up).Unit
						up = forward:Cross(right)
						local orientationCFrame = CFrame.fromMatrix(hitPointObjectSpace + hitNormalObjectSpace * 0.05, right, up, -forward)
						hitMark.CFrame = hitPart.CFrame:toWorldSpace(orientationCFrame)
					else
						-- Make hitmark appear stuck in the hit surface from the direction the projectile came from (good for things like arrows)
						hitMark.CFrame = hitPart.CFrame * CFrame.new(hitPointObjectSpace, hitPointObjectSpace + hitPart.CFrame:vectorToObjectSpace(incomingVec))
					end

					-- Weld hitMark to the hitPart
					local weld = Instance.new("WeldConstraint")
					weld.Part0 = hitMark
					weld.Part1 = hitPart
					weld.Parent = hitMark

					-- Fade glow decal over time
					local glowDecal = hitMark:FindFirstChild("Glow")
					if glowDecal then
						coroutine.wrap(function()
							local heartbeat = RunService.Heartbeat
							for i = 0, 1, 1/60 do
								heartbeat:Wait()
								glowDecal.Transparency = (i ^ 2)
							end
						end)()
					end

					-- Set bullethole decal color and fade over time
					local bulletHole = hitMark:FindFirstChild("BulletHole")
					if bulletHole then
						bulletHole.Color3 = hitPartColor
						TweenService:Create(
							bulletHole,
							TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 4),
							{ Transparency = 1 }
						):Play()
					end

					-- Fade impact billboard's size and transparency over time
					local impactBillboard = hitMark:FindFirstChild("ImpactBillboard")
					if impactBillboard then
						local impact = impactBillboard:FindFirstChild("Impact")
						local impactTween = TweenService:Create(
							impact,
							TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
							{ Size = UDim2.new(1, 0, 1, 0) }
						)
						impactTween.Completed:Connect(function()
							TweenService:Create(
								impact,
								TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
								{ Size = UDim2.new(0.5, 0, 0.5, 0), ImageTransparency = 1 }
							):Play()
						end)
						impactTween:Play()
					end

					-- Destroy hitMark in 5 seconds
					Debris:AddItem(hitMark, 5)
				end

				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Will enter this if-statement if projectile hit something or maxDistance has been reached
		if projFront >= maxDist then
			if not stoppedMotion then
				stoppedMotion = true
				stoppedMotionAt = now
			end

			-- Stop particle effects if projectile didn't hit anything and projBack has reached the end
			if projBack >= maxDist and not flyingVisualEffectsFinished then
				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Update parabola domain
		parabola:setDomain(projBack, projFront)

		-- Continue updating pTravelDistance until projBack has reached maxDist (this helps with some visual effects)
		if projBack < maxDist then
			pTravelDistance = math.max(0, timeSinceStart * bulletSpeed)
		end


		-- Update visual effects each frame

		-- Update CFrame/velocity of projectile if the projectile uses a model (such as rocket or grenade)
		if shouldMovePart then
			local bulletPos = parabola:samplePoint(1)
			local bulletVelocity = parabola:sampleVelocity(1)
			bulletEffect.CFrame = CFrame.new(bulletPos, bulletPos + bulletVelocity)
			bulletEffect.Velocity = bulletVelocity.Unit * bulletSpeed
		end

		-- Update thickness and render trailing beams
		local thickness0 = beamThickness0
		local thickness1 = beamThickness1
		if beamFadeTime then
			-- Fade out trail beams if projectile is no longer moving (hit something or reached max distance)
			local timeSinceEnd = stoppedMotion and (now - stoppedMotionAt) or 0
			local fadeAlpha = math.clamp(timeSinceEnd / beamFadeTime, 0, 1)
			thickness0 = thickness0 * (1 - fadeAlpha)
			thickness1 = thickness1 * (1 - fadeAlpha)
		end
		if beam0 then
			beam0.Width0 = thickness0
			beam0.Width1 = thickness1
			parabola:renderToBeam(beam0)
		end
		if beam1 then
			beam1.Width0 = thickness0
			beam1.Width1 = thickness1
			parabola:renderToBeam(beam1)
		end

		-- Disable muzzle flash after muzzleFlashTime seconds have passed
		if muzzleFlashShown and timeSinceStart > muzzleFlashTime and self.muzzleFlashBeam then
			self.muzzleFlashBeam.Enabled = false
			muzzleFlashShown = false
		end

		-- Destroy projectile and attached visual effects when visual effects are done showing or max bullet time has been reached
		local timeSinceParticleEffectsFinished = now - visualEffectsFinishTime
		if (flyingVisualEffectsFinished and timeSinceParticleEffectsFinished > 0) or timeSinceStart > MAX_BULLET_TIME then
			if bulletEffect then
				bulletEffect:Destroy()
				bulletEffect = nil
			end

			stepConn:Disconnect()
		end
	end

	stepConn = RunService.Heartbeat:Connect(steppedCallback)

	-- Get rid of charge on chargeable weapons
	if not IsServer and self.usesCharging then
		self.charge = math.clamp(self.charge - self:getConfigValue("FireDischarge", 1), 0, 1)
	end
end

function BulletWeapon:calculateDamage(travelDistance)
	local zeroDamageDistance = self:getConfigValue("ZeroDamageDistance", 10000)
	local fullDamageDistance = self:getConfigValue("FullDamageDistance", 1000)
	local distRange = zeroDamageDistance - fullDamageDistance
	local falloff = math.clamp(1 - (math.max(0, travelDistance - fullDamageDistance) / math.max(1, distRange)), 0, 1)
	return math.max(self:getConfigValue("HitDamage", 10) * falloff, 0)
end

function BulletWeapon:applyDamage(hitInfo)
	local damage = self:calculateDamage(hitInfo.d)

	if damage <= 0 then
		return
	end

	self.weaponsSystem.doDamage(hitInfo.h, damage, nil, self.player)
end

function BulletWeapon:onHit(hitInfo)
	local hitPoint = hitInfo.p
	local hitNormal = hitInfo.n
	local hitPart = hitInfo.part

	if hitPart and hitPart.Parent then
		local humanoid = self.weaponsSystem.getHumanoid(hitPart)
		hitInfo.h = humanoid or hitPart

		if IsServer and
		   (not hitInfo.h:IsA("Humanoid") or
		   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player))
		then
			self:applyDamage(hitInfo)
		elseif hitInfo.h:IsA("Humanoid") and
			hitInfo.h:GetState() ~= Enum.HumanoidStateType.Dead and
			self.weaponsSystem.gui and
			self.player == Players.LocalPlayer and
			self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player)
		then
			-- Show hit indicators on gui of client that shot projectile if players are not on same team
			self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), hitInfo.h)
		end
	end

	-- Create invisible explosion on server that deals damage to anything caught in the explosion
	if IsServer and self:getConfigValue("ExplodeOnImpact", false) then
		local blastRadius = self:getConfigValue("BlastRadius", 8)
		local blastPressure = self:getConfigValue("BlastPressure", 10000)
		local blastDamage = self:getConfigValue("BlastDamage", 100)

		local explosion = Instance.new("Explosion")
		explosion.Position = hitPoint + (hitNormal * 0.5)
		explosion.BlastRadius = blastRadius
		explosion.BlastPressure = blastPressure
		explosion.ExplosionType = Enum.ExplosionType.NoCraters
		explosion.DestroyJointRadiusPercent = 0
		explosion.Visible = false

		explosion.Hit:Connect(function(explodedPart, hitDist)
			local damageMultiplier = (1 - math.clamp((hitDist / blastRadius), 0, 1))
			local damageToDeal = blastDamage * damageMultiplier

			local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
			if humanoid then
				if explodedPart.Name == "UpperTorso" and
				   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
				   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
				then
					-- Do damage to players/humanoids
					self.weaponsSystem.doDamage(humanoid, damageToDeal, nil, self.player)
				end
			elseif not CollectionService:HasTag(explodedPart, "WeaponsSystemIgnore") then
				-- Do damage to a part (sends damage to breaking system)
				self.weaponsSystem.doDamage(explodedPart, damageToDeal, nil, self.player)
			end
		end)

		explosion.Parent = workspace
	end
end

function BulletWeapon:fire(origin, dir, charge)
	if not self:isCharged() then
		return
	end

	BaseWeapon.fire(self, origin, dir, charge)
end

function BulletWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer and firingPlayer == Players.LocalPlayer and fromNetwork then
		return
	end

	local cooldownTime = self:getConfigValue("ShotCooldown", 0.1)
	local fireMode = self:getConfigValue("FireMode", "Semiautomatic")
	local isSemiAuto = fireMode == "Semiautomatic"
	local isBurst = fireMode == "Burst"

	if isBurst and not self.burstFiring then
		self.burstIdx = 0
		self.burstFiring = true
	elseif isSemiAuto then
		self.triggerDisconnected = true
	end

	-- Calculate cooldown time for burst firing
	if self.burstFiring then
		self.burstIdx = self.burstIdx + 1
		if self.burstIdx >= self:getConfigValue("NumBurstShots", 3) then
			self.burstFiring = false
			self.triggerDisconnected = true
		else
			cooldownTime = self:getConfigValue("BurstShotCooldown", nil) or cooldownTime
		end
	end

	self.nextFireTime = tick() + cooldownTime

	BaseWeapon.onFired(self, firingPlayer, fireInfo, fromNetwork)
end

function BulletWeapon:onConfigValueChanged(valueName, newValue, oldValue)
	BaseWeapon.onConfigValueChanged(self, valueName, newValue, oldValue)
	if valueName == "ShotEffect" then
		self.bulletEffectTemplate = ShotsFolder:FindFirstChild(self:getConfigValue("ShotEffect", "Bullet"))
		if self.bulletEffectTemplate then
			local config = self.bulletEffectTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end

			local beam0 = self.bulletEffectTemplate:FindFirstChild("Beam0")
			if beam0 then
				coroutine.wrap(function()
					ContentProvider:PreloadAsync({ beam0 })
				end)()
			end
		end
	elseif valueName == "HitMarkEffect" then
		self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))
		if self.hitMarkTemplate then
			local config = self.hitMarkTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "CasingEffect" then
		self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
		if self.casingTemplate then
			local config = self.casingTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "ChargeRate" then
		self.usesCharging = newValue ~= nil
	end
end

function BulletWeapon:onActivatedChanged()
	BaseWeapon.onActivatedChanged(self)

	if not IsServer then
		-- Reload if no ammo left in clip
		if self.equipped and self:getAmmoInWeapon() <= 0 then
			self:reload()
			return
		end

		-- Fire weapon
		if self.activated and self.player == localPlayer and self:canFire() and tick() > self.nextFireTime then
			self:doLocalFire()
		end

		-- Reenable trigger after activated changes to false
		if not self.activated and self.triggerDisconnected and not self.burstFiring then
			self.triggerDisconnected = false
		end
	end
end

function BulletWeapon:onRenderStepped(dt)
	BaseWeapon.onRenderStepped(self, dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	local tipCFrame = self.tipAttach.WorldCFrame

	if self.player == Players.LocalPlayer then
		-- Retrieve aim point from camera and update player's aim animation
		local aimTrack = self:getAnimTrack(self:getConfigValue("AimTrack", "RifleAim"))
		local aimZoomTrack = self:getAnimTrack(self:getConfigValue("AimZoomTrack", "RifleAimDownSights"))
		if aimTrack then
			local aimDir = tipCFrame.LookVector

			local gunLookRay = Ray.new(tipCFrame.p, aimDir * 500)

			local _, gunHitPoint = Roblox.penetrateCast(gunLookRay, self.ignoreList)

			if self.weaponsSystem.aimRayCallback then
				local _, hitPoint = Roblox.penetrateCast(self.weaponsSystem.aimRayCallback(), self.ignoreList)
				self.aimPoint = hitPoint
			else
				self.aimPoint = gunHitPoint
			end

			if not aimTrack.IsPlaying and not self.reloading then
				aimTrack:Play(0.15)
				coroutine.wrap(function() -- prevent player from firing until gun is fully out
					wait(self:getConfigValue("StartupTime", 0.2))
					self.startupFinished = true
				end)()
			end

			if aimZoomTrack and not self.reloading then
				if not aimZoomTrack.IsPlaying then
					aimZoomTrack:Play(0.15)
				end
				aimZoomTrack:AdjustSpeed(0.001)
				if self.weaponsSystem.camera:isZoomed() then
					if aimTrack.WeightTarget ~= 0 then
						aimZoomTrack:AdjustWeight(1)
						aimTrack:AdjustWeight(0)
					end
				elseif aimTrack.WeightTarget ~= 1 then
					aimZoomTrack:AdjustWeight(0)
					aimTrack:AdjustWeight(1)
				end
			end

			local MIN_ANGLE = -80
			local MAX_ANGLE = 80
			local aimYAngle = math.deg(self.recoilIntensity)
			if self.weaponsSystem.camera.enabled then
				-- Gets pitch and recoil from camera to figure out how high/low to aim the gun
				aimYAngle = math.deg(self.weaponsSystem.camera:getRelativePitch() + self.weaponsSystem.camera.currentRecoil.Y + self.recoilIntensity)
			end
			local aimTimePos = 2 * ((aimYAngle - MIN_ANGLE) / (MAX_ANGLE - MIN_ANGLE))

			aimTrack:AdjustSpeed(0.001)
			aimTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)

			if aimZoomTrack then
				aimZoomTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)
			end

			-- Update recoil (decay over time)
			local recoilDecay = self:getConfigValue("RecoilDecay", 0.825)
			self.recoilIntensity = math.clamp(self.recoilIntensity * recoilDecay, 0, math.huge)
		else
			warn("no aimTrack")
		end
	end
end

function BulletWeapon:setChargingParticles(charge)
	local ratePerCharge = self:getConfigValue("ChargingParticlesRatePerCharge", 20)
	local rate = ratePerCharge * charge
	for _, v in pairs(self.chargingParticles) do
		v.Rate = rate
	end
end

function BulletWeapon:onStepped(dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	BaseWeapon.onStepped(self, dt)

	local now = tick()

	local chargingSound = self:getSound("Charging")
	local dischargingSound = self:getSound("Discharging")

	if self.usesCharging then
		-- Update charge amount
		local chargeBefore = self.charge
		self:handleCharging(dt)
		local chargeDelta = self.charge - chargeBefore

		-- Update charge particles
		if chargeDelta > 0 then
			self:setChargingParticles(self.charge)
		else
			self:setChargingParticles(0)
		end

		-- Play charging sounds
		if chargingSound then
			if chargingSound.Looped then
				if chargeDelta < 0 then
					chargingSound:Stop()
				else
					if not chargingSound.Playing and self.charge < 1 and chargeDelta > 0 then
						chargingSound:Play()
					end
					chargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta > 0 and self.charge <= 1 and not chargingSound.Playing then
					chargingSound.TimePosition = chargingSound.TimeLength * self.charge
					chargingSound:Play()
				elseif chargeDelta <= 0 and chargingSound.Playing then
					chargingSound:Stop()
				end
			end
		end
		if dischargingSound then
			if dischargingSound.Looped then
				if chargeDelta > 0 then
					dischargingSound:Stop()
				else
					if not dischargingSound.Playing and self.charge > 0 then
						dischargingSound:Play()
					end
					dischargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta < 0 and self.charge >= 0 and not dischargingSound.Playing then
					dischargingSound.TimePosition = dischargingSound.TimeLength * self.charge
					dischargingSound:Play()
				elseif chargeDelta >= 0 and dischargingSound.Playing then
					dischargingSound:Stop()
				end
			end
		end

		-- Play charge/discharge completed sounds and particle effects
		if chargeBefore < 1 and self.charge >= 1 then
			local chargeCompleteSound = self:getSound("ChargeComplete")
			if chargeCompleteSound then
				chargeCompleteSound:Play()
			end
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if self.chargeCompleteParticles then
				self.chargeCompleteParticles:Emit(self:getConfigValue("NumChargeCompleteParticles", 25))
			end
		end
		if chargeBefore > 0 and self.charge <= 0 then
			local dischargeCompleteSound = self:getSound("DischargeComplete")
			if dischargeCompleteSound then
				dischargeCompleteSound:Play()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
			if self.dischargeCompleteParticles then
				self.dischargeCompleteParticles:Emit(self:getConfigValue("NumDischargeCompleteParticles", 25))
			end
		end

		self:renderCharge()
	else
		if chargingSound then
			chargingSound:Stop()
		end
		if dischargingSound then
			dischargingSound:Stop()
		end
	end

	if self.usesCharging and self.chargeGlowPart then
		self.chargeGlowPart.Transparency = 1 - self.charge
	end

	-- Fire weapon if it is fully charged
	if self:canFire() and now > self.nextFireTime then
		self:doLocalFire()
	end
end

function BulletWeapon:handleCharging(dt)
	local chargeDelta
	local shouldCharge = self.activated or self.burstFiring or self:getConfigValue("ChargePassively", false)
	if self.reloading or self.triggerDisconnected then
		shouldCharge = false
	end

	if shouldCharge then
		chargeDelta = self:getConfigValue("ChargeRate", 0) * dt
	else
		chargeDelta = self:getConfigValue("DischargeRate", 0) * -dt
	end

	self.charge = math.clamp(self.charge + chargeDelta, 0, 1)
end

function BulletWeapon:isCharged()
	return not self.usesCharging or self.charge >= 1
end

function BulletWeapon:canFire()
	return self.player == Players.LocalPlayer and (self.burstFiring or self.activated) and not self.triggerDisconnected and not self.reloading and self:isCharged() and self.startupFinished
end

function BulletWeapon:doLocalFire()
	if self.tipAttach then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local aimDir = (self.aimPoint - tipPos).Unit

		self:fire(tipPos, aimDir, self.charge)
	end
end

return BulletWeapon

end))
Script455.Name = "ServerWeaponsScript"
Script455.Parent = Folder341
table.insert(cors,sandbox(Script455,function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local curWeaponsSystemFolder = script.Parent
local weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
local weaponsSystemInitialized = false

local function initializeWeaponsSystemAssets()
	if not weaponsSystemInitialized then
		-- Enable/make visible all necessary assets
		local effectsFolder = weaponsSystemFolder.Assets.Effects
		local partNonZeroTransparencyValues = {
			["BulletHole"] = 1, ["Explosion"] = 1, ["Pellet"] = 1, ["Scorch"] = 1,
			["Bullet"] = 1, ["Plasma"] = 1, ["Railgun"] = 1,
		}
		local decalNonZeroTransparencyValues = { ["ScorchMark"] = 0.25 }
		local particleEmittersToDisable = { ["Smoke"] = true }
		local imageLabelNonZeroTransparencyValues = { ["Impact"] = 0.25 }
		for _, descendant in pairs(effectsFolder:GetDescendants()) do
			if descendant:IsA("BasePart") then
				if partNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = partNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("Decal") then
				descendant.Transparency = 0
				if decalNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = decalNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("ParticleEmitter") then
				descendant.Enabled = true
				if particleEmittersToDisable[descendant.Name] ~= nil then
					descendant.Enabled = false
				else
					descendant.Enabled = true
				end
			elseif descendant:IsA("ImageLabel") then
				if imageLabelNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.ImageTransparency = imageLabelNonZeroTransparencyValues[descendant.Name]
				else
					descendant.ImageTransparency = 0
				end
			end
		end
		
		weaponsSystemInitialized = true
	end
end

if weaponsSystemFolder == nil then
	weaponsSystemFolder = curWeaponsSystemFolder:Clone()
	initializeWeaponsSystemAssets()
	weaponsSystemFolder.Parent = ReplicatedStorage
end

if ServerScriptService:FindFirstChild("ServerWeaponsScript") == nil then
	script.Parent = ServerScriptService
	initializeWeaponsSystemAssets()

	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
	
	local function setupClientWeaponsScript(player)
		local clientWeaponsScript = player.PlayerGui:FindFirstChild("ClientWeaponsScript")
		if clientWeaponsScript == nil then
			clientWeaponsScript = weaponsSystemFolder.ClientWeaponsScript:Clone()
			clientWeaponsScript.Parent = player.PlayerGui
		end
	end
	
	Players.PlayerAdded:Connect(function(player)
		setupClientWeaponsScript(player)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		setupClientWeaponsScript(player)
	end
end

if curWeaponsSystemFolder.Name == "WeaponsSystem" then
	curWeaponsSystemFolder:Destroy()
end
end))
Folder456.Name = "Configuration"
Folder456.Parent = Folder341
BoolValue457.Name = "SprintEnabled"
BoolValue457.Parent = Folder456
BoolValue457.Value = true
BoolValue458.Name = "SlowZoomWalkEnabled"
BoolValue458.Parent = Folder456
BoolValue458.Value = true
Folder459.Name = "Libraries"
Folder459.Parent = Folder341
ModuleScript460.Name = "DamageBillboardHandler"
ModuleScript460.Parent = Folder459
table.insert(cors,sandbox(ModuleScript460,function()
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

if RunService:IsServer() then return {} end

local localPlayer = Players.LocalPlayer
while not localPlayer do
	Players.PlayerAdded:Wait()
	localPlayer = Players.LocalPlayer
end

local adorneeToBillboardGui = {}

local DamageBillboardHandler = {}

function DamageBillboardHandler:CreateBillboardForAdornee(adornee)
	local billboard = adorneeToBillboardGui[adornee]
	if billboard then
		return billboard
	end

	billboard = Instance.new("BillboardGui")
	billboard.Name = "DamageBillboardGui"
	billboard.Adornee = adornee
	billboard.AlwaysOnTop = true
	billboard.ExtentsOffsetWorldSpace = Vector3.new(0,18,0)
	billboard.Size = UDim2.new(0.42,20,15,0)
	billboard.ResetOnSpawn = false
	billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	billboard.Parent = localPlayer.PlayerGui
	adorneeToBillboardGui[adornee] = billboard

	local ancestorCon
	ancestorCon = adornee.AncestryChanged:connect(function(child, parent)
		if parent == nil then
			ancestorCon:disconnect()
			ancestorCon = nil

			local adorneeBillboard = adorneeToBillboardGui[adornee]
			adorneeBillboard:Destroy()
			adorneeToBillboardGui[adornee] = nil
		end
	end)

	return billboard
end

function DamageBillboardHandler:ShowDamageBillboard(damageAmount, adornee)
	damageAmount = math.ceil(damageAmount)

	local billboard = self:CreateBillboardForAdornee(adornee)

	local randomXPos = math.random(-10,10)/30

	local damageNumber = Instance.new("TextLabel")
	damageNumber.AnchorPoint = Vector2.new(0.5, 1)
	damageNumber.BackgroundTransparency = 1
	damageNumber.BorderSizePixel = 0
	damageNumber.Position = UDim2.fromScale(0.5 + randomXPos,1)
	damageNumber.Size = UDim2.fromScale(0,0.25)
	damageNumber.Font = Enum.Font.GothamBlack
	damageNumber.Text = tostring(damageAmount)
	damageNumber.TextColor3 = Color3.new(0.7,0.7,0.7)
	damageNumber.TextScaled = true
	damageNumber.TextStrokeTransparency = 0
	damageNumber.TextTransparency = 0
	damageNumber.TextXAlignment = Enum.TextXAlignment.Center
	damageNumber.TextYAlignment = Enum.TextYAlignment.Bottom
	damageNumber.Parent = billboard

	local appearTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Elastic,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0) --delayTime
	local appearTween = TweenService:Create(
		damageNumber,
		appearTweenInfo, {
			Size = UDim2.fromScale(1, damageNumber.Size.Y.Scale),
			TextColor3 = Color3.new(1,1,1)
		}
	)

	local upTweenInfo = TweenInfo.new(
		0.5, --time
		Enum.EasingStyle.Linear,
		Enum.EasingDirection.Out,
		0, --repeatCount
		false, --reverses
		0.2) --delayTime
	local upTween = TweenService:Create(
		damageNumber,
		upTweenInfo, {
			Position = UDim2.fromScale(damageNumber.Position.X.Scale, 0.25),
			TextTransparency = 1,
			TextStrokeTransparency = 4,
			Rotation = math.random(-5,5)
		}
	)

	local completedCon
	completedCon = upTween.Completed:connect(function()
		completedCon:disconnect()
		completedCon = nil
		damageNumber:Destroy()
	end)

	appearTween:Play()
	upTween:Play()
end

return DamageBillboardHandler
end))
ModuleScript461.Name = "DirectionalIndicatorGuiManager"
ModuleScript461.Parent = Folder459
table.insert(cors,sandbox(ModuleScript461,function()
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local DirectionalIndicatorGuiManager = {}
DirectionalIndicatorGuiManager.__index = DirectionalIndicatorGuiManager

local function GetConfigValue(config, propertyName, default)
	if config then
		local property = config:FindFirstChild(propertyName)
		if property then
			return property.Value
		end
	end
	return default
end

function DirectionalIndicatorGuiManager.new(weaponsGui)
	local self = setmetatable({}, DirectionalIndicatorGuiManager)
	self.weaponsGui = weaponsGui
	self.connections = {}
	self.enabled = false

	-- Note DI is an abbreviation for DirectionalIndicator
	self.DIFolder = self.weaponsGui.scalingElementsFolder:WaitForChild("DirectionalIndicators")
	self.DIInfo = {}

	for _, DIFrame in ipairs(self.DIFolder:GetChildren()) do
		if DIFrame:IsA("Frame") and DIFrame:FindFirstChildOfClass("ImageLabel") then
			local config = DIFrame:FindFirstChildOfClass("Configuration")
			local name = GetConfigValue(config, "Name", DIFrame.Name)
			self.DIInfo[name] = self:GetDIInfoFromFrame(DIFrame)

			DIFrame.Visible = true
			self.DIInfo[name].image.ImageTransparency = 1
		end
	end

	return self
end

function DirectionalIndicatorGuiManager:GetDIInfoFromFrame(frame)
	local diInfo = {}
	diInfo.frame = frame
	diInfo.image = frame:FindFirstChildOfClass("ImageLabel")
	diInfo.config = frame:FindFirstChildOfClass("Configuration")
	diInfo.active = false
	diInfo.dieOnFade = false -- will only be true for copies of original DIs
	return diInfo
end

function DirectionalIndicatorGuiManager:ActivateDirectionalIndicator(DIName, otherPosition)
	-- Use original DI, or make a copy if it's already active
	local diInfo = self.DIInfo[DIName]
	if not diInfo then
		warn("Warning: invalid name given to ActivateDirectionalIndicator")
		return
	end

	if diInfo.active then
		local newFrame = diInfo.frame:Clone()
		newFrame.Parent = diInfo.frame.Parent
		diInfo = self:GetDIInfoFromFrame(newFrame)
		diInfo.dieOnFade = true
	end
	diInfo.active = true

	-- Update distance from center
	local distanceLevel = GetConfigValue(diInfo.config, "DistanceLevelFromCenter", 6)
	local widthLevel = GetConfigValue(diInfo.config, "WidthLevel", distanceLevel)
	local levelMultiplier = 0.03
	self.weaponsGui.originalScaleAmounts[diInfo.frame] = Vector2.new(widthLevel * levelMultiplier, distanceLevel * levelMultiplier * 2)
	self.weaponsGui:updateScale(diInfo.frame, workspace.CurrentCamera.ViewportSize)

	-- Set initial indicator rotation and transparency
	diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
	diInfo.image.ImageTransparency = GetConfigValue(diInfo.config, "TransparencyBeforeFade", 0)

	-- Update rotation of indicator as player rotates
	coroutine.wrap(function()
		while diInfo.image.ImageTransparency < 1 do
			diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
			RunService.RenderStepped:Wait()
		end

		diInfo.active = false
		if diInfo.dieOnFade then
			diInfo.frame:Destroy()
			diInfo = nil
		end
	end)()

	-- Show indicator for a bit, then fade out
	coroutine.wrap(function()
		wait(GetConfigValue(diInfo.config, "TimeBeforeFade", 1))
		local tweenInfo = TweenInfo.new(GetConfigValue(diInfo.config, "FadeTime", 1))
		local goal = {}
		goal.ImageTransparency = 1
		local tween = TweenService:Create(diInfo.image, tweenInfo, goal)
		tween:Play()
	end)()
end

function DirectionalIndicatorGuiManager:CalculateDIRotation(otherPosition)
	local camera = self.weaponsGui.weaponsSystem.camera
	local localPlayerOffsetPositionXZ = Vector3.new(camera.currentCamera.Focus.X, 0, camera.currentCamera.Focus.Z)
	local otherPlayerPositionXZ = Vector3.new(otherPosition.X, 0, otherPosition.Z)
	local toOtherPlayer = (localPlayerOffsetPositionXZ - otherPlayerPositionXZ).Unit
	local forward = (Vector3.new(camera.currentCFrame.LookVector.X, 0, camera.currentCFrame.LookVector.Z)).Unit
	if toOtherPlayer == Vector3.new() then
		toOtherPlayer = forward
	end
	local dotProduct = forward:Dot(toOtherPlayer)
	local crossProduct = forward:Cross(toOtherPlayer)
	local acosAngle = math.deg(math.acos(dotProduct))
	local asinAngle = math.deg(math.asin(crossProduct.Y))
	if asinAngle >= 0 then
		acosAngle = 360 - acosAngle
	end
	return acosAngle
end

return DirectionalIndicatorGuiManager
end))
ModuleScript462.Name = "Parabola"
ModuleScript462.Parent = Folder459
table.insert(cors,sandbox(ModuleScript462,function()
local RunService = game:GetService("RunService")

local MIN_HORZ_SPEED = 0.01 --The minimum X and Z velocity for a physical-launch parabola to be considered vertical, helps avoid numerical instability
local DEFAULT_NUM_SAMPLES = RunService:IsServer() and 32 or 32
local DEFAULT_NORMAL = Vector3.new(0, 1, 0)
local ROT_OFFSET = {
	[0] = CFrame.Angles(0, math.rad(90), 0) * CFrame.Angles(math.rad(90), 0, 0),
	[1] = CFrame.Angles(0, math.rad(-90), 0) * CFrame.Angles(math.rad(90), 0, 0)
}
local UP_VECTOR = Vector3.new(0, 1, 0)
local ONE_THIRD, TWO_THIRDS = 1/3, 2/3

local Parabola = {}
Parabola.__index = Parabola

function Parabola.new(a, b, c, x0, x1)
	local self = setmetatable({}, Parabola)

	self.referenceFrame = CFrame.new()

	self.a = a or 1
	self.b = b or 1
	self.c = c or 0

	self.x0 = x0 or 0
	self.x1 = x1 or 10

	self.velocity = Vector2.new()
	self.gravity = 0

	self.numSamples = DEFAULT_NUM_SAMPLES

	return self
end

function Parabola:setPhysicsLaunch(startPoint, velocity, endpointY, gravity)
	gravity = gravity or -workspace.Gravity

	local flatVelocity = velocity * Vector3.new(1, 0, 1)
	if flatVelocity.Magnitude > MIN_HORZ_SPEED then
		self.referenceFrame = CFrame.new(startPoint, startPoint + flatVelocity)
	else
		self.referenceFrame = CFrame.new(startPoint)
	end
	local relativeVelocity = self.referenceFrame:vectorToObjectSpace(velocity)
	local xVelocity, yVelocity = math.max(MIN_HORZ_SPEED, -relativeVelocity.Z), relativeVelocity.Y
	self.a = (0.5 * gravity) * (1 / (xVelocity ^ 2))
	self.b = yVelocity / xVelocity
	self.c = 0

	self.velocity = Vector2.new(xVelocity, yVelocity)
	self.gravity = gravity

	if math.abs(gravity) > 1e-3 then
		self.x0 = 0

		if endpointY and startPoint.Y - endpointY > 0 then
			--y = ax^2 + bx + c
			--0 = ax^2 + bx - y
			--x = (-b +- sqrt(b^2 - 4ac)) / 2a

			local a, b, c = self.a, self.b, startPoint.Y - endpointY
			local det = math.sqrt(b^2 - 4 * a * c)
			local s1, s2 = (-b + det) / (2 * a), (-b - det) / (2 * a)

			self.x1 = math.max(s1, s2)
		else
			self.x1 = math.abs(2 * xVelocity * yVelocity) / math.abs(gravity)
		end
	else
		self.x0 = 0
		self.x1 = 100
	end
end

function Parabola:setNumSamples(numSamples)
	self.numSamples = numSamples
end

function Parabola:setDomain(x0, x1)
	self.x0 = x0
	self.x1 = x1
end

function Parabola:samplePoint(t)
	local a, b, c = self.a, self.b, self.c
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (a * x * x) + (b * x) + c
	return self.referenceFrame:pointToWorldSpace(Vector3.new(0, y, -x))
end

function Parabola:sampleSlope(t)
	local a, b = self.a, self.b
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (2 * a * x) + b
	return y
end

function Parabola:sampleVelocity(t)
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local xVelocity = self.velocity.X
	local xT = x / xVelocity
	local yVelocity = self.velocity.Y + (self.gravity * xT)
	return self.referenceFrame:vectorToWorldSpace(Vector3.new(0, yVelocity, -xVelocity))
end

function Parabola:_penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, UP_VECTOR, Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Parabola:_findPart(funcName, list)
	list = list or {}

	local numSamples = self.numSamples
	local hitPart, hitPoint, hitNormal, hitMaterial, hitT = nil, self.referenceFrame.p, DEFAULT_NORMAL, Enum.Material.Air, 0

	local func = funcName ~= "penetrateCast" and workspace[funcName] or Parabola._penetrateCast

	for i = 1, numSamples do
		local t0 = (i - 1) / numSamples
		local t1 = i / numSamples

		local p0 = self:samplePoint(t0)
		local p1 = self:samplePoint(t1)
		local ray = Ray.new(p0, p1 - p0)

		hitPart, hitPoint, hitNormal, hitMaterial = func(workspace, ray, list)
		if hitPart then
			local hitX = -self.referenceFrame:pointToObjectSpace(hitPoint).Z

			hitT = ((hitX - self.x0) / (self.x1 - self.x0))
			break
		end
	end
	if not hitPart then
		hitT = 1
	end
	return hitPart, hitPoint, hitNormal, hitMaterial, hitT
end

function Parabola:findPart(ignoreList)
	return self:_findPart("penetrateCast", ignoreList)
end
function Parabola:findPartWithWhitelist(whitelist)
	return self:_findPart("FindPartOnRayWithWhitelist", whitelist)
end

function Parabola:findSpheresHit(sphereTable, radius)

end

function Parabola:_setBeamControlPoint(beam, attachment, idx, pos, refFrame)
	local attachmentPos = attachment.WorldPosition
	local vecFromAttachment = pos - attachmentPos
	local curveSize = vecFromAttachment.Magnitude

	attachment.CFrame = refFrame:toObjectSpace(CFrame.new(attachmentPos, pos) * ROT_OFFSET[idx])
	if idx == 0 then
		beam.CurveSize0 = curveSize
	else
		beam.CurveSize1 = curveSize
	end
end

function Parabola:renderToBeam(beam)
	local att0, att1 = beam.Attachment0, beam.Attachment1
	--assert(att0 and att1 and att0.Parent and att0.Parent:IsA("BasePart") and att1.Parent and att1.Parent:IsA("BasePart"), "Beam must have valid attachments that are in a BasePart")

	if not att0.Parent or not att1.Parent then
		return
	end

	local root0, root1 = att0.Parent.CFrame, att1.Parent.CFrame

	local referenceFrame = self.referenceFrame

	local x0, x1 = self.x0, self.x1
	local domain = x1 - x0
	local halfDomain = domain * 0.5
	local p0 = self:samplePoint(0)
	local p1 = self:samplePoint(1)
	local a, b, c = self.a, self.b, self.c
	local x = x0 + (0 * (x1 - x0))
	local cY = ((a * x * x) + (b * x) + c) + self:sampleSlope(0) * halfDomain
	c = referenceFrame:pointToWorldSpace(Vector3.new(0, cY, -(x0 + x1) / 2))
	local c0 = TWO_THIRDS * c + ONE_THIRD * p0
	local c1 = TWO_THIRDS * c + ONE_THIRD * p1

	att0.Position = root0:pointToObjectSpace(p0)
	att1.Position = root1:pointToObjectSpace(p1)

	self:_setBeamControlPoint(beam, att0, 0, c0, root0)
	self:_setBeamControlPoint(beam, att1, 1, c1, root1)
end

return Parabola

end))
ModuleScript463.Name = "Ragdoll"
ModuleScript463.Parent = Folder459
table.insert(cors,sandbox(ModuleScript463,function()
local RunService = game:GetService("RunService")

local JOINT_INFO = {
	LeftShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(45))
	},
	LeftElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	LeftWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},
	RightShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(-45))
	},
	RightElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	RightWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},

	Waist = {
		Limits = { Lower = -45, Upper = 30 }
	},
	Neck = {
		Limits = { Cone = 20, Twist = 20 }
	},

	LeftHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(35)),
	},
	LeftKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	LeftAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	},
	RightHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(-35))
	},
	RightKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	RightAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	}
}

local GROUPS = {
	UpperBody = {
		"Waist",
		"Neck",
		"LeftShoulder",
		"RightShoulder",
		"LeftElbow",
		"RightElbow",
		"LeftWrist",
		"RightWrist"
	},
	LowerBody = {
		"LeftHip",
		"RightHip",
		"LeftKnee",
		"RightKnee",
		"LeftAnkle",
		"RightAnkle"
	},
	LeftArm = {
		"LeftShoulder",
		"LeftElbow",
		"LeftWrist",
	},
	RightArm = {
		"RightShoulder",
		"RightElbow",
		"RightWrist"
	},
	LeftLeg = {
		"LeftHip",
		"LeftKnee",
		"LeftAnkle"
	},
	RightLeg = {
		"RightHip",
		"RightKnee",
		"RightAnkle"
	},
}

local Ragdoll = {}
Ragdoll.__index = Ragdoll

function Ragdoll.new(character)
	local self = setmetatable({}, Ragdoll)
	self.character = character
	self.humanoid = character:WaitForChild("Humanoid")

	self.joints = {}
	for jointName, info in pairs(JOINT_INFO) do
		self.joints[jointName] = self:setupJoint(jointName, info)
	end

	return self
end

function Ragdoll:setupJoint(jointName, info)
	if self.joints[jointName] then
		return self.joints[jointName]
	end

	local constraintName = jointName .. "Constraint"
	local rigAttachmentName = jointName .. "RigAttachment"
	local existingConstraint = self.character:FindFirstChild(constraintName, true)
	local existingMotor = self.character:FindFirstChild(jointName, true)
	if not existingMotor then
		return nil
	end

	if existingConstraint or RunService:IsClient() then
		existingConstraint = self.character:WaitForChild(constraintName)
		return {
			constraint = existingConstraint,
			motor = existingMotor,
			ragdolled = existingMotor.Part1 ~= nil
		}
	else
		local constraintType = "HingeConstraint"
		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraintType = "BallSocketConstraint"
		end

		local constraint = Instance.new(constraintType)
		constraint.Name = constraintName
		constraint.Enabled = false
		constraint.Attachment0 = existingMotor.Part0:FindFirstChild(rigAttachmentName)
		constraint.Attachment1 = existingMotor.Part1:FindFirstChild(rigAttachmentName)
		constraint.LimitsEnabled = info.Limits ~= nil

		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraint.UpperAngle = info.Limits.Cone
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = -info.Limits.Twist
			constraint.TwistUpperAngle = info.Limits.Twist
		elseif info.Limits and info.Limits.Lower and info.Limits.Upper then
			constraint.LowerAngle = info.Limits.Lower
			constraint.UpperAngle = info.Limits.Upper
		end

		constraint.Parent = existingMotor.Parent

		return {
			constraint = constraint,
			motor = existingMotor,
			ragdolled = false
		}
	end
end

function Ragdoll:setJointRagdolled(jointName, ragdolled)
	local joint = self.joints[jointName]
	if not joint then return end

	joint.constraint.Enabled = ragdolled
	if joint.motor and joint.motor:IsA("Motor6D") then
		if ragdolled then
			joint.motor.Part1 = nil
		else
			joint.motor.Part1 = joint.motor.Parent
		end
	end
end

function Ragdoll:setGroupRagdolled(groupName, ragdolled)
	local groupJoints = GROUPS[groupName]
	assert(groupJoints, string.format("%s is not a valid ragdoll group", tostring(groupName)))

	for _, jointName in pairs(groupJoints) do
		self:setJointRagdolled(jointName, ragdolled)
	end
end

function Ragdoll:setRagdolled(ragdolled, whitelist)
	for jointName in pairs(self.joints) do
		if not whitelist or whitelist[jointName] then
			self:setJointRagdolled(jointName, ragdolled)
		end
	end
end

function Ragdoll:destroy()
	self:setRagdolled(false)
	for _, joint in pairs(self.joints) do
		if joint.constraint then
			joint.constraint:Destroy()
		end
	end
	self.joints = {}
end

return Ragdoll

end))
ModuleScript464.Name = "Roblox"
ModuleScript464.Parent = Folder459
table.insert(cors,sandbox(ModuleScript464,function()
local TweenService 		= game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local RunService 		= game:GetService("RunService")
local UserInputService	= game:GetService("UserInputService")

local Roblox = {}

Roblox.Random = Random.new()
Roblox.zeroVector2 = Vector2.new()
Roblox.zeroVector3 = Vector3.new()
Roblox.identityCFrame = CFrame.new()
Roblox.upVector2 = Vector2.new(0, 1)
Roblox.upVector3 = Vector3.new(0, 1, 0)

local guidCharsText = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+./"
local guidChars = {}
for i = 1, #guidCharsText do
	guidChars[i] = guidCharsText:sub(i, i)
end
local guidRandom = Random.new()

function Roblox.newGuid()
	local guid = ""
	for _ = 1, 10 do
		local char = guidRandom:NextInteger(1,#guidChars)
		guid = guid .. guidChars[char]
	end
	return guid
end

function Roblox.isPlaySolo()
	return RunService:IsClient() and RunService:IsServer() and RunService:IsStudio()
end

function Roblox.waitForDescendant(instance, descendantName, timeout)
	timeout = timeout or 60
	local found = instance:FindFirstChild(descendantName, true)
	if found then
		return found
	end

	if timeout < 1e6 and timeout > 0 then
		coroutine.wrap(function()
			wait(timeout)
			if not found then
				warn("Roblox.waitForDescendant(%s, %s) is taking too long")
			end
		end)()
	end

	while not found do
		local newDescendant = instance.DescendantAdded:Wait()
		if newDescendant.Name == descendantName then
			found = newDescendant
			return newDescendant
		end
	end
end

function Roblox.create(className)
	return function(props)
		local instance = Instance.new(className)
		for key, val in pairs(props) do
			if key ~= "Parent" then
				instance[key] = val
			end
		end
		instance.Parent = props.Parent
		return instance
	end
end

function Roblox.weldModel(model)
	local rootPart = model.PrimaryPart
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and part ~= rootPart then
			local weld = Instance.new("WeldConstraint")
			weld.Part0 = rootPart
			weld.Part1 = part
			weld.Parent = part
		end
	end
end

function Roblox.setNetworkOwner(model, owner)
	if not model then warn("Cannot setNetworkOwner on nil model") return end
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and not part.Anchored then
			part:SetNetworkOwner(owner)
		end
	end
end

function Roblox.createMotor6D(root, child)
	local motor = Instance.new("Motor6D")
	motor.Part0 = root
	motor.Part1 = child

	motor.C0 = root.CFrame:toObjectSpace(child.CFrame)
	motor.C1 = CFrame.new()

	motor.Parent = root
	return motor
end

function Roblox.getTotalMass(part)
	local allConnected = part:GetConnectedParts(true)
	local total = 0
	for _, v in pairs(allConnected) do
		total = total + v:GetMass()
	end
	return total
end

function Roblox.waitForTween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
	tween.Completed:wait()
end

function Roblox.tween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
end

function Roblox.fadeAway(gui, duration, level)
	duration = duration or 0.5
	level = level or 0

	local tweenInfo = TweenInfo.new(duration)
	local tweenProps = { BackgroundTransparency = 1 }

	if gui:IsA("TextButton") or gui:IsA("TextLabel") or gui:IsA("TextBox") then
		tweenProps.TextTransparency = 1
		tweenProps.TextStrokeTransparency = 1
	elseif gui:IsA("ImageLabel") or gui:IsA("ImageButton") then
		tweenProps.ImageTransparency = 1
	else
		return
	end

	for _, v in pairs(gui:GetChildren()) do
		Roblox.fadeAway(v, duration, level + 1)
	end


	if level == 0 then
		coroutine.wrap(function()
			Roblox.waitForTween(gui, tweenInfo, tweenProps)
			gui:Destroy()
		end)()
	else
		Roblox.tween(gui, tweenInfo, tweenProps)
	end
end

function Roblox.setModelAnchored(model, anchored)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = anchored
		end
	end
end

function Roblox.setModelLocalVisible(model, visible)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.LocalTransparencyModifier = visible and 0 or 1
		elseif part:IsA("SurfaceGui") then
			part.Enabled = visible
		elseif part:IsA("Decal") then
			part.Transparency = visible and 0 or 1
		end
	end
end

function Roblox.forAllTagged(tagName, enterFunc, exitFunc)
	for _, obj in pairs(CollectionService:GetTagged(tagName)) do
		if enterFunc then
			enterFunc(obj, tagName)
		end
	end
	if enterFunc then
		CollectionService:GetInstanceAddedSignal(tagName):Connect(function(obj) enterFunc(obj, tagName) end)
	end
	if exitFunc then
		CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(obj) exitFunc(obj, tagName) end)
	end
end

function Roblox.getHumanoidFromCharacterPart(part)
	local currentNode = part
	while currentNode do
		local humanoid = currentNode:FindFirstChildOfClass("Humanoid")
		if humanoid then return humanoid end
		currentNode = currentNode.Parent
	end
	return nil
end

local addEsEndings = {
	s = true,
	sh = true,
	ch = true,
	x = true,
	z = true
}
local vowels = {
	a = true,
	e = true,
	i = true,
	o = true,
	u = true
}
function Roblox.formatPlural(num, name, wordOnly)
	if num ~= 1 then
		local lastTwo = name:sub(-2):lower()
		local lastOne = name:sub(-1):lower()

		local suffix = "s"
		if addEsEndings[lastTwo] or addEsEndings[lastOne] then
			suffix = "es"
		elseif lastOne == "o" and #lastTwo == 2 then
			local secondToLast = lastTwo:sub(1, 1)
			if not vowels[secondToLast] then
				suffix = "es"
			end
		end
		name = name .. suffix
	end
	if not wordOnly then
		return ("%s %s"):format(Roblox.formatInteger(num), name)
	else
		return name
	end
end

function Roblox.formatNumberTight(number)
	local order = math.log10(number)
	if order >= 3 and order < 6 then
		return ("%.1fK"):format(number / (10^3))
	end
	if order >= 6 and order < 9 then
		return ("%.1fM"):format(number / (10^6))
	end
	if order >= 9 then
		return ("%.1fB"):format(number / (10^9))
	end

	return tostring(math.floor(number + 0.5))
end

function Roblox.formatInteger(amount)
	amount = math.floor(amount + 0.5)
	local formatted = amount
	local numMatches
	repeat
		formatted, numMatches = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
	until numMatches == 0
	return formatted
end

function Roblox.round(val, decimal)
	if decimal then
		return math.floor((val * 10 ^ decimal) + 0.5) / (10 ^ decimal)
	else
		return math.floor(val + 0.5)
	end
end

function Roblox.formatNumber(number)
	local result, integral, fractional

	integral, fractional = math.modf(number)
	result = Roblox.formatInteger(integral)

	if fractional ~= 0 then
		result = result .. "." .. string.sub(tostring(math.abs(fractional)),3)
	end
	if number < 0 then
		result = "-" .. result
	end

	return result
end

function Roblox.isPointInsidePart(point, part)
	local localPos = part.CFrame:pointToObjectSpace(point)
	return math.abs(localPos.X) <= part.Size.X * 0.5 and math.abs(localPos.Y) <= part.Size.Y * 0.5 and math.abs(localPos.Z) <= part.Size.Z * 0.5
end

function Roblox.rayPlaneIntersect(ray, pointOnPlane, planeNormal)
	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function Roblox.debugPrint(t, level)
	level = level or 0
	local tabs = string.rep("\t", level)
	if typeof(t) == "table" then
		for key, val in pairs(t) do
			print(tabs, key, "=", val)
			if typeof(val) == "table" then
				Roblox.debugPrint(val, level + 1)
			end
		end
	end
end

local function findInstanceImpl(root, path, getChildFunc)
	local currentInstance = root

	while true do
		local nextChildName
		local nextSeparator = path:find("%.")
		if not nextSeparator then
			nextChildName = path
		else
			nextChildName = path:sub(1, nextSeparator - 1)
			path = path:sub(nextSeparator + 1)
		end

		local child = getChildFunc(currentInstance, nextChildName)
		if child then
			currentInstance = child
		else
			return nil
		end
	end
end

local function findFirstChildImpl(parent, childName)
	return parent:FindFirstChild(childName)
end
local function waitForChildImpl(parent, childName)
	return parent:WaitForChild(childName)
end

function Roblox.findInstance(root, path)
	return findInstanceImpl(root, path, findFirstChildImpl)
end

function Roblox.waitForInstance(root, path)
	return findInstanceImpl(root, path, waitForChildImpl)
end

function Roblox.penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and (not hitPart.CanCollide or CollectionService:HasTag(hitPart, "DroppedItemPart") or CollectionService:HasTag(hitPart, "Hidden")) and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Roblox.posInGuiObject(pos, guiObject)
	local guiMin = guiObject.AbsolutePosition
	local guiMax = guiMin + guiObject.AbsoluteSize
	return pos.X >= guiMin.X and pos.X <= guiMax.X and pos.Y >= guiMin.Y and pos.Y <= guiMax.Y
end

function Roblox.getUTCTime()
	local dateInfo = os.date("!*t")
	return string.format("%04d-%02d-%02d %02d:%02d:%02d", dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.min, dateInfo.sec)
end

function Roblox.getUTCTimestamp()
	return os.time(os.date("!*t"))
end

local DURATION_TOKENS = {
	{ "years",   "y",  31536000 },
	{ "months",  "mo", 2592000 },
	{ "weeks",   "w",  604800 },
	{ "days",    "d",  86400 },
	{ "hours",   "h",  3600 },
	{ "minutes", "m",  60 },
	{ "seconds", "s",  1 },
}
function Roblox.parseDurationInSeconds(inputStr)
	local tokensFound = {}
	local totalDurationSeconds = 0
	for _, tokenInfo in pairs(DURATION_TOKENS) do
		local numFound = string.match(inputStr, "(%d+)" .. tokenInfo[2])
		if numFound then
			local num = tonumber(numFound) or 0
			if num > 0 then
				table.insert(tokensFound, string.format("%d %s", num, tokenInfo[1]))
			end
			totalDurationSeconds = totalDurationSeconds + (num * tokenInfo[3])
		end
	end

	local outputStr = table.concat(tokensFound, ", ")
	return totalDurationSeconds, outputStr
end

local random = Random.new()
function Roblox.chooseWeighted(choiceTable)
    local sum = 0
    for _, weight in pairs(choiceTable) do
        sum = sum + weight
    end

    local roll = random:NextNumber(0, 1)
    local choiceSum = 0
    for choiceName, weight in pairs(choiceTable) do
        local chance = weight / sum
        if roll >= choiceSum and roll < choiceSum + chance then
            return choiceName
        else
            choiceSum = choiceSum + chance
        end
    end

    return nil
end

function Roblox.hasMatchingTag(instance, tagPattern)
	for _, tagName in pairs(CollectionService:GetTags(instance)) do
		if tagName:match(tagPattern) ~= nil then
			return true
		end
	end
	return false
end

local highlightTweens = setmetatable({}, { __mode = 'k' })
function Roblox.showHighlight(instance, show)
	local highlightInstance = instance:FindFirstChild("Highlight")
	if not highlightInstance or not highlightInstance:IsA("ImageLabel") then
		return
	end

	local existingTween = highlightTweens[instance]
	if existingTween then
		if show then
			return
		else
			existingTween:Cancel()
			highlightTweens[instance] = nil
			highlightInstance.ImageTransparency = 1
		end
	else
		if not show then
			return
		else
			coroutine.wrap(function()
				highlightInstance.ImageTransparency = 1
				local newTween = TweenService:Create(highlightInstance, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, true), { ImageTransparency = 0 })
				highlightTweens[instance] = newTween
				while highlightTweens[instance] == newTween do
					newTween:Play()
					newTween.Completed:Wait()
				end
			end)()
		end
	end
end

function Roblox.getClickVerb(capitalize)
	local verb = "Click"
	if UserInputService.TouchEnabled then
		verb = "Tap"
	end

	if not capitalize then
		verb = verb:lower()
	end
	return verb
end

function Roblox.computeLaunchAngle(relativePoint, launchVelocity)
	local dx, dy = -relativePoint.Z, relativePoint.Y

	local g = workspace.Gravity
	local invRoot = (launchVelocity ^ 4) - (g * ((g * dx * dx) + (2 * dy * launchVelocity * launchVelocity)))
	if invRoot <= 0 then
		return math.pi / 4
	end

	local root = math.sqrt(invRoot)
	local angle1 = math.atan(((launchVelocity * launchVelocity) + root) / (g * dx))
	local angle2 = math.atan(((launchVelocity * launchVelocity) - root) / (g * dx))

	local chosenAngle = math.min(angle1, angle2)

	return chosenAngle
end

function Roblox.getClosestPointOnLine(line0, line1, point, doClamp)
	local lineVec = line1 - line0
	local pointFromLine0 = point - line0

	local dotProduct = lineVec:Dot(pointFromLine0)
	local t = dotProduct / (lineVec.Magnitude ^ 2)
	if doClamp ~= false then
		t = math.clamp(t, 0, 1)
	end
	local pointOnLine = line0:Lerp(line1, t)
	return pointOnLine, t, (point - pointOnLine).Magnitude
end

function Roblox.getClosestPointOnLines(referencePoint, lines)
	local closestPoint, closestDist, closestLine, closestT = nil, math.huge, nil, 0
	for i = 1, #lines do
		local lineA, lineB = lines[i][1], lines[i][2]

		local point, t, dist = Roblox.getClosestPointOnLine(lineA, lineB, referencePoint)
		if dist < closestDist then
			closestPoint = point
			closestDist = dist
			closestLine = i
			closestT = t
		end
	end

	return closestPoint, closestDist, closestLine, closestT
end

function Roblox.getPointInFrontOnLines(referencePoint, forwardOffset, lines)
	local closestPoint, _, closestLine, closestT = Roblox.getClosestPointOnLines(referencePoint, lines)
	if closestPoint then
		local pointOffset = closestPoint
		local offsetBudget = forwardOffset

		if closestLine == 1 and closestT == 0 then
			local beforeDist = (lines[1][1] - Roblox.getClosestPointOnLine(lines[1][1], lines[1][2], referencePoint, false)).Magnitude
			offsetBudget = offsetBudget - beforeDist
		end

		local lineDir = Vector3.new(0, 0, 0)
		while offsetBudget > 0 and closestLine <= #lines do
			local lineA, lineB = lines[closestLine][1], lines[closestLine][2]
			local lineVec = lineB - lineA
			local lineLength = lineVec.Magnitude
			local pointDistAlongLine = (pointOffset - lineA).Magnitude
			local distLeftOnLine = lineLength - pointDistAlongLine
			lineDir = lineVec.Unit

			if offsetBudget > distLeftOnLine then
				offsetBudget = offsetBudget - distLeftOnLine
				pointOffset = lineB
				closestLine = closestLine + 1
			else
				break
			end
		end
		pointOffset = pointOffset + lineDir * offsetBudget

		return pointOffset
	end
	return closestPoint
end

function Roblox.applySpread(unspreadDir, randomGenerator, minSpread, maxSpread)
	local spreadRotation = randomGenerator:NextNumber(-math.pi, math.pi)
	local spreadOffset = randomGenerator:NextNumber(minSpread, maxSpread)
	local spreadTransform = CFrame.fromAxisAngle(Vector3.new(math.cos(spreadRotation), math.sin(spreadRotation), 0), spreadOffset)
	local unspreadCFrame = CFrame.new(Vector3.new(), unspreadDir)
	return (unspreadCFrame * spreadTransform).LookVector
end

return Roblox

end))
ModuleScript465.Name = "ShoulderCamera"
ModuleScript465.Parent = Folder459
table.insert(cors,sandbox(ModuleScript465,function()
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local UserGameSettings = UserSettings():GetService("UserGameSettings")

local LocalPlayer = Players.LocalPlayer
if RunService:IsClient() then
	while not LocalPlayer do
		Players.PlayerAdded:Wait()
		LocalPlayer = Players.LocalPlayer
	end
end
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

local CAMERA_RENDERSTEP_NAME = "ShoulderCameraUpdate"
local ZOOM_ACTION_NAME = "ShoulderCameraZoom"
local SPRINT_ACTION_NAME = "ShoulderCameraSprint"
local CONTROLLABLE_HUMANOID_STATES = {
	[Enum.HumanoidStateType.Running] = true,
	[Enum.HumanoidStateType.RunningNoPhysics] = true,
	[Enum.HumanoidStateType.Freefall] = true,
	[Enum.HumanoidStateType.Jumping] = true,
	[Enum.HumanoidStateType.Swimming] = false,
	[Enum.HumanoidStateType.Landed] = true
}

-- Gamepad thumbstick utilities
local k = 0.5
local lowerK = 0.9
local function SCurveTransform(t)
	t = math.clamp(t, -1,1)
	if t >= 0 then
		return (k*t) / (k - t + 1)
	end
	return -((lowerK*-t) / (lowerK + t + 1))
end

local DEADZONE = 0.25
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
end

local function fromSCurveSpace(t)
	return t/2 + 0.5
end

-- Applies a nonlinear transform to the thumbstick position to serve as the acceleration for camera rotation.
-- See https://www.desmos.com/calculator/xw2ytjpzco for a visual reference.
local function gamepadLinearToCurve(thumbstickPosition)
	return Vector2.new(
		math.clamp(math.sign(thumbstickPosition.X) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.X)))), -1, 1),
		math.clamp(math.sign(thumbstickPosition.Y) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.Y)))), -1, 1))
end


-- Remove back accessories since they frequently block the camera
local function isBackAccessory(instance)
	if instance and instance:IsA("Accessory") then
		local handle = instance:WaitForChild("Handle", 5)
		if handle and handle:IsA("Part") then
			local bodyBackAttachment = handle:WaitForChild("BodyBackAttachment", 5)
			if bodyBackAttachment and bodyBackAttachment:IsA("Attachment") then
				return true
			end

			local waistBackAttachment = handle:WaitForChild("WaistBackAttachment", 5)
			if waistBackAttachment and waistBackAttachment:IsA("Attachment") then
				return true
			end
		end
	end

	return false
end

local function removeBackAccessoriesFromCharacter(character)
	for _, child in ipairs(character:GetChildren()) do
		coroutine.wrap(function()
			if isBackAccessory(child) then
				child:Destroy()
			end
		end)()
	end
end

local descendantAddedConnection = nil
local function onCharacterAdded(character)
	removeBackAccessoriesFromCharacter(character)
	descendantAddedConnection = character.DescendantAdded:Connect(function(descendant)
		coroutine.wrap(function()
			if isBackAccessory(descendant) then
				descendant:Destroy()
			end
		end)()
	end)
end

local function onCharacterRemoving(character)
	if descendantAddedConnection then
		descendantAddedConnection:Disconnect()
		descendantAddedConnection = nil
	end
end

-- Set up the Local Player
if RunService:IsClient() then
	if LocalPlayer.Character then
		onCharacterAdded(LocalPlayer.Character)
	end
	LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
	LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)
end


local ShoulderCamera = {}
ShoulderCamera.__index = ShoulderCamera
ShoulderCamera.SpringService = nil

function ShoulderCamera.new(weaponsSystem)
	local self = setmetatable({}, ShoulderCamera)
	self.weaponsSystem = weaponsSystem

	-- Configuration parameters (constants)
	self.fieldOfView = 70
	self.minPitch = math.rad(-75) -- min degrees camera can angle down
	self.maxPitch = math.rad(75) -- max degrees camera can cangle up
	self.normalOffset = Vector3.new(2.25, 2.25, 10.5) -- this is the camera's offset from the player
	self.zoomedOffsetDistance = 8 -- number of studs to zoom in from default offset when zooming
	self.normalCrosshairScale = 1
	self.zoomedCrosshairScale = 0.75
	self.defaultZoomFactor = 1
	self.canZoom = true
	self.zoomInputs = { Enum.UserInputType.MouseButton2, Enum.KeyCode.ButtonL2 }
	self.sprintInputs = { Enum.KeyCode.LeftShift }
	self.mouseRadsPerPixel = Vector2.new(1 / 480, 1 / 480)
	self.zoomedMouseRadsPerPixel = Vector2.new(1 / 1200, 1 / 1200)
	self.touchSensitivity = Vector2.new(1 / 100, 1 / 100)
	self.zoomedTouchSensitivity = Vector2.new(1 / 200, 1 / 200)
	self.touchDelayTime = 0.25 -- max time for a touch to count as a tap (to shoot the weapon instead of control camera),
	                           -- also the amount of time players have to start a second touch after releasing the first time to trigger automatic fire
	self.recoilDecay = 2 -- higher number means faster recoil decay rate
	self.rotateCharacterWithCamera = true
	self.gamepadSensitivityModifier = Vector2.new(0.85, 0.65)
	-- Walk speeds
	self.zoomWalkSpeed = 8
	self.normalWalkSpeed = 16
	self.sprintingWalkSpeed = 24

	-- Current state
	self.enabled = false
	self.yaw = 0
	self.pitch = 0
	self.currentCFrame = CFrame.new()
	self.currentOffset = self.normalOffset
	self.currentRecoil = Vector2.new(0, 0)
	self.currentMouseRadsPerPixel = self.mouseRadsPerPixel
	self.currentTouchSensitivity = self.touchSensitivity
	self.mouseLocked = true
	self.touchPanAccumulator = Vector2.new(0, 0) -- used for touch devices, represents amount the player has dragged their finger since starting a touch
	self.currentTool = nil
	self.sprintingInputActivated = false
	self.desiredWalkSpeed = self.normalWalkSpeed
	self.sprintEnabled = false -- true means player will move faster while doing sprint inputs
	self.slowZoomWalkEnabled = false -- true means player will move slower while doing zoom inputs
	self.desiredFieldOfView = self.fieldOfView
	-- Zoom variables
	self.zoomedFromInput = false -- true if player has performed input to zoom
	self.forcedZoomed = false -- ignores zoomedFromInput and canZoom
	self.zoomState = false -- true if player is currently zoomed in
	self.zoomAlpha = 0
	self.hasScope = false
	self.hideToolWhileZoomed = false
	self.currentZoomFactor = self.defaultZoomFactor
	self.zoomedFOV = self.fieldOfView
	-- Gamepad variables
	self.gamepadPan = Vector2.new(0, 0) -- essentially the amount the gamepad has moved from resting position
	self.movementPan = Vector2.new(0, 0) -- this is for movement (gamepadPan is for camera)
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.lastThumbstickTime = nil
	self.currentGamepadSpeed = 0
	self.lastGamepadVelocity = Vector2.new(0, 0)

	-- Occlusion
	self.lastOcclusionDistance = 0
	self.lastOcclusionReachedTime = 0 -- marks the last time camera was at the true occlusion distance
	self.defaultTimeUntilZoomOut = 0
	self.timeUntilZoomOut = self.defaultTimeUntilZoomOut -- time after lastOcclusionReachedTime that camera will zoom out
	self.timeLastPoppedWayIn = 0 -- this holds the last time camera popped nearly into first person
	self.isZoomingOut = false
	self.tweenOutTime = 0.2
	self.curOcclusionTween = nil
	self.occlusionTweenObject = nil

	-- Side correction (when player is against a wall)
	self.sideCorrectionGoalVector = nil
	self.lastSideCorrectionMagnitude = 0
	self.lastSideCorrectionReachedTime = 0 -- marks the last time the camera was at the true correction distance
	self.revertSideCorrectionSpeedMultiplier = 2 -- speed at which camera reverts the side correction (towards 0 correction)
	self.defaultTimeUntilRevertSideCorrection = 0.75
	self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection -- time after lastSideCorrectionReachedTime that camera will revert the correction
	self.isRevertingSideCorrection = false

	-- Datamodel references
	self.eventConnections = {}
	self.raycastIgnoreList = {}
	self.currentCamera = nil
	self.currentCharacter = nil
	self.currentHumanoid = nil
	self.currentRootPart = nil
	self.controlModule = nil -- used to get player's touch input for moving character
	self.random = Random.new()

	return self
end

function ShoulderCamera:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end
	self.enabled = enabled

	if self.enabled then
		RunService:BindToRenderStep(CAMERA_RENDERSTEP_NAME, Enum.RenderPriority.Camera.Value - 1, function(dt) self:onRenderStep(dt) end)
		ContextActionService:BindAction(ZOOM_ACTION_NAME, function(...) self:onZoomAction(...) end, false, unpack(self.zoomInputs))
		ContextActionService:BindAction(SPRINT_ACTION_NAME, function(...) self:onSprintAction(...) end, false, unpack(self.sprintInputs))

		table.insert(self.eventConnections, LocalPlayer.CharacterAdded:Connect(function(character) self:onCurrentCharacterChanged(character) end))
		table.insert(self.eventConnections, LocalPlayer.CharacterRemoving:Connect(function() self:onCurrentCharacterChanged(nil) end))
		table.insert(self.eventConnections, workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() self:onCurrentCameraChanged(workspace.CurrentCamera) end))
		table.insert(self.eventConnections, UserInputService.InputBegan:Connect(function(inputObj, wasProcessed) self:onInputBegan(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputChanged:Connect(function(inputObj, wasProcessed) self:onInputChanged(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputEnded:Connect(function(inputObj, wasProcessed) self:onInputEnded(inputObj, wasProcessed) end))

		self:onCurrentCharacterChanged(LocalPlayer.Character)
		self:onCurrentCameraChanged(workspace.CurrentCamera)

		-- Make transition to shouldercamera smooth by facing in same direction as previous camera
		local cameraLook = self.currentCamera.CFrame.lookVector
		self.yaw = math.atan2(-cameraLook.X, -cameraLook.Z)
		self.pitch = math.asin(cameraLook.Y)

		self.currentCamera.CameraType = Enum.CameraType.Scriptable

		self:setZoomFactor(self.currentZoomFactor) -- this ensures that zoomedFOV reflecs currentZoomFactor

		workspace.CurrentCamera.CameraSubject = self.currentRootPart

		self.occlusionTweenObject = Instance.new("NumberValue")
		self.occlusionTweenObject.Name = "OcclusionTweenObject"
		self.occlusionTweenObject.Parent = script
		self.occlusionTweenObject.Changed:Connect(function(value)
			self.lastOcclusionDistance = value
		end)

		-- Sets up weapon system to use camera for raycast direction instead of gun look vector
		self.weaponsSystem.aimRayCallback = function()
			local cameraCFrame = self.currentCFrame
			return Ray.new(cameraCFrame.p, cameraCFrame.LookVector * 500)
		end
	else
		RunService:UnbindFromRenderStep(CAMERA_RENDERSTEP_NAME)
		ContextActionService:UnbindAction(ZOOM_ACTION_NAME)
		ContextActionService:UnbindAction(SPRINT_ACTION_NAME)

		if self.currentHumanoid then
			self.currentHumanoid.AutoRotate = true
		end

		if self.currentCamera then
			self.currentCamera.CameraType = Enum.CameraType.Custom
		end

		self:updateZoomState()

		self.yaw = 0
		self.pitch = 0

		for _, conn in pairs(self.eventConnections) do
			conn:Disconnect()
		end
		self.eventConnections = {}

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end
end

function ShoulderCamera:onRenderStep(dt)
	if not self.enabled or
	   not self.currentCamera or
	   not self.currentCharacter or
	   not self.currentHumanoid or
	   not self.currentRootPart
	then
		return
	end

	-- Hide mouse and lock to center if applicable
	if self.mouseLocked and not GuiService:GetEmotesMenuOpen() then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end

	-- Handle gamepad input
	self:processGamepadInput(dt)

	-- Smoothly zoom to desired values
	if self.hasScope then
		ShoulderCamera.SpringService:Target(self, 0.8, 8, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 8, { FieldOfView = self.desiredFieldOfView })
	else
		ShoulderCamera.SpringService:Target(self, 0.8, 3, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 3, { FieldOfView = self.desiredFieldOfView })
	end

	-- Handle walk speed changes
	if self.sprintEnabled or self.slowZoomWalkEnabled then
		self.desiredWalkSpeed = self.normalWalkSpeed
		if self.sprintEnabled and (self.sprintingInputActivated or self:sprintFromTouchInput() or self:sprintFromGamepadInput()) and not self.zoomState then
			self.desiredWalkSpeed = self.sprintingWalkSpeed
		end
		if self.slowZoomWalkEnabled and self.zoomAlpha > 0.1 then
			self.desiredWalkSpeed = self.zoomWalkSpeed
		end

		ShoulderCamera.SpringService:Target(self.currentHumanoid, 0.95, 4, { WalkSpeed = self.desiredWalkSpeed })
	end

	-- Initialize variables used for side correction, occlusion, and calculating camera focus/rotation
	local rootPartPos = self.currentRootPart.CFrame.Position
	local rootPartUnrotatedCFrame = CFrame.new(rootPartPos)
	local yawRotation = CFrame.Angles(0, self.yaw, 0)
	local pitchRotation = CFrame.Angles(self.pitch + self.currentRecoil.Y, 0, 0)
	local xOffset = CFrame.new(self.normalOffset.X, 0, 0)
	local yOffset = CFrame.new(0, self.normalOffset.Y, 0)
	local zOffset = CFrame.new(0, 0, self.normalOffset.Z)
	local collisionRadius = self:getCollisionRadius()
	local cameraYawRotationAndXOffset =
		yawRotation * 		-- First rotate around the Y axis (look left/right)
		xOffset 			-- Then perform the desired offset (so camera is centered to side of player instead of directly on player)
	local cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset

	-- Handle/Calculate side correction when player is adjacent to a wall (so camera doesn't go in the wall)
	local vecToFocus = cameraFocus.p - rootPartPos
	local rayToFocus = Ray.new(rootPartPos, vecToFocus + (vecToFocus.Unit * collisionRadius))
	local hitPart, hitPoint, hitNormal = self:penetrateCast(rayToFocus, self.raycastIgnoreList)
	local currentTime = tick()
	local sideCorrectionGoalVector = Vector3.new() -- if nothing is adjacent to player, goal vector is (0, 0, 0)
	if hitPart then
		hitPoint = hitPoint + (hitNormal * collisionRadius)
		sideCorrectionGoalVector = hitPoint - cameraFocus.p
		if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then -- make it easy for camera to pop closer to player (move left)
			if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection and self.lastSideCorrectionMagnitude ~= 0 then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection * 2 -- double time until revert if popping in repeatedly
			elseif self.lastSideCorrectionMagnitude == 0 and self.timeUntilRevertSideCorrection ~= self.defaultTimeUntilRevertSideCorrection then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection
			end
			self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
			self.lastSideCorrectionReachedTime = currentTime
			self.isRevertingSideCorrection = false
		else
			self.isRevertingSideCorrection = true
		end
	elseif self.lastSideCorrectionMagnitude ~= 0 then
		self.isRevertingSideCorrection = true
	end
	if self.isRevertingSideCorrection then -- make it hard/slow for camera to revert side correction (move right)
		if sideCorrectionGoalVector.Magnitude > self.lastSideCorrectionMagnitude - 1 and sideCorrectionGoalVector.Magnitude ~= 0 then
			self.lastSideCorrectionReachedTime = currentTime -- reset timer if occlusion significantly increased since last frame
		end
		if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection then
			local sideCorrectionChangeAmount = dt * (vecToFocus.Magnitude) * self.revertSideCorrectionSpeedMultiplier
			self.lastSideCorrectionMagnitude = self.lastSideCorrectionMagnitude - sideCorrectionChangeAmount
			if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then
				self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
				self.lastSideCorrectionReachedTime = currentTime
				self.isRevertingSideCorrection = false
			end
		end
	end

	-- Update cameraFocus to reflect side correction
	cameraYawRotationAndXOffset = cameraYawRotationAndXOffset + (-vecToFocus.Unit * self.lastSideCorrectionMagnitude)
	cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset
	self.currentCamera.Focus = cameraFocus

	-- Calculate and apply CFrame for camera
	local cameraCFrameInSubjectSpace =
		cameraYawRotationAndXOffset *
		pitchRotation * 	-- rotate around the X axis (look up/down)
		yOffset *			-- move camera up/vertically
		zOffset				-- move camera back
	self.currentCFrame = rootPartUnrotatedCFrame * cameraCFrameInSubjectSpace

	-- Move camera forward if zoomed in
	if self.zoomAlpha > 0 then
		local trueZoomedOffset = math.max(self.zoomedOffsetDistance - self.lastOcclusionDistance, 0) -- don't zoom too far in if already occluded
		self.currentCFrame = self.currentCFrame:lerp(self.currentCFrame + trueZoomedOffset * self.currentCFrame.LookVector.Unit, self.zoomAlpha)
	end

	self.currentCamera.CFrame = self.currentCFrame

	-- Handle occlusion
	local occlusionDistance = self.currentCamera:GetLargestCutoffDistance(self.raycastIgnoreList)
	if occlusionDistance > 1e-5 then
		occlusionDistance = occlusionDistance + collisionRadius
	end
	if occlusionDistance >= self.lastOcclusionDistance then -- make it easy for the camera to pop in towards the player
		if self.curOcclusionTween ~= nil then
			self.curOcclusionTween:Cancel()
			self.curOcclusionTween = nil
		end
		if currentTime > self.lastOcclusionReachedTime + self.timeUntilZoomOut and self.lastOcclusionDistance ~= 0 then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut * 2 -- double time until zoom out if popping in repeatedly
		elseif self.lastOcclusionDistance == 0  and self.timeUntilZoomOut ~= self.defaultTimeUntilZoomOut then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut
		end

		if occlusionDistance / self.normalOffset.Z > 0.8 and self.timeLastPoppedWayIn == 0 then
			self.timeLastPoppedWayIn = currentTime
		end

		self.lastOcclusionDistance = occlusionDistance
		self.lastOcclusionReachedTime = currentTime
		self.isZoomingOut = false
	else -- make it hard/slow for camera to zoom out
		self.isZoomingOut = true
		if occlusionDistance > self.lastOcclusionDistance - 2 and occlusionDistance ~= 0 then -- reset timer if occlusion significantly increased since last frame
			self.lastOcclusionReachedTime = currentTime
		end

		-- If occlusion pops camera in to almost first person for a short time, pop out instantly
		if currentTime < self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.lastOcclusionDistance / self.normalOffset.Z > 0.8 then
			self.lastOcclusionDistance = occlusionDistance
			self.lastOcclusionReachedTime = currentTime
			self.isZoomingOut = false
		elseif currentTime >= self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.timeLastPoppedWayIn ~= 0 then
			self.timeLastPoppedWayIn = 0
		end
	end

	-- Update occlusion amount if timeout time has passed
	if currentTime >= self.lastOcclusionReachedTime + self.timeUntilZoomOut and not self.zoomState then
		if self.curOcclusionTween == nil then
			self.occlusionTweenObject.Value = self.lastOcclusionDistance
			local tweenInfo = TweenInfo.new(self.tweenOutTime)
			local goal = {}
			goal.Value = self.lastOcclusionDistance - self.normalOffset.Z
			self.curOcclusionTween = TweenService:Create(self.occlusionTweenObject, tweenInfo, goal)
			self.curOcclusionTween:Play()
		end
	end

	-- Apply occlusion to camera CFrame
	local currentOffsetDir = self.currentCFrame.LookVector.Unit
	self.currentCFrame = self.currentCFrame + (currentOffsetDir * self.lastOcclusionDistance)
	self.currentCamera.CFrame = self.currentCFrame

	-- Apply recoil decay
	self.currentRecoil = self.currentRecoil - (self.currentRecoil * self.recoilDecay * dt)

	if self:isHumanoidControllable() and self.rotateCharacterWithCamera then
		self.currentHumanoid.AutoRotate = false
		self.currentRootPart.CFrame = CFrame.Angles(0, self.yaw, 0) + self.currentRootPart.Position -- rotate character to be upright and facing the same direction as camera
		self:applyRootJointFix()
	else
		self.currentHumanoid.AutoRotate = true
	end

	self:handlePartTransparencies()
	self:handleTouchToolFiring()
end

-- This function keeps the held weapon from bouncing up and down too much when you move
function ShoulderCamera:applyRootJointFix()
	if self.rootJoint then
		local translationScale = self.zoomState and Vector3.new(0.25, 0.25, 0.25) or Vector3.new(0.5, 0.5, 0.5)
		local rotationScale = self.zoomState and 0.15 or 0.2
		local rootRotation = self.rootJoint.Part0.CFrame - self.rootJoint.Part0.CFrame.Position
		local rotation = self.rootJoint.Transform - self.rootJoint.Transform.Position
		local yawRotation = CFrame.Angles(0, self.yaw, 0)
		local leadRotation = rootRotation:toObjectSpace(yawRotation)
		local rotationFix = self.rootRigAttach.CFrame
		if self:isHumanoidControllable() then
			rotationFix = self.rootJoint.Transform:inverse() * leadRotation * rotation:Lerp(CFrame.new(), 1 - rotationScale) + (self.rootJoint.Transform.Position * translationScale)
		end

		self.rootJoint.C0 = CFrame.new(self.rootJoint.C0.Position, self.rootJoint.C0.Position + rotationFix.LookVector.Unit)
	end
end

function ShoulderCamera:sprintFromTouchInput()
	local moveVector = nil
	local activeController = nil
	local activeControllerIsTouch = nil
	if self.controlModule then
		moveVector = self.controlModule:GetMoveVector()
		activeController = self.controlModule:GetActiveController()
	end
	if moveVector and activeController then
		activeControllerIsTouch = activeController.thumbstickFrame ~= nil or activeController.thumbpadFrame ~= nil
	end

	if activeControllerIsTouch then
		return (moveVector and moveVector.Magnitude >= 0.9)
	else
		return false
	end
end

function ShoulderCamera:sprintFromGamepadInput()
	return self.movementPan.Magnitude > 0.9
end

function ShoulderCamera:onCurrentCharacterChanged(character)
	self.currentCharacter = character
	if self.currentCharacter then
		self.raycastIgnoreList[1] = self.currentCharacter
		self.currentHumanoid = character:WaitForChild("Humanoid")
		self.currentRootPart = character:WaitForChild("HumanoidRootPart")

		self.rootRigAttach = self.currentRootPart:WaitForChild("RootRigAttachment")
		self.rootJoint = character:WaitForChild("LowerTorso"):WaitForChild("Root")
		self.currentWaist = character:WaitForChild("UpperTorso"):WaitForChild("Waist")
		self.currentWrist = character:WaitForChild("RightHand"):WaitForChild("RightWrist")
		self.wristAttach0 = character:WaitForChild("RightLowerArm"):WaitForChild("RightWristRigAttachment")
		self.wristAttach1 = character:WaitForChild("RightHand"):WaitForChild("RightWristRigAttachment")
		self.rightGripAttachment = character:WaitForChild("RightHand"):WaitForChild("RightGripAttachment")

		self.currentTool = character:FindFirstChildOfClass("Tool")

		self.eventConnections.humanoidDied = self.currentHumanoid.Died:Connect(function()
			self.zoomedFromInput = false
			self:updateZoomState()
		end)
		self.eventConnections.characterChildAdded = character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.currentTool = child
				self:updateZoomState()
			end
		end)
		self.eventConnections.characterChildRemoved = character.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") and self.currentTool == child then
				self.currentTool = character:FindFirstChildOfClass("Tool")
				self:updateZoomState()
			end
		end)

		if Players.LocalPlayer then
			local PlayerScripts = Players.LocalPlayer:FindFirstChild("PlayerScripts")
			if PlayerScripts then
				local PlayerModule = PlayerScripts:FindFirstChild("PlayerModule")
				if PlayerModule then
					self.controlModule = require(PlayerModule:FindFirstChild("ControlModule"))
				end
			end
		end
	else
		if self.eventConnections.humanoidDied then
			self.eventConnections.humanoidDied:Disconnect()
			self.eventConnections.humanoidDied = nil
		end
		if self.eventConnections.characterChildAdded then
			self.eventConnections.characterChildAdded:Disconnect()
			self.eventConnections.characterChildAdded = nil
		end
		if self.eventConnections.characterChildRemoved then
			self.eventConnections.characterChildRemoved:Disconnect()
			self.eventConnections.characterChildRemoved = nil
		end

		self.currentTool = nil
		self.currentHumanoid = nil
		self.currentRootPart = nil
		self.controlModule = nil
	end
end

function ShoulderCamera:onCurrentCameraChanged(camera)
	if self.currentCamera == camera then
		return
	end

	self.currentCamera = camera

	if self.currentCamera then
		self.raycastIgnoreList[2] = self.currentCamera

		if self.eventConnections.cameraTypeChanged then
			self.eventConnections.cameraTypeChanged:Disconnect()
			self.eventConnections.cameraTypeChanged = nil
		end
		self.eventConnections.cameraTypeChanged = self.currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
			if self.enabled then
				self.currentCamera.CameraType = Enum.CameraType.Scriptable
			end
		end)
	end
end

function ShoulderCamera:isHumanoidControllable()
	if not self.currentHumanoid then
		return false
	end
	local humanoidState = self.currentHumanoid:GetState()
	return CONTROLLABLE_HUMANOID_STATES[humanoidState] == true
end

function ShoulderCamera:getCollisionRadius()
	if not self.currentCamera then
		return 0
	end
	local viewportSize = self.currentCamera.ViewportSize
	local aspectRatio = viewportSize.X / viewportSize.Y
	local fovRads = math.rad(self.fieldOfView)
	local imageHeight = math.tan(fovRads) * math.abs(self.currentCamera.NearPlaneZ)
	local imageWidth = imageHeight * aspectRatio

	local cornerPos = Vector3.new(imageWidth, imageHeight, self.currentCamera.NearPlaneZ)
	return cornerPos.Magnitude
end

function ShoulderCamera:penetrateCast(ray, ignoreList)
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function ShoulderCamera:getRelativePitch()
	if self.currentRootPart then
		local pitchRotation = CFrame.Angles(self.pitch, 0, 0)
		local relativeRotation = self.currentRootPart.CFrame:toObjectSpace(pitchRotation)
		local relativeLook = relativeRotation.lookVector

		local angle = math.asin(relativeLook.Y)
		return math.clamp(angle, self.minPitch, self.maxPitch)
	end
	return self.pitch
end

function ShoulderCamera:getCurrentFieldOfView()
	if self.zoomState then
		return self.zoomedFOV
	else
		return self.fieldOfView
	end
end

function ShoulderCamera:handlePartTransparencies()
	local partsLookup = {}
	local accoutrementsLookup = {}

	for _, child in pairs(self.currentCharacter:GetChildren()) do
		local hidden = false
		if child:IsA("BasePart") then
			hidden = partsLookup[child.Name] == true
			child.LocalTransparencyModifier = hidden and 1 or 0
		elseif child:IsA("Accoutrement") then
			local descendants = child:GetDescendants()
			local accoutrementParts = {}
			for _, desc in pairs(descendants) do
				if desc:IsA("Attachment") and accoutrementsLookup[desc.Name] then
					hidden = true
				elseif desc:IsA("BasePart") then
					table.insert(accoutrementParts, desc)
				end
			end
			for _, part in pairs(accoutrementParts) do
				part.LocalTransparencyModifier = hidden and 1 or 0
			end
		elseif child:IsA("Tool") then
			hidden = self.zoomState and (self.hasScope or self.hideToolWhileZoomed)
			for _, part in pairs(child:GetDescendants()) do
				if part:IsA("BasePart") then
					part.LocalTransparencyModifier = hidden and 1 or 0
				end
			end
		end
	end
end

function ShoulderCamera:setSprintEnabled(enabled)
	self.sprintEnabled = enabled
end

function ShoulderCamera:setSlowZoomWalkEnabled(enabled)
	self.slowZoomWalkEnabled = enabled
end

function ShoulderCamera:setHasScope(hasScope)
	if self.hasScope == hasScope then
		return
	end

	self.hasScope = hasScope
	self:updateZoomState()
end

function ShoulderCamera:onSprintAction(actionName, inputState, inputObj)
	self.sprintingInputActivated = inputState == Enum.UserInputState.Begin
end


-- Zoom related functions

function ShoulderCamera:isZoomed()
	return self.zoomState
end

function ShoulderCamera:setHideToolWhileZoomed(hide)
	self.hideToolWhileZoomed = hide
end

function ShoulderCamera:setZoomFactor(zoomFactor)
	self.currentZoomFactor = zoomFactor
	local nominalFOVRadians = math.rad(self.fieldOfView)
	local nominalImageHeight = math.tan(nominalFOVRadians / 2)
	local zoomedImageHeight = nominalImageHeight / self.currentZoomFactor
	self.zoomedFOV = math.deg(math.atan(zoomedImageHeight) * 2)
	self:updateZoomState()
end

function ShoulderCamera:resetZoomFactor()
	self:setZoomFactor(self.defaultZoomFactor)
end

function ShoulderCamera:setForceZoomed(zoomed)
	if self.forcedZoomed == zoomed then return end
	self.forcedZoomed = zoomed
	self:updateZoomState()
end

function ShoulderCamera:setZoomedFromInput(zoomedFromInput)
	if self.zoomedFromInput == zoomedFromInput or (self.currentHumanoid and self.currentHumanoid:GetState() == Enum.HumanoidStateType.Dead) then
		return
	end

	self.zoomedFromInput = zoomedFromInput
	self:updateZoomState()
end

function ShoulderCamera:updateZoomState()
	local isZoomed = self.forcedZoomed
	if self.canZoom and not self.forcedZoomed then
		isZoomed = self.zoomedFromInput
	end

	if not self.enabled or not self.currentTool then
		isZoomed = false
	end

	self.zoomState = isZoomed

	self.currentMouseRadsPerPixel = isZoomed and self.zoomedMouseRadsPerPixel or self.mouseRadsPerPixel
	self.currentTouchSensitivity = isZoomed and self.zoomedTouchSensitivity or self.touchSensitivity

	if self.weaponsSystem and self.weaponsSystem.gui then
		self.weaponsSystem.gui:setCrosshairScaleTarget(self.zoomState and self.zoomedCrosshairScale or self.normalCrosshairScale)
		self.weaponsSystem.gui:setCrosshairEnabled(not self.zoomState or not self.hasScope)
		self.weaponsSystem.gui:setScopeEnabled(self.zoomState and self.hasScope)
		if self.currentTool then
			self.currentTool.ManualActivationOnly = self.zoomState and self.hasScope and UserInputService.TouchEnabled
		end
	end

	if self.currentCamera then
		self.desiredFieldOfView = self:getCurrentFieldOfView()
	end
end

function ShoulderCamera:onZoomAction(actionName, inputState, inputObj)
	if not self.enabled or not self.canZoom or not self.currentCamera or not self.currentCharacter or not self.weaponsSystem.currentWeapon then
		self:setZoomedFromInput(false)
		return Enum.ContextActionResult.Pass
	end

	self:setZoomedFromInput(inputState == Enum.UserInputState.Begin)
	return Enum.ContextActionResult.Sink
end


-- Recoil related functions

function ShoulderCamera:setCurrentRecoilIntensity(x, y)
	self.currentRecoil = Vector2.new(x, y)
end

function ShoulderCamera:addRecoil(recoilAmount)
	self.currentRecoil = self.currentRecoil + recoilAmount
end


-- Input related functions

function ShoulderCamera:applyInput(yaw, pitch)
	local yInvertValue = UserGameSettings:GetCameraYInvertValue()
	self.yaw = self.yaw + yaw
	self.pitch = math.clamp(self.pitch + pitch * yInvertValue, self.minPitch, self.maxPitch)
end

function ShoulderCamera:processGamepadInput(dt)
	local gamepadPan = self.gamepadPan
	if gamepadPan then
		gamepadPan = gamepadLinearToCurve(gamepadPan)
		if gamepadPan.X == 0 and gamepadPan.Y == 0 then
			self.lastThumbstickTime = nil
			if self.lastThumbstickPos.X == 0 and self.lastThumbstickPos.Y == 0 then
				self.currentGamepadSpeed = 0
			end
		end

		local finalConstant = 0
		local currentTime = tick()

		if self.lastThumbstickTime then
			local elapsed = (currentTime - self.lastThumbstickTime) * 10
			self.currentGamepadSpeed = self.currentGamepadSpeed + (6 * ((elapsed ^ 2) / 0.7))

			if self.currentGamepadSpeed > 6 then self.currentGamepadSpeed = 6 end

			if self.lastGamepadVelocity then
				local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
				local velocityDeltaMag = (velocity - self.lastGamepadVelocity).Magnitude

				if velocityDeltaMag > 12 then
					self.currentGamepadSpeed = self.currentGamepadSpeed * (20 / velocityDeltaMag)
					if self.currentGamepadSpeed > 6 then
						self.currentGamepadSpeed = 6
					end
				end
			end

			finalConstant = GameSettings.GamepadCameraSensitivity * self.currentGamepadSpeed * dt
			self.lastGamepadVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickTime = currentTime

		local yawInput = -gamepadPan.X * finalConstant * self.gamepadSensitivityModifier.X
		local pitchInput = finalConstant * gamepadPan.Y * GameSettings:GetCameraYInvertValue() * self.gamepadSensitivityModifier.Y

		self:applyInput(yawInput, pitchInput)
	end
end

function ShoulderCamera:handleTouchToolFiring()
	if self.touchObj then
		if self.lastTapEndTime then -- and not (self.zoomState and self.hasScope) then
			local touchTime = tick() - self.lastTapEndTime
			if touchTime < self.touchDelayTime and self.currentTool and self.touchPanAccumulator.Magnitude < 0.5 and not self.firingTool and not self.applyingTouchPan then
				self.firingTool = true
				self.currentTool:Activate()
			end
		end
	else
		if self.currentTool and self.firingTool then
			self.currentTool:Deactivate()
		end
		self.firingTool = false
	end
end

function ShoulderCamera:isTouchPositionForCamera(pos)
	if LocalPlayer then
		local guiObjects = LocalPlayer.PlayerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)
		for _, guiObject in ipairs(guiObjects) do
			if guiObject.Name == "DynamicThumbstickFrame" then
				return false
			end
		end
		return true
	end
	return false
end

function ShoulderCamera:onInputBegan(inputObj, wasProcessed)
	if self.touchObj then
		self.touchObj = nil
		wasProcessed = false
	end

	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		local touchStartPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
		if not wasProcessed and self:isTouchPositionForCamera(touchStartPos) and not self.touchObj then
			self.touchObj = inputObj
			self.touchStartTime = tick()
			self.eventConnections.touchChanged = inputObj.Changed:Connect(function(prop)
				if prop == "Position" then
					local touchTime = tick() - self.touchStartTime

					local newTouchPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
					local delta = (newTouchPos - touchStartPos) * self.currentTouchSensitivity
					local yawInput = -delta.X
					local pitchInput = -delta.Y
					if self.touchPanAccumulator.Magnitude > 0.01 and touchTime > self.touchDelayTime then
						if not self.applyingTouchPan then
							self.applyingTouchPan = true
							self.touchPanAccumulator = Vector2.new(0, 0)
						end
					end
					self:applyInput(yawInput, pitchInput)
					self.touchPanAccumulator = self.touchPanAccumulator + Vector2.new(yawInput, pitchInput)
					touchStartPos = newTouchPos
				end
			end)
		end
	end
end

function ShoulderCamera:onInputChanged(inputObj, wasProcessed)
	if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
		local yawInput = -inputObj.Delta.X * self.currentMouseRadsPerPixel.X
		local pitchInput = -inputObj.Delta.Y * self.currentMouseRadsPerPixel.Y

		self:applyInput(yawInput, pitchInput)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	end
end

function ShoulderCamera:onInputEnded(inputObj, wasProcessed)
	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(0, 0)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(0, 0)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		if self.touchObj == inputObj then
			if self.eventConnections and self.eventConnections.touchChanged then
				self.eventConnections.touchChanged:Disconnect()
				self.eventConnections.touchChanged = nil
			end

			local touchTime = tick() - self.touchStartTime
			if self.currentTool and self.firingTool then
				self.currentTool:Deactivate()
			elseif self.zoomState and self.hasScope and touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.currentTool:Activate() -- this makes sure to shoot the sniper with a single tap when it is zoomed in
				self.currentTool:Deactivate()
			end
			self.firingTool = false

			self.touchPanAccumulator = Vector2.new(0, 0)
			if touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.lastTapEndTime = tick()
			else
				self.lastTapEndTime = nil
			end
			self.applyingTouchPan = false

			self.gamepadPan = Vector2.new(0, 0)
			self.touchObj = nil
		end
	end
end

return ShoulderCamera

end))
ModuleScript466.Name = "SpringService"
ModuleScript466.Parent = Folder459
table.insert(cors,sandbox(ModuleScript466,function()
-- SpringService.lua
-- Binds properties to spring simulations
-- @author Parker Stebbins <pstebbins@roblox.com>

local RunService = game:GetService('RunService')

local LinearSpring = {} do
	LinearSpring.__index = LinearSpring

	local pi = math.pi
	local exp = math.exp
	local sin = math.sin
	local cos = math.cos
	local sqrt = math.sqrt

	function LinearSpring.new(dampingRatio, frequency, goal)
		assert(
			dampingRatio*frequency >= 0,
			'No steady state solution for the given damping ratio & frequency'
		)

		return setmetatable(
			{
				d = dampingRatio, -- Damping ratio - Dimensionless
				f = frequency, -- Undamped frequency - Hertz
				g = goal, -- Goal position - Vector
				v = goal*0, -- Current velocity - Vector
			},
			LinearSpring
		)
	end

	function LinearSpring:setGoal(goal)
		self.g = goal
	end

	function LinearSpring:canSleep()
		return false -- @todo add sleeping
	end

	function LinearSpring:step(dt, p0)

		-- Problem: Advance the spring simulation by t seconds.
		-- Start by taking the ODE of a damped harmonic oscillator:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is desired position, f is angular frequency, and d is damping ratio.
		-- Apply some constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- The IVP can now be solved to obtain analytic expressions for X[t] and X'[t].
		-- The solution takes on one of three forms depending on the value of d.

		local d = self.d
		local f = self.f*pi*2 -- cycle/s -> rad/s
		local g = self.g
		local v0 = self.v

		local o = p0 - g
		local decay = exp(-dt*d*f)

		local p1, v1

		if d == 1 then -- Critically damped

			p1 = (v0*dt + o*(f*dt + 1))*decay + g
			v1 = (v0 - (o*f + v0)*(f*dt))*decay

		elseif d < 1 then -- Underdamped

			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- @todo improve stability as d approaches 1

			p1 = (o*i + (v0 + o*(d*f))*j/(f*c))*decay + g
			v1 = (v0*(i*c) - (v0*d + o*f)*j)*(decay/c)

		else -- Overdamped

			local c = sqrt(d*d - 1)

			local r1 = -f*(d - c)
			local r2 = -f*(d + c)

			-- @todo improve stability as d approaches 1

			local co2 = (v0 - o*r1)/(2*f*c)
			local co1 = o - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			p1 = e1 + e2 + g
			v1 = r1*e1 + r2*e2
		end

		self.v = v1

		return p1
	end
end

local LinearValue = {} do
	LinearValue.__index = LinearValue

	function LinearValue.new(...)
		return setmetatable(
			{
				...
			},
			LinearValue
		)
	end

	function LinearValue:__add(rhs)
		-- vector + vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] + rhs[i]
		end

		return out
	end

	function LinearValue:__sub(rhs)
		-- vector - vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] - rhs[i]
		end

		return out
	end

	function LinearValue:__mul(rhs)
		-- vector*scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]*rhs
		end

		return out
	end

	function LinearValue:__div(rhs)
		-- vector/scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]/rhs
		end

		return out
	end
end

local springMetadata = {
	-- Defines a spring type with functions for converting to/from values that the spring can digest
	number = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value)
		end,
		fromIntermediate = function(value)
			return value[1]
		end,
	},

	UDim = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.Scale, value.Offset)
		end,
		fromIntermediate = function(value)
			return UDim.new(value[1], value[2])
		end,
	},

	UDim2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return LinearValue.new(x.Scale, x.Offset, y.Scale, y.Offset)
		end,
		fromIntermediate = function(value)
			return UDim2.new(value[1], value[2], value[3], value[4])
		end,
	},

	Vector2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y)
		end,
		fromIntermediate = function(value)
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y, value.Z)
		end,
		fromIntermediate = function(value)
			return Vector3.new(value[1], value[2], value[3])
		end,
	},
}

local springStates = {} -- {[object] = {[property] = Spring}

local steppedEvent = RunService:IsClient() and RunService.RenderStepped or RunService.Heartbeat
steppedEvent:Connect(function(dt)
	for object, state in pairs(springStates) do
		for name, spring in pairs(state) do
			local oldValue = object[name]
			local meta = assert(springMetadata[typeof(oldValue)])

			local oldIntermediate = meta.toIntermediate(oldValue)
			local newIntermediate = spring:step(dt, oldIntermediate)

			if spring:canSleep() then
				state[name] = nil
			end

			object[name] = meta.fromIntermediate(newIntermediate)
		end

		if not next(state) then
			springStates[object] = nil
		end
	end
end)

local SpringService = {} do
	function SpringService:Target(object, dampingRatio, frequency, properties)
		local state = springStates[object]

		if not state then
			state = {}
			springStates[object] = state
		end

		for name, goal in pairs(properties) do
			local spring = state[name]

			local meta = assert(
				springMetadata[typeof(goal)],
				'Unsupported type: ' .. typeof(goal)
			)
			local intermediateGoal = meta.toIntermediate(goal)

			if spring then
				spring:setGoal(intermediateGoal)
			else
				spring = meta.springType.new(dampingRatio, frequency, intermediateGoal)
				state[name] = spring
			end
		end
	end

	function SpringService:Stop(object, property)
		if property then
			-- Unbind a property
			local state = springStates[object]
			if state then
				state[property] = nil
			end
		else
			-- Unbind all the properties
			springStates[object] = nil
		end
	end
end

return SpringService

end))
ModuleScript467.Name = "WeaponsGui"
ModuleScript467.Parent = Folder459
table.insert(cors,sandbox(ModuleScript467,function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer

local WeaponsSystemFolder = script.Parent.Parent
local WeaponData = WeaponsSystemFolder:WaitForChild("WeaponData")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local SpringService = require(Libraries:WaitForChild("SpringService"))

local DirectionalIndicatorGuiManager = require(Libraries:WaitForChild("DirectionalIndicatorGuiManager"))
local DamageBillboardHandler = require(Libraries:WaitForChild("DamageBillboardHandler"))

local WeaponsSystemGuiTemplate = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("WeaponsSystemGui")

local AIM_ON_NORMAL = "rbxassetid://2804583948"
local AIM_OFF_NORMAL = "rbxassetid://2804597178"
local AIM_ON_PRESSED = "rbxassetid://2804598866"
local AIM_OFF_PRESSED = "rbxassetid://2804599869"

local FIRE_NORMAL = "rbxassetid://2804818047"
local FIRE_PRESSED = "rbxassetid://2804818076"

local WeaponsGui = {}
WeaponsGui.__index = WeaponsGui

function WeaponsGui.new(weaponsSystem)
	local self = setmetatable({}, WeaponsGui)
	self.weaponsSystem = weaponsSystem
	self.connections = {}
	self.enabled = false

	self.referenceViewportSize = Vector2.new(1000, 1000) -- viewport size that ui elements in scalingElementsFolder were designed on
	self.scaleWeight = 0.75 -- determines weight of scaling (a higher value increases the degree to which elements are scaled)
	self.originalScaleAmounts = {}

	self.crosshairDampingRatio = 0.9
	self.crosshairFrequency = 3
	self.crosshairScaleTarget = 1
	self.crosshairScale = 1
	self.crosshairWeaponScale = 1
	self.crosshairEnabled = true

	self.scopeEnabled = false
	self.isZoomed = false

	self.gui = WeaponsSystemGuiTemplate:Clone()
	self.gui.Enabled = false

	coroutine.wrap(function()
		self.scalingElementsFolder = self.gui:WaitForChild("ScalingElements")

		self.DirectionalIndicatorGuiManager = DirectionalIndicatorGuiManager.new(self)

		self.crosshairFrame = self.scalingElementsFolder:WaitForChild("Crosshair")
		self.crosshairBottom = self.crosshairFrame:WaitForChild("Bottom")
		self.crosshairLeft = self.crosshairFrame:WaitForChild("Left")
		self.crosshairRight = self.crosshairFrame:WaitForChild("Right")
		self.crosshairTop = self.crosshairFrame:WaitForChild("Top")
		self.origCrosshairScales = {} -- these will be used to size crosshair pieces when screen size changes
		self.origCrosshairScales[self.crosshairBottom] = Vector2.new(self.crosshairBottom.Size.X.Scale, self.crosshairBottom.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairLeft] = Vector2.new(self.crosshairLeft.Size.X.Scale, self.crosshairLeft.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairRight] = Vector2.new(self.crosshairRight.Size.X.Scale, self.crosshairRight.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairTop] = Vector2.new(self.crosshairTop.Size.X.Scale, self.crosshairTop.Size.Y.Scale)
		self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

		self.hitMarker = self.scalingElementsFolder:WaitForChild("HitMarker"):WaitForChild("HitMarkerImage")

		self.scopeFrame = self.gui:WaitForChild("Scope")
		local scopeImage = self.scopeFrame:WaitForChild("ScopeImage")

		self.smallTouchscreen = self.gui:WaitForChild("SmallTouchscreen")
		self.largeTouchscreen = self.gui:WaitForChild("LargeTouchscreen")

		self.smallAimButton = self.smallTouchscreen:WaitForChild("AimButton")
		self.smallAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.largeAimButton = self.largeTouchscreen:WaitForChild("AimButton")
		self.largeAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.smallFireButton = self.smallTouchscreen:WaitForChild("FireButton")
		self.smallFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.smallFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)
		self.largeFireButton = self.largeTouchscreen:WaitForChild("FireButton")
		self.largeFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.largeFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)

		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		self.gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
		self.gui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() self:onScreenSizeChanged() end)
		self:onScreenSizeChanged()

		WeaponData.OnClientEvent:Connect(function(cmd, otherPlayerPosition)
			if cmd == "HitByOtherPlayer" then
				self.DirectionalIndicatorGuiManager:ActivateDirectionalIndicator("DamageIndicator", otherPlayerPosition)
			end
		end)

		ContentProvider:PreloadAsync({
			self.crosshairBottom,
			self.crosshairLeft,
			self.crosshairRight,
			self.crosshairTop,
			scopeImage,
			self.smallAimButton,
			self.largeAimButton,
			self.smallFireButton,
			self.largeFireButton,
		})
	end)()

	return self
end

local function getJumpButton()
	if UserInputService.TouchEnabled then
		local touchGui = LocalPlayer.PlayerGui:WaitForChild("TouchGui")
		return touchGui.TouchControlFrame:FindFirstChild("JumpButton")
	end

	return nil
end

function WeaponsGui:onScreenSizeChanged()
	if self.smallTouchscreen and self.largeTouchscreen then
		if UserInputService.TouchEnabled then
			local isSmallScreen
			local jumpButton = getJumpButton()
			if jumpButton then
				isSmallScreen = jumpButton.Size.X.Offset <= 70
			else
				isSmallScreen = self.gui.AbsoluteSize.Y < 600
			end
			self.smallTouchscreen.Visible = isSmallScreen
			self.largeTouchscreen.Visible = not isSmallScreen
		else
			self.smallTouchscreen.Visible = false
			self.largeTouchscreen.Visible = false
		end
	end

	-- Scales all ui elements in scalingElementsFolder based on current screen size relative to self.referenceViewportSize
	local viewportSize = workspace.CurrentCamera.ViewportSize
	for _, child in pairs(self.scalingElementsFolder:GetChildren()) do
		self:updateScale(child, viewportSize)
	end

	self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

	-- Update crosshair sizes...they must use offset because crosshairFrame changes size frequently
	self.crosshairBottom.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairBottom].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairBottom].Y * self.crosshairNormalSize.Y)
	self.crosshairLeft.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairLeft].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairLeft].Y * self.crosshairNormalSize.Y)
	self.crosshairRight.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairRight].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairRight].Y * self.crosshairNormalSize.Y)
	self.crosshairTop.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairTop].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairTop].Y * self.crosshairNormalSize.Y)
end

-- This scales the scale amount non-linearly according to scaleWeight
function WeaponsGui:getWeightedScaleAmount(originalScaleAmount, newScreenDim, referenceScreenDim)
	return (1 - self.scaleWeight) * originalScaleAmount * referenceScreenDim / newScreenDim + self.scaleWeight * originalScaleAmount
end

function WeaponsGui:updateScale(guiObject, viewportSize)
	if guiObject:IsA("GuiObject") then
		local xScale = guiObject.Size.X.Scale
		local yScale = guiObject.Size.Y.Scale
		if xScale ~= 0 or yScale ~= 0 or self.originalScaleAmounts[guiObject] ~= nil then
			if self.originalScaleAmounts[guiObject] == nil then
				self.originalScaleAmounts[guiObject] = Vector2.new(xScale, yScale)
			end

			xScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].X, viewportSize.X, self.referenceViewportSize.X)
			yScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].Y, viewportSize.Y, self.referenceViewportSize.Y)
			guiObject.Size = UDim2.new(xScale, 0, yScale, 0)
		end
		return -- makes it so only the most outer container will be scaled
	end

	for _, child in ipairs(guiObject:GetChildren()) do
		self:updateScale(child, viewportSize)
	end
end

function WeaponsGui:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end

	self.enabled = enabled
	if self.enabled then
		self.connections.renderStepped = RunService.RenderStepped:Connect(function(dt) self:onRenderStepped(dt) end)
	else
		self:setZoomed(false)

		for _, v in pairs(self.connections) do
			v:Disconnect()
		end
		self.connections = {}
	end

	if self.gui then
		self.gui.Enabled = self.enabled
	end
end

function WeaponsGui:setCrosshairEnabled(crosshairEnabled)
	if self.crosshairEnabled == crosshairEnabled then
		return
	end

	self.crosshairEnabled = crosshairEnabled
	if self.crosshairFrame then
		self.crosshairFrame.Visible = self.crosshairEnabled
	end
	if self.hitMarker then
		self.hitMarker.ImageTransparency = 1
		self.hitMarker.Visible = self.crosshairEnabled
	end
end

function WeaponsGui:setScopeEnabled(scopeEnabled)
	if self.scopeEnabled == scopeEnabled then
		return
	end

	self.scopeEnabled = scopeEnabled
	if self.scopeFrame then
		self.scopeFrame.Visible = self.scopeEnabled
	end

	local jumpButton = getJumpButton()

	if self.scopeEnabled then
		self.smallFireButton.Visible = true
		self.largeFireButton.Visible = true

		if jumpButton then
			jumpButton.Visible = false
		end
	else
		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		if jumpButton then
			jumpButton.Visible = true
		end
	end
end

function WeaponsGui:setCrosshairWeaponScale(scale)
	if self.crosshairWeaponScale == scale then
		return
	end

	self.crosshairWeaponScale = scale
end

function WeaponsGui:setCrosshairScaleTarget(target, dampingRatio, frequency)
	if typeof(dampingRatio) == "number" then
		self.crosshairDampingRatio = dampingRatio
	end
	if typeof(frequency) == "number" then
		self.crosshairFrequency = frequency
	end
	if self.crosshairScaleTarget == target then
		return
	end

	self.crosshairScaleTarget = target
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:setCrosshairScale(scale)
	if self.crosshairScale == scale then
		return
	end

	self.crosshairScale = scale
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:OnHitOtherPlayer(damage, humanoidHit) -- show hit indicator, then fade
	self.hitMarker.ImageTransparency = 0
	local tweenInfo = TweenInfo.new(0.8)
	local goal = {}
	goal.ImageTransparency = 1
	local tween = TweenService:Create(self.hitMarker, tweenInfo, goal)
	tween:Play()

	DamageBillboardHandler:ShowDamageBillboard(damage, humanoidHit.Parent:FindFirstChild("Head"))
end

function WeaponsGui:onRenderStepped(dt)
	if not self.enabled then
		return
	end
	if not self.gui then
		return
	end

	if self.crosshairFrame and self.crosshairEnabled then
		local crosshairSize = self.crosshairNormalSize * self.crosshairScale * self.crosshairWeaponScale
		self.crosshairFrame.Size = UDim2.new(0, crosshairSize.X, 0, crosshairSize.Y)
	end
end

function WeaponsGui:setZoomed(zoomed)
	if zoomed == self.isZoomed then
		return
	end

	self.isZoomed = zoomed
	local normalImage = self.isZoomed and AIM_OFF_NORMAL or AIM_ON_NORMAL
	local pressedImage = self.isZoomed and AIM_OFF_PRESSED or AIM_ON_PRESSED

	if self.smallAimButton then
		self.smallAimButton.Image = normalImage
		self.smallAimButton.PressedImage = pressedImage
	end
	if self.largeAimButton then
		self.largeAimButton.Image = normalImage
		self.largeAimButton.PressedImage = pressedImage
	end

	if self.weaponsSystem.camera then
		self.weaponsSystem.camera:setForceZoomed(self.isZoomed)
	end
end

function WeaponsGui:onTouchAimButtonActivated()
	self:setZoomed(not self.isZoomed)
end

function WeaponsGui:onTouchFireButton(inputObj, inputState)
	local currentWeapon = self.weaponsSystem.currentWeapon
	if currentWeapon and currentWeapon.instance and currentWeapon.instance:IsA("Tool") then
		if inputObj.UserInputState == Enum.UserInputState.Begin then
			currentWeapon.instance:Activate()
			if self.smallFireButton then
				self.smallFireButton.Image = FIRE_PRESSED
			end
			if self.largeFireButton then
				self.largeFireButton.Image = FIRE_PRESSED
			end

			inputObj:GetPropertyChangedSignal("UserInputState"):Connect(function()
				if inputObj.UserInputState == Enum.UserInputState.End then
					currentWeapon.instance:Deactivate()
					if self.smallFireButton then
						self.smallFireButton.Image = FIRE_NORMAL
					end
					if self.largeFireButton then
						self.largeFireButton.Image = FIRE_NORMAL
					end
				end
			end)
		end
	end
end

return WeaponsGui
end))
ModuleScript468.Name = "ancestorHasTag"
ModuleScript468.Parent = Folder459
table.insert(cors,sandbox(ModuleScript468,function()
local CollectionService = game:GetService("CollectionService")

local function ancestorHasTag(instance, tag)
	local currentInstance = instance
	while currentInstance do
		if CollectionService:HasTag(currentInstance, tag) then
			return true
		else
			currentInstance = currentInstance.Parent
		end
	end

	return false
end

return ancestorHasTag
end))
ModuleScript469.Name = "BaseWeapon"
ModuleScript469.Parent = Folder459
table.insert(cors,sandbox(ModuleScript469,function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local AnimationsFolder = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Animations")

local localRandom = Random.new()

local BaseWeapon = {}
BaseWeapon.__index = BaseWeapon

BaseWeapon.CanAimDownSights = false
BaseWeapon.CanBeReloaded = false
BaseWeapon.CanBeFired = false
BaseWeapon.CanHit = false

function BaseWeapon.new(weaponsSystem, instance)
	assert(instance, "BaseWeapon.new() requires a valid Instance to be attached to.")

	local self = setmetatable({}, BaseWeapon)
	self.connections = {}
	self.descendants = {}
	self.descendantsRegistered = false
	self.optionalDescendantNames = {}
	self.weaponsSystem = weaponsSystem
	self.instance = instance
	self.animController = nil
	self.player = nil
	self.enabled = false
	self.equipped = false
	self.activated = false
	self.nextShotId = 1
	self.activeRenderStepName = nil
	self.curReloadSound = nil

	self.animTracks = {}
	self.sounds = {}
	self.configValues = {}
	self.trackedConfigurations = {}

	self.ammoInWeaponValue = nil

	self.reloading = false
	self.canReload = true

	self:registerDescendants()
	self.connections.descendantAdded = self.instance.DescendantAdded:Connect(function(descendant)
		self:onDescendantAdded(descendant)
	end)

	return self
end

function BaseWeapon:doInitialSetup()
	local selfClass = getmetatable(self)
	self.instanceIsTool = self.instance:IsA("Tool")

	-- Set up child added/removed
	self.connections.childAdded = self.instance.ChildAdded:Connect(function(child)
		self:onChildAdded(child)
	end)
	self.connections.childRemoved = self.instance.ChildRemoved:Connect(function(child)
		self:onChildRemoved(child)
	end)
	for _, child in pairs(self.instance:GetChildren()) do
		self:onChildAdded(child)
	end

	-- Initialize self.ammoInWeaponValue
	if selfClass.CanBeReloaded then
		if IsServer then
			self.ammoInWeaponValue = self.instance:FindFirstChild("CurrentAmmo")
			if not self.ammoInWeaponValue then
				self.ammoInWeaponValue = Instance.new("IntValue")
				self.ammoInWeaponValue.Name = "CurrentAmmo"
				self.ammoInWeaponValue.Value = 0
				self.ammoInWeaponValue.Parent = self.instance
			end
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		else
			self.ammoInWeaponValue = self.instance:WaitForChild("CurrentAmmo")
		end
	end

	self.connections.ancestryChanged = self.instance.AncestryChanged:Connect(function() self:onAncestryChanged() end)
	self:onAncestryChanged()

	-- Set up equipped/unequipped and activated/deactivated
	if self.instanceIsTool then
		self.connections.equipped = self.instance.Equipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(true)
				if self:getAmmoInWeapon() <= 0 then
					-- Have to wait a frame, otherwise the reload animation will not play
					coroutine.wrap(function()
						wait()
						self:reload()
					end)()
				end
			end
		end)
		self.connections.unequipped = self.instance.Unequipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(false)
				if self.reloading then
					self:cancelReload()
				end
			end
		end)
		if self.instance:IsDescendantOf(workspace) and self.player then
			self:setEquipped(true)
		end

		self.connections.activated = self.instance.Activated:Connect(function()
			self:setActivated(true)
		end)
		self.connections.deactivated = self.instance.Deactivated:Connect(function()
			self:setActivated(false)
		end)

		-- Weld handle to weapon primary part
		if IsServer then
			self.handle = self.instance:FindFirstChild("Handle")

			local model = self.instance:FindFirstChildOfClass("Model")
			local handleAttachment = model:FindFirstChild("HandleAttachment", true)

			if self.handle and handleAttachment then
				local handleOffset = model.PrimaryPart.CFrame:toObjectSpace(handleAttachment.WorldCFrame)

				local weld = Instance.new("Weld")
				weld.Name = "HandleWeld"
				weld.Part0 = self.handle
				weld.Part1 = model.PrimaryPart
				weld.C0 = CFrame.new()
				weld.C1 = handleOffset
				weld.Parent = self.handle

				self.handle.Anchored = false
				model.PrimaryPart.Anchored = false
			end
		end
	end
end

function BaseWeapon:registerDescendants()
	if not self.instance then
		error("No instance set yet!")
	end

	if self.descendantsRegistered then
		warn("Descendants already registered!")
		return
	end

	for _, descendant in ipairs(self.instance:GetDescendants()) do
		if self.descendants[descendant.Name] == nil then
			self.descendants[descendant.Name] = descendant
		else
			self.descendants[descendant.Name] = "Multiple"
		end
	end
	self.descendantsRegistered = true
end

function BaseWeapon:addOptionalDescendant(key, descendantName)
	if self.instance == nil then
		error("No instance set yet!")
	end

	if not self.descendantsRegistered then
		error("Descendants not registered!")
	end

	if self.descendants[descendantName] == "Multiple" then
		error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendantName.."\", so you cannot addOptionalDescendant with that descendant name.")
	end

	local found = self.descendants[descendantName]
	if found then
		self[key] = found
		return
	else
		self.optionalDescendantNames[descendantName] = key
	end
end

function BaseWeapon:onDescendantAdded(descendant)
	if self.descendants[descendant.Name] == nil then
		self.descendants[descendant.Name] = descendant
	else
		self.descendants[descendant.Name] = "Multiple"
	end

	local desiredKey = self.optionalDescendantNames[descendant.Name]
	if desiredKey then
		if self.descendants[descendant.Name] == "Multiple" then
			error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendant.Name.."\", so you cannot addOptionalDependency with that descendant name.")
		end
		self[desiredKey] = descendant
		self.optionalDescendantNames[descendant.Name] = nil
	end
end

function BaseWeapon:cleanupConnection(...)
	local args = { ... }
	for _, name in pairs(args) do
		if typeof(name) == "string" and self.connections[name] then
			self.connections[name]:Disconnect()
			self.connections[name] = nil
		end
	end
end

function BaseWeapon:onAncestryChanged()
	if self.instanceIsTool then
		local player = nil
		if self.instance:IsDescendantOf(Players) then
			local parentPlayer = self.instance.Parent.Parent
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		elseif self.instance:IsDescendantOf(workspace) then
			local parentPlayer = Players:GetPlayerFromCharacter(self.instance.Parent)
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		end

		self:setPlayer(player)
	end
end

function BaseWeapon:setPlayer(player)
	if self.player == player then
		return
	end

	self.player = player
end

function BaseWeapon:setEquipped(equipped)
	if self.equipped == equipped then
		return
	end

	self.equipped = equipped
	self:onEquippedChanged()

	if not self.equipped then
		self:stopAnimations()
	end
end

function BaseWeapon:onEquippedChanged()
	if self.activeRenderStepName then
		RunService:UnbindFromRenderStep(self.activeRenderStepName)
		self.activeRenderStepName = nil
	end
	self:cleanupConnection("localStepped")

	if not IsServer and self.weaponsSystem then
		self.weaponsSystem.setWeaponEquipped(self, self.equipped)
		if self.equipped then
			if self.player == Players.LocalPlayer then
				RunService:BindToRenderStep(self.instance:GetFullName(), Enum.RenderPriority.Input.Value, function(dt)
					self:onRenderStepped(dt)
				end)
				self.activeRenderStepName = self.instance:GetFullName()
			end
			self.connections.localStepped = RunService.Heartbeat:Connect(function(dt)
				self:onStepped(dt)
			end)
		end
	end

	if self.instanceIsTool then
		for _, part in pairs(self.instance:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = part ~= self.handle and not self.equipped
			end
		end
	end

	self:setActivated(false)
end

function BaseWeapon:setActivated(activated, fromNetwork)
	if not IsServer and fromNetwork and self.player == Players.LocalPlayer then
		return
	end

	if self.activated == activated then
		return
	end

	self.activated = activated
	if IsServer and not fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponActivated"):FireAllClients(self.player, self.instance, self.activated)
	end

	self:onActivatedChanged()
end

function BaseWeapon:onActivatedChanged()

end

function BaseWeapon:renderFire(fireInfo)

end

function BaseWeapon:simulateFire(fireInfo)

end

function BaseWeapon:isOwnerAlive()
	if self.instance:IsA("Tool") then
		local humanoid = self.instance.Parent:FindFirstChildOfClass("Humanoid")
		if humanoid then
			return humanoid:GetState() ~= Enum.HumanoidStateType.Dead
		end
	end

	return true
end

function BaseWeapon:fire(origin, dir, charge)
	if not self:isOwnerAlive() or self.reloading then
		return
	end

	if self:useAmmo(1) <= 0 then
		self:reload()
		return
	end

	local fireInfo = {}
	fireInfo.origin = origin
	fireInfo.dir = dir
	fireInfo.charge = math.clamp(charge or 1, 0, 1)
	fireInfo.id = self.nextShotId
	self.nextShotId = self.nextShotId + 1

	if not IsServer then
		self:onFired(self.player, fireInfo, false)
		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireServer(self.instance, fireInfo)
	else
		self:onFired(self.player, fireInfo, false)
	end
end

function BaseWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer then
		if firingPlayer == Players.LocalPlayer and fromNetwork then
			return
		end

		self:simulateFire(firingPlayer, fireInfo)
	else
		if self:useAmmo(1) <= 0 then
			return
		end

		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireAllClients(firingPlayer, self.instance, fireInfo)
	end
end

function BaseWeapon:getConfigValue(valueName, defaultValue)
	if self.configValues[valueName] ~= nil then
		return self.configValues[valueName]
	else
		return defaultValue
	end
end

function BaseWeapon:tryPlaySound(soundName, playbackSpeedRange)
	playbackSpeedRange = playbackSpeedRange or 0

	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	if not soundTemplate then
		return
	end

	local sound = soundTemplate:Clone()
	sound.PlaybackSpeed = sound.PlaybackSpeed + localRandom:NextNumber(-playbackSpeedRange * 0.5, playbackSpeedRange * 0.5)
	sound.Parent = soundTemplate.Parent
	sound:Play()
	coroutine.wrap(function()
		wait(sound.TimeLength / sound.PlaybackSpeed)
		sound:Destroy()
	end)()

	return sound
end

function BaseWeapon:getSound(soundName)
	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	return soundTemplate
end

function BaseWeapon:onDestroyed()

end

function BaseWeapon:onConfigValueAdded(valueObj)
	local valueName = valueObj.Name
	local newValue = valueObj.Value
	self.configValues[valueName] = newValue
	self:onConfigValueChanged(valueName, newValue, nil)

	self.connections["valueChanged:" .. valueName] = valueObj.Changed:Connect(function(changedValue)
		local oldValue = self.configValues[valueName]
		self.configValues[valueName] = changedValue

		self:onConfigValueChanged(valueName, changedValue, oldValue)
	end)
	self.connections["valueRenamed:" .. valueName] = valueObj:GetPropertyChangedSignal("Name"):Connect(function()
		self.configValues[valueName] = nil
		self:cleanupConnection("valueChanged:" .. valueName)
		self:cleanupConnection("valueRenamed:" .. valueName)
		self:onConfigValueAdded(valueObj)
	end)
end

function BaseWeapon:onConfigValueRemoved(valueObj)
	local valueName = valueObj.Name
	self.configValues[valueName] = nil

	self:cleanupConnection("valueChanged:" .. valueName)
	self:cleanupConnection("valueRenamed:" .. valueName)
end

-- This function is used to set configuration values from outside configuration objects/folders
function BaseWeapon:importConfiguration(config)
	if not config or not config:IsA("Configuration") then
		for _, child in pairs(config:GetChildren()) do
			if child:IsA("ValueBase") then
				local valueName = child.Name
				local newValue = child.Value
				local oldValue = self.configValues[valueName]
				self.configValues[valueName] = newValue
				self:onConfigValueChanged(valueName, newValue, oldValue)
			end
		end
	end
end

function BaseWeapon:setConfiguration(config)
	self:cleanupConnection("configChildAdded", "configChildRemoved")
	if not config or not config:IsA("Configuration") then
		return
	end

	for _, child in pairs(config:GetChildren()) do
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end
	self.connections.configChildAdded = config.ChildAdded:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end)
	self.connections.configChildRemoved = config.ChildRemoved:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueRemoved(child)
		end
	end)
end

function BaseWeapon:onChildAdded(child)
	if child:IsA("Configuration") then
		self:setConfiguration(child)
	end
end

function BaseWeapon:onChildRemoved(child)
	if child:IsA("Configuration") then
		self:setConfiguration(nil)
	end
end

function BaseWeapon:onConfigValueChanged(valueName, newValue, oldValue)

end

function BaseWeapon:onRenderStepped(dt)

end

function BaseWeapon:onStepped(dt)

end

function BaseWeapon:getAnimationController()
	if self.animController then
		if not self.instanceIsTool or (self.animController.Parent and self.animController.Parent:IsAncestorOf(self.instance)) then
			return self.animController
		end
	end

	self:setAnimationController(nil)

	if self.instanceIsTool then
		local humanoid = IsServer and self.instance.Parent:FindFirstChildOfClass("Humanoid") or self.instance.Parent:WaitForChild("Humanoid", math.huge)
		local animController = nil
		if not humanoid then
			animController = self.instance.Parent:FindFirstChildOfClass("AnimationController")
		end

		self:setAnimationController(humanoid or animController)
		return self.animController
	end
end

function BaseWeapon:setAnimationController(animController)
	if animController == self.animController then
		return
	end
	self:stopAnimations()
	self.animController = animController
end

function BaseWeapon:stopAnimations()
	for _, track in pairs(self.animTracks) do
		if track.IsPlaying then
			track:Stop()
		end
	end
	self.animTracks = {}
end

function BaseWeapon:getAnimTrack(key)
	local track = self.animTracks[key]
	if not track then
		local animController = self:getAnimationController()
		if not animController then
			warn("No animation controller when trying to play ", key)
			return nil
		end

		local animation = AnimationsFolder:FindFirstChild(key)
		if not animation then
			error(string.format("No such animation \"%s\" ", tostring(key)))
		end

		track = animController:LoadAnimation(animation)
		self.animTracks[key] = track
	end

	return track
end

function BaseWeapon:reload(player, fromNetwork)
	if
		not self.equipped or
		self.reloading or
		not self.canReload or
		self:getAmmoInWeapon() == self:getConfigValue("AmmoCapacity", 30)
	then
		return false
	end

	if not IsServer then
		if self.player ~= nil and self.player ~= Players.LocalPlayer then
			return
		end
		self.weaponsSystem.getRemoteEvent("WeaponReloadRequest"):FireServer(self.instance)
		self:onReloaded(self.player)
	else
		self:onReloaded(player, fromNetwork)
		self.weaponsSystem.getRemoteEvent("WeaponReloaded"):FireAllClients(player, self.instance)
	end
end

function BaseWeapon:onReloaded(player, fromNetwork)
	if fromNetwork and player == Players.LocalPlayer then -- make sure localplayer doesn't reload twice
		return
	end

	self.reloading = true
	self.canReload = false

	-- Play reload animation and sound
	if not IsServer then
		local reloadTrackKey = self:getConfigValue("ReloadAnimation", "RifleReload")
		if reloadTrackKey then
			self.reloadTrack = self:getAnimTrack(reloadTrackKey)
			if self.reloadTrack then
				self.reloadTrack:Play()
			end
		end

		self.curReloadSound = self:tryPlaySound("Reload", nil)
		if self.curReloadSound then
			self.curReloadSound.Ended:Connect(function()
				self.curReloadSound = nil
			end)
		end
	end

	local reloadTime = self:getConfigValue("ReloadTime", 2)
	local startTime = tick()

	if self.connections.reload ~= nil then -- this prevents an endless ammo bug
		return
	end
	self.connections.reload = RunService.Heartbeat:Connect(function()
		-- Stop trying to reload if the player unequipped this weapon or reloading was canceled some other way
		if not self.reloading then
			if self.connections.reload then
				self.connections.reload:Disconnect()
				self.connections.reload = nil
			end
		end

		-- Wait until gun finishes reloading
		if tick() < startTime + reloadTime then
			return
		end

		-- Add ammo to weapon
		if self.ammoInWeaponValue then
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		end

		if self.connections.reload then
			self.connections.reload:Disconnect()
			self.connections.reload = nil
		end

		self.reloading = false
		self.canReload = false
	end)
end

function BaseWeapon:cancelReload(player, fromNetwork)
	if not self.reloading then
		return
	end
	if fromNetwork and player == Players.LocalPlayer then
		return
	end

	if not IsServer and not fromNetwork and player == Players.LocalPlayer then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireServer(self.instance)
	elseif IsServer and fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireAllClients(player, self.instance)
	end

	self.reloading = false
	self.canReload = true

	if not IsServer and self.reloadTrack and self.reloadTrack.IsPlaying then
		warn("Stopping reloadTrack")
		self.reloadTrack:Stop()
	end
	if self.curReloadSound then
		self.curReloadSound:Stop()
		self.curReloadSound:Destroy()
		self.curReloadSound = nil
	end
end

function BaseWeapon:getAmmoInWeapon()
	if self.ammoInWeaponValue then
		return self.ammoInWeaponValue.Value
	end
	return 0
end

function BaseWeapon:useAmmo(amount)
	if self.ammoInWeaponValue then
		local ammoUsed = math.min(amount, self.ammoInWeaponValue.Value)
		self.ammoInWeaponValue.Value = self.ammoInWeaponValue.Value - ammoUsed
		self.canReload = true
		return ammoUsed
	else
		return 0
	end
end

function BaseWeapon:renderCharge()

end

return BaseWeapon

end))
ModuleScript470.Name = "WeaponsSystem"
ModuleScript470.Parent = Folder341
table.insert(cors,sandbox(ModuleScript470,function()
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

-- Dependencies
local WeaponData = script.Parent:WaitForChild("WeaponData")
local WeaponsSystemFolder = script.Parent
local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local ShoulderCamera = require(Libraries:WaitForChild("ShoulderCamera"))
local WeaponsGui = require(Libraries:WaitForChild("WeaponsGui"))
local SpringService = require(Libraries:WaitForChild("SpringService"))
local ancestorHasTag = require(Libraries:WaitForChild("ancestorHasTag"))
ShoulderCamera.SpringService = SpringService

local Configuration = WeaponsSystemFolder:WaitForChild("Configuration")
local ConfigurationValues = {
	SprintEnabled = Configuration:WaitForChild("SprintEnabled"),
	SlowZoomWalkEnabled = Configuration:WaitForChild("SlowZoomWalkEnabled"),
}

local WEAPON_TAG = "WeaponsSystemWeapon"
local WEAPON_TYPES_LOOKUP = {}

local REMOTE_EVENT_NAMES = {
	"WeaponFired",
	"WeaponHit",
	"WeaponReloadRequest",
	"WeaponReloaded",
	"WeaponReloadCanceled",
	"WeaponActivated"
}
local REMOTE_FUNCTION_NAMES = {}

--Set up WeaponTypes lookup table
do
	local function onNewWeaponType(weaponTypeModule)
		if not weaponTypeModule:IsA("ModuleScript") then
			return
		end
		local weaponTypeName = weaponTypeModule.Name
		xpcall(function()
			coroutine.wrap(function()
				local weaponType = require(weaponTypeModule)
				assert(typeof(weaponType) == "table", string.format("WeaponType \"%s\" did not return a valid table", weaponTypeModule:GetFullName()))
				WEAPON_TYPES_LOOKUP[weaponTypeName] = weaponType
			end)()
		end, function(errMsg)
			warn(string.format("Error while loading %s: %s", weaponTypeModule:GetFullName(), errMsg))
			warn(debug.traceback())
		end)
	end
	for _, child in pairs(WeaponTypes:GetChildren()) do
		onNewWeaponType(child)
	end
	WeaponTypes.ChildAdded:Connect(onNewWeaponType)
end

local WeaponsSystem = {}
WeaponsSystem.didSetup = false
WeaponsSystem.knownWeapons = {}
WeaponsSystem.connections = {}
WeaponsSystem.networkFolder = nil
WeaponsSystem.remoteEvents = {}
WeaponsSystem.remoteFunctions = {}
WeaponsSystem.currentWeapon = nil
WeaponsSystem.aimRayCallback = nil

WeaponsSystem.CurrentWeaponChanged = Instance.new("BindableEvent")

local NetworkingCallbacks = require(WeaponsSystemFolder:WaitForChild("NetworkingCallbacks"))
NetworkingCallbacks.WeaponsSystem = WeaponsSystem

local _damageCallback = nil
local _getTeamCallback = nil

function WeaponsSystem.setDamageCallback(cb)
	_damageCallback = cb
end

function WeaponsSystem.setGetTeamCallback(cb)
	_getTeamCallback = cb
end

function WeaponsSystem.setup()
	if WeaponsSystem.didSetup then
		warn("Warning: trying to run WeaponsSystem setup twice on the same module.")
		return
	end
	print(script.Parent:GetFullName(), "is now active.")

	WeaponsSystem.doingSetup = true

	--Setup network routing
	if IsServer then
		local networkFolder = Instance.new("Folder")
		networkFolder.Name = "Network"

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			local remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = remoteEventName
			remoteEvent.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteEventName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteEvent \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnServerEvent:Connect(function(...)
				callback(...)
			end)
			WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			local remoteFunc = Instance.new("RemoteEvent")
			remoteFunc.Name = remoteFuncName
			remoteFunc.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteFuncName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteFunction \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			remoteFunc.OnServerInvoke = function(...)
				return callback(...)
			end
			WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
		end

		networkFolder.Parent = WeaponsSystemFolder
		WeaponsSystem.networkFolder = networkFolder
	else
		WeaponsSystem.StarterGui = game:GetService("StarterGui")

		WeaponsSystem.camera = ShoulderCamera.new(WeaponsSystem)
		WeaponsSystem.gui = WeaponsGui.new(WeaponsSystem)

		if ConfigurationValues.SprintEnabled.Value then
			WeaponsSystem.camera:setSprintEnabled(ConfigurationValues.SprintEnabled.Value)
		end
		
		if ConfigurationValues.SlowZoomWalkEnabled.Value then
			WeaponsSystem.camera:setSlowZoomWalkEnabled(ConfigurationValues.SlowZoomWalkEnabled.Value)
		end

		local networkFolder = WeaponsSystemFolder:WaitForChild("Network", math.huge)

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			coroutine.wrap(function()
				local remoteEvent = networkFolder:WaitForChild(remoteEventName, math.huge)
				local callback = NetworkingCallbacks[remoteEventName]
				if callback then
					WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnClientEvent:Connect(function(...)
						callback(...)
					end)
				end
				WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
			end)()
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			coroutine.wrap(function()
				local remoteFunc = networkFolder:WaitForChild(remoteFuncName, math.huge)
				local callback = NetworkingCallbacks[remoteFuncName]
				if callback then
					remoteFunc.OnClientInvoke = function(...)
						return callback(...)
					end
				end
				WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
			end)()
		end

		Players.LocalPlayer.CharacterAdded:Connect(WeaponsSystem.onCharacterAdded)
		if Players.LocalPlayer.Character then
			WeaponsSystem.onCharacterAdded(Players.LocalPlayer.Character)
		end

		WeaponsSystem.networkFolder = networkFolder
		WeaponsSystem.camera:setEnabled(true)
	end

	--Setup weapon tools and listening
	WeaponsSystem.connections.weaponAdded = CollectionService:GetInstanceAddedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponAdded)
	WeaponsSystem.connections.weaponRemoved = CollectionService:GetInstanceRemovedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponRemoved)

	for _, instance in pairs(CollectionService:GetTagged(WEAPON_TAG)) do
		WeaponsSystem.onWeaponAdded(instance)
	end

	WeaponsSystem.doingSetup = false
	WeaponsSystem.didSetup = true
end

function WeaponsSystem.onCharacterAdded(character)
	-- Make it so players unequip weapons while seated, then reequip weapons when they become unseated
	local humanoid = character:WaitForChild("Humanoid")
	WeaponsSystem.connections.seated = humanoid.Seated:Connect(function(isSeated)
		if isSeated then
			WeaponsSystem.seatedWeapon = character:FindFirstChildOfClass("Tool")
			humanoid:UnequipTools()
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		else
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			humanoid:EquipTool(WeaponsSystem.seatedWeapon)
		end
	end)
end

function WeaponsSystem.shutdown()
	if not WeaponsSystem.didSetup then
		return
	end

	for _, weapon in pairs(WeaponsSystem.knownWeapons) do
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons = {}

	if IsServer and WeaponsSystem.networkFolder then
		WeaponsSystem.networkFolder:Destroy()
	end
	WeaponsSystem.networkFolder = nil
	WeaponsSystem.remoteEvents = {}
	WeaponsSystem.remoteFunctions = {}

	for _, connection in pairs(WeaponsSystem.connections) do
		if typeof(connection) == "RBXScriptConnection" then
			connection:Disconnect()
		end
	end
	WeaponsSystem.connections = {}
end

function WeaponsSystem.getWeaponTypeFromTags(instance)
	for _, tag in pairs(CollectionService:GetTags(instance)) do
		local weaponTypeFound = WEAPON_TYPES_LOOKUP[tag]
		if weaponTypeFound then
			return weaponTypeFound
		end
	end

	return nil
end

function WeaponsSystem.createWeaponForInstance(weaponInstance)
	coroutine.wrap(function()
		local weaponType = WeaponsSystem.getWeaponTypeFromTags(weaponInstance)
		if not weaponType then
			local weaponTypeObj = weaponInstance:WaitForChild("WeaponType")

			if weaponTypeObj and weaponTypeObj:IsA("StringValue") then
				local weaponTypeName = weaponTypeObj.Value
				local weaponTypeFound = WEAPON_TYPES_LOOKUP[weaponTypeName]
				if not weaponTypeFound then
					warn(string.format("Cannot find the weapon type \"%s\" for the instance %s!", weaponTypeName, weaponInstance:GetFullName()))
					return
				end

				weaponType = weaponTypeFound
			else
				warn("Could not find a WeaponType tag or StringValue for the instance ", weaponInstance:GetFullName())
				return
			end
		end

		-- Since we might have yielded while trying to get the WeaponType, we need to make sure not to continue
		-- making a new weapon if something else beat this iteration.
		if WeaponsSystem.getWeaponForInstance(weaponInstance) then
			warn("Already got ", weaponInstance:GetFullName())
			warn(debug.traceback())
			return
		end

		-- We should be pretty sure we got a valid weaponType by now
		assert(weaponType, "Got invalid weaponType")

		local weapon = weaponType.new(WeaponsSystem, weaponInstance)
		WeaponsSystem.knownWeapons[weaponInstance] = weapon
	end)()
end

function WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not typeof(weaponInstance) == "Instance" then
		warn("WeaponsSystem.getWeaponForInstance(weaponInstance): 'weaponInstance' was not an instance.")
		return nil
	end

	return WeaponsSystem.knownWeapons[weaponInstance]
end

-- and (IsServer or weaponInstance:IsDescendantOf(Players.LocalPlayer))

function WeaponsSystem.onWeaponAdded(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not weapon then
		WeaponsSystem.createWeaponForInstance(weaponInstance)
	end
end

function WeaponsSystem.onWeaponRemoved(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if weapon then
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons[weaponInstance] = nil
end

function WeaponsSystem.getRemoteEvent(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteEvent = WeaponsSystem.remoteEvents[name]
	if IsServer then
		if not remoteEvent then
			warn("No RemoteEvent named ", name)
			return nil
		end

		return remoteEvent
	else
		if not remoteEvent then
			remoteEvent = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteEvent
	end
end

function WeaponsSystem.getRemoteFunction(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteFunc = WeaponsSystem.remoteFunctions[name]
	if IsServer then
		if not remoteFunc then
			warn("No RemoteFunction named ", name)
			return nil
		end

		return remoteFunc
	else
		if not remoteFunc then
			remoteFunc = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteFunc
	end
end

function WeaponsSystem.setWeaponEquipped(weapon, equipped)
	assert(not IsServer, "WeaponsSystem.setWeaponEquipped should only be called on the client.")
	if not weapon then
		return
	end

	local lastWeapon = WeaponsSystem.currentWeapon
	local hasWeapon = false
	local weaponChanged = false

	if lastWeapon == weapon then
		if not equipped then
			WeaponsSystem.currentWeapon = nil
			hasWeapon = false
			weaponChanged = true
		else
			weaponChanged = false
		end
	else
		if equipped then
			WeaponsSystem.currentWeapon = weapon
			hasWeapon = true
			weaponChanged = true
		end
	end

	if WeaponsSystem.camera then
		WeaponsSystem.camera:resetZoomFactor()
		WeaponsSystem.camera:setHasScope(false)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.camera:setZoomFactor(WeaponsSystem.currentWeapon:getConfigValue("ZoomFactor", 1.1))
			WeaponsSystem.camera:setHasScope(WeaponsSystem.currentWeapon:getConfigValue("HasScope", false))
		end
	end

	if WeaponsSystem.gui then
		WeaponsSystem.gui:setEnabled(hasWeapon)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.gui:setCrosshairWeaponScale(WeaponsSystem.currentWeapon:getConfigValue("CrosshairScale", 1))
		else
			WeaponsSystem.gui:setCrosshairWeaponScale(1)
		end
	end

	if weaponChanged then
		WeaponsSystem.CurrentWeaponChanged:Fire(weapon.instance, lastWeapon and lastWeapon.instance)
	end
end

function WeaponsSystem.getHumanoid(part)
	while part and part ~= workspace do
		if part:IsA("Model") and part.PrimaryPart and part.PrimaryPart.Name == "HumanoidRootPart" then
			return part:FindFirstChildOfClass("Humanoid")
		end

		part = part.Parent
	end
end

function WeaponsSystem.getPlayerFromHumanoid(humanoid)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and humanoid:IsDescendantOf(player.Character) then
			return player
		end
	end
end

local function _defaultDamageCallback(system, target, amount, damageType, dealer, hitInfo, damageData)
	if target:IsA("Humanoid") then
		target:TakeDamage(amount)
	end
end

function WeaponsSystem.doDamage(target, amount, damageType, dealer, hitInfo, damageData)
	if not target or ancestorHasTag(target, "WeaponsSystemIgnore") then
		return
	end
	if IsServer then
		if target:IsA("Humanoid") and dealer:IsA("Player") and dealer.Character then
			local dealerHumanoid = dealer.Character:FindFirstChildOfClass("Humanoid")
			local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
			if dealerHumanoid and target ~= dealerHumanoid and targetPlayer then
				-- Trigger the damage indicator
				WeaponData:FireClient(targetPlayer, "HitByOtherPlayer", dealer.Character.HumanoidRootPart.CFrame.Position)
			end
		end

		-- NOTE:  damageData is a more or less free-form parameter that can be used for passing information from the code that is dealing damage about the cause.
		-- .The most obvious usage is extracting icons from the various weapon types (in which case a weapon instance would likely be passed in)
		-- ..The default weapons pass in that data
		local handler = _damageCallback or _defaultDamageCallback
		handler(WeaponsSystem, target, amount, damageType, dealer, hitInfo, damageData)
	end
end

local function _defaultGetTeamCallback(player)
	return 0
end

function WeaponsSystem.getTeam(player)
	local handler = _getTeamCallback or _defaultGetTeamCallback
	return handler(player)
end

function WeaponsSystem.playersOnDifferentTeams(player1, player2)
	if player1 == player2 or player1 == nil or player2 == nil then
		-- This allows players to damage themselves and NPC's
		return true
	end

	local player1Team = WeaponsSystem.getTeam(player1)
	local player2Team = WeaponsSystem.getTeam(player2)
	return player1Team == 0 or player1Team ~= player2Team
end

return WeaponsSystem

end))
for i,v in pairs(mas:GetChildren()) do
	v.Parent = workspace
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end
